<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo教程</title>
      <link href="/2022/02/23/hexo%E6%95%99%E7%A8%8B/"/>
      <url>/2022/02/23/hexo%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post（新建发布文章）"><a href="#Create-a-new-post（新建发布文章）" class="headerlink" title="Create a new post（新建发布文章）"></a>Create a new post（新建发布文章）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server（开启服务）"><a href="#Run-server（开启服务）" class="headerlink" title="Run server（开启服务）"></a>Run server（开启服务）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files（重新生成静态页面）"><a href="#Generate-static-files（重新生成静态页面）" class="headerlink" title="Generate static files（重新生成静态页面）"></a>Generate static files（重新生成静态页面）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites（发送到远端github服务）"><a href="#Deploy-to-remote-sites（发送到远端github服务）" class="headerlink" title="Deploy to remote sites（发送到远端github服务）"></a>Deploy to remote sites（发送到远端github服务）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="新增-categories-分类页面"><a href="#新增-categories-分类页面" class="headerlink" title="新增 categories 分类页面"></a>新增 categories 分类页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page k8s</span><br></pre></td></tr></table></figure><ul><li><p>配置</p><p>打开 blog&#x2F;source&#x2F;k8s&#x2F;index.md，默认是下列内容：</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;---</span><br><span class="line">&gt;title: 分类</span><br><span class="line">&gt;date: 2018-10-22 14:25:08</span><br><span class="line">&gt;---</span><br></pre></td></tr></table></figure></blockquote><p>修改为：</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-10-22 14:25:08</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>新建文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;k8s集群搭建&quot;</span></span><br></pre></td></tr></table></figure><p>打开 blog&#x2F;source&#x2F;_posts&#x2F;k8s集群搭建.md, 默认头部信息如下:</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;---</span><br><span class="line">&gt;title: k8s集群搭建</span><br><span class="line">&gt;date: 2018-10-22 23:03:42</span><br><span class="line">&gt;tags:</span><br><span class="line">&gt;---</span><br></pre></td></tr></table></figure></blockquote><p>修改为</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;---</span><br><span class="line">&gt;title: k8s集群搭建</span><br><span class="line">&gt;comments: true</span><br><span class="line">&gt;date: 2018-10-22 23:03:42</span><br><span class="line">&gt;updated: 2019-10-22 23:03:42</span><br><span class="line">&gt;desc: 云服务器k8s集群搭建</span><br><span class="line">&gt;categories:</span><br><span class="line"><span class="bullet">-</span> k8s</span><br><span class="line">&gt;tags: [k8s]</span><br><span class="line">&gt;keywords: k8s, cloudnative</span><br><span class="line">&gt;---</span><br><span class="line">&gt;## k8s 集群搭建</span><br><span class="line">&gt;具体的文章内容..........</span><br></pre></td></tr></table></figure></blockquote></li><li><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可在本地查看刚才新建的文章效果</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq</title>
      <link href="/2022/02/23/rabbitmq/"/>
      <url>/2022/02/23/rabbitmq/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s命令</title>
      <link href="/2022/02/22/k8s%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/02/22/k8s%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-master节点"><a href="#1-master节点" class="headerlink" title="1. master节点"></a>1. master节点</h2><ol><li><p><strong>查看node节点加入命令</strong> </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure></li><li><p><strong>查看创建节点日志</strong>  </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl describe pods -l app=$&#123;pod_name&#125;</span><br><span class="line">      </span><br><span class="line">&gt; kubectl describe pod $&#123;pod_name&#125; -n $&#123;name_space&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>重启k8s集群</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      master节点执行：</span><br><span class="line">      &gt; kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">      &gt; kubectl delete node k8s-node1</span><br><span class="line">      在相应node节点执行：</span><br><span class="line">      &gt; kubeadm reset</span><br><span class="line">      &gt; rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d</span><br><span class="line">  </span><br><span class="line">      master节点执行：</span><br><span class="line">&gt; kubectl drain k8s-node2 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">&gt; kubectl delete node k8s-node2</span><br><span class="line">在相应node节点执行:</span><br><span class="line">&gt; kubeadm reset</span><br><span class="line">      &gt; rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d</span><br><span class="line">      </span><br><span class="line">      删除master节点：</span><br><span class="line">&gt; kubectl drain k8s-master --delete-local-data --force --ignore-daemonsets</span><br><span class="line">&gt; kubectl delete node k8s-master</span><br><span class="line">&gt; kubeadm reset</span><br><span class="line">   &gt; rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d</span><br></pre></td></tr></table></figure></li><li><p><strong>实时查看 Deployment 对象的状态变化</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl rollout status deployment/$&#123;deployment_name&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改镜像信息信息</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl set image deployment/nginx-deployment nginx=nginx:1.91</span><br></pre></td></tr></table></figure></li><li><p><strong>回滚上一版本</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li><li><p><strong>查看Deployment 变更对应的版本</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl rollout history deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li><li><p><strong>回滚到执行版本</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure></li><li><p><strong>暂停滚动更新</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl rollout pause deployment/nginx-deployment</span><br></pre></td></tr></table></figure><p>  <font color=orange>因为我们每修改一次deployment，都会生成一个新的ReplicaSet对象，这样显得有些多余和浪费资源，所以，当我们需要修改deployment的时候，先暂时暂停滚动更新，等到我们一次性修改完成后，再重新恢复即可。</font></p></li><li><p><strong>恢复滚动更新</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl rollout resume deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-node节点"><a href="#2-node节点" class="headerlink" title="2. node节点"></a>2. node节点</h2>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存数据库数据一致性保证演进过程</title>
      <link href="/2021/12/23/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/12/23/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="DTC-解决的业务痛点"><a href="#DTC-解决的业务痛点" class="headerlink" title="DTC 解决的业务痛点"></a>DTC 解决的业务痛点</h1><hr><h2 id="1-缓存数据库一致性问题"><a href="#1-缓存数据库一致性问题" class="headerlink" title="1. 缓存数据库一致性问题"></a>1. 缓存数据库一致性问题</h2><ul><li><h3 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h3><ol><li><blockquote><p><strong>全量数据刷新缓存</strong> </p><ul><li>数据库的数据,全量刷入缓存（不设置失效时间）。</li><li>写请求只更新数据库，不更新缓存。</li><li>启动一个定时任务，定时把数据库的数据，更新到缓存中。</li></ul></blockquote><p><font color="green" ><b>优点:</b></font> </p><ul><li>读请求可以直接命中缓存，不需查库，所以性能高。</li></ul><p><font color="red" ><b>缺点:</b></font>  </p><ol><li>缓存利用率低: 不经常使用的数据还一直留在缓存中，全量数据，耗费缓存空间;</li><li>数据不一致: 定时刷新缓存，缓存中数据的更新节点完全依赖于定时任务频率和执行效率。</li></ol></li><li><blockquote><p><strong>优化缓存利用率低和一致性</strong> </p><ul><li>写请求只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存。</li><li>同时，写入缓存的数据，都设置失效时间。</li></ul></blockquote><p><font color="green" ><b>优点:</b></font></p><ul><li>缓存中设置了过期时间，这样，缓存中保存的都是热点数据，解决了缓存利用率问题.</li></ul><p> <font color="red" ><b>缺点:</b></font></p><ul><li><p><strong>异常引发数据不一致问题（这里分两种情况讨论）:</strong> </p><p>① <font color="Coral" face="华文彩云"><b>「先更新缓存，后更新数据库」</b></font> </p><p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库是<font color="Maroon">「旧值」</font>。</p><p>虽然此时读请求可以命中缓存，拿到正确的值，但是一旦<font color="Maroon">「缓存失效」</font>。 <br>就会从数据库中读取<font color="Maroon">「旧值」</font>， 这时更新进缓存的也是这个旧值。</p><p>这时，用户就会发现之前修改过的数据，突然又<font color="Maroon">「变回去」</font>了。</p><p>② <font color="Coral" face="华文彩云"><b>「先更新数据库，后更新缓存」</b></font> </p><p>数据库更新成功，写缓存失败，那么数据库是最新值，缓存中是<font color="Maroon">「旧值」</font>。</p><p>这时用户从缓存中读到的全是旧数据，直到<font color="Maroon">「缓存失效」</font>后，读数据库才能读到最新的值。</p><p>这时用户发现，自己修改的值，迟迟不能生效。</p></li><li><p><strong>并发引发数据不一致问题:</strong> </p><p>① <font color="Coral" face="华文彩云"><b> 「先更新缓存，后更新数据库」</b></font></p><p>  接下来我们看，即使数据库和缓存都更新成功，会不会就没什么问题了？</p><p>  假设现在又线程 A 和线程 B 两个线程，需要更新<font color="Maroon">「同一条」</font>数据，时序如下:</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1): 线程 A 更新数据库 (X = 1) </span><br><span class="line">T2): 线程 B 更新数据库 (X = 2) </span><br><span class="line">T3): 线程 B 更新缓存 (X = 2) </span><br><span class="line">T4): 线程 A 更新缓存 (X = 1) </span><br></pre></td></tr></table></figure><p>  最后结果：缓存中（X&#x3D;1） 数据库（X&#x3D;2），从而造成数据不一致。</p><p>② <font color="Coral" face="华文彩云"><b>「先更新数据库，后更新缓存」</b></font></p><p>   同 ① ，这里不在详述。</p></li><li><p><strong>缓存利用率低</strong> </p><p>因为该方案是每次数据库发生变更，都会去写缓存，但是缓存中的数据很多都不会被访问到，留在内存中耗费资源。</p></li></ul></li><li><blockquote><p><strong>旁路缓存策略方案</strong>  </p><ul><li>读请求先读缓存，缓存不命中，再读库</li><li>写请求做两个动作：写数据库+删除数据缓存</li></ul></blockquote><p><font color="red" ><b>缺点:</b></font></p><ul><li><p><strong>异常引发数据不一致问题（这里分两种情况讨论）:</strong> </p><p>  这里的场景和 ii.中的异常场景相同，两步中只要有其中一步发生失败，就会引发数据不一致。</p></li><li><p><strong>并发引发数据不一致问题:</strong></p><p>  ① <font color="Coral" face="华文彩云"><b>「先删除缓存，后更新数据库」</b></font> </p><p>  如果有 2 个线程要并发<font color="Maroon">「读写」</font> 数据，可能会发生以下场景:</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T1): 线程 A 要更新 X = 2 (原值 X = 1)</span><br><span class="line">     </span><br><span class="line">T2): 线程 A 删除缓存</span><br><span class="line">     </span><br><span class="line">T3): 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</span><br><span class="line">     </span><br><span class="line">T4): 线程 A 将新值写入数据库 (X = 2)</span><br><span class="line">     </span><br><span class="line">T5): 线程 B 将旧值写入缓存 (X = 1)</span><br><span class="line">     </span><br><span class="line">T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 发生不一致。</span><br></pre></td></tr></table></figure><p>  可见，先删除缓存，再更新数据库，当发生<font color="Maroon">「读+写」</font> 并发时，存在数据不一致的情况。</p><p>  ② <font color="Coral" face="华文彩云"><b>「先更新数据库，后删除缓存」</b></font></p><p>  依旧是 2 个线程要并发<font color="Maroon">「读写」</font> 数据。</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T1): 缓存中 X 不存在（数据库 X = 1）</span><br><span class="line"></span><br><span class="line">T2): 线程 A 读取数据库，得到旧值 (X = 1)</span><br><span class="line"></span><br><span class="line">T3): 线程 B 更新数据库（X = 2）</span><br><span class="line"></span><br><span class="line">T4): 线程 B 删除缓存</span><br><span class="line"></span><br><span class="line">T5): 线程 A 将旧值写入缓存 (X = 1)</span><br><span class="line"></span><br><span class="line">T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 也发生不一致。</span><br></pre></td></tr></table></figure><p>  其实这个方案就是算是<font color="Maroon">「旁路缓存」</font>策略的实现方案；</p><p>  仔细思考以下，这种情况理论来说是可能发生的，但实际上发生的概率是<font color="Maroon">「极低」</font>的。</p><p>  因为它必须满足 3 个条件:</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-: 缓存刚好失效</span><br><span class="line">       </span><br><span class="line">2-: 读请求 + 写请求并发</span><br><span class="line">       </span><br><span class="line">3-: 更新数据库 + 删除缓存的时间(T3+T4) &gt; 读数据库 + 写缓存时间 (T2 + T5) </span><br></pre></td></tr></table></figure><p>  <font color="SeaGreen"><b>因为写数据库通常有加锁操作，所以写数据库通常要比读数据库的时间要长，所以，条件3发生的概率极低。<br>  这个策略也是我用在<font color="Maroon">「成长值账户」</font>中的缓存策略；</b></font></p>  <p>  ________________________________________________________________________________________________________________________  <font color="Maroon">前面说过异常情况，无论是更新缓存还是删除缓存，只要第二步发生失败，就会导致数据库和缓存不一致。</font> <p>  那么这里我们再回过头来讨论下<font color="Maroon">「旁路缓存策略」</font> - <font color="Coral" face="华文彩云"><b>「先更新数据库，后删除缓存」</b></font> 策略异常情况下，我们如何保证第二步执行成功？</p>  </p></li><li><p><strong><font color="Maroon">重试</font></strong> </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果更新数据库成功，删除缓存失败，这里我们就可以无脑的在业务代码中，一直尝试删除缓存；</span><br><span class="line">但是这种方案往往存在以下问题：</span><br><span class="line">1-: 失败后立即重试，大概率还会「失败」（网络抖动，或者服务异常）;</span><br><span class="line">2-: 「重试次数」我们要设置多少才是合理值？</span><br><span class="line">3-: 重试会一直「占用」线程资源，无法服务其它请求。</span><br></pre></td></tr></table></figure><p>基于以上结论，我们发现这种<font color="Maroon">「同步重试」</font>方式往往不能解决根本问题。</p></li><li><p><strong><font color="Maroon">异步重试</font></strong> </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步重试步骤：</span><br><span class="line">1-: 更新数据库后，发消息到消息队列。</span><br><span class="line">2-: 消费者消费队列消息。</span><br><span class="line">3-: 删除对应的缓存信息。</span><br></pre></td></tr></table></figure><p>这个方案除了需要维护一个重的「消息队列」服务外，看似好像是无懈可击的方案，但是该方案也有一个致命的漏洞，<br>那就是，数据库主从延迟，基于前面我们讨论的并发情况，写数据库往往是操作主库，查库往往是操作从库，所以，<br>会存在，主库处理玩，然后缓存清理后，从库还是旧数据的情况，那么用户从从库中读取旧数据，更新到缓存中时，还是<br>会出现数据不一致的情况。</p><p>基于以上总总方案，所以我们引入最终的解决方案:</p></li><li><p><strong><font color="Maroon">订阅数据库变更日志，再操作缓存</font></strong> </p><p>引入binlog 监控组件 canal 监控binlog变更日志。</p><p><font color="green" ><b>优点:</b></font></p><ul><li>业务只操作数据，无需考虑缓存以及其它相关业务是失败情况，只要写库成功，就会有binlog，<br>余下的工作旧交由下游业务处理，使得业务更加轻量化和简洁化。</li><li>canal 不作为master的slave，而是作为一个slave的slave，规避主从延迟造成的数据不一致。</li><li>利用binlog 本身的有序性，完全避免并发中的数据不一致问题。</li></ul></li></ul></li></ol></li></ul><h2 id="2-数据变更业务埋点"><a href="#2-数据变更业务埋点" class="headerlink" title="2. 数据变更业务埋点"></a>2. 数据变更业务埋点</h2><ul><li><h3 id="券变更通知用户业务"><a href="#券变更通知用户业务" class="headerlink" title="券变更通知用户业务"></a>券变更通知用户业务</h3><ol><li><blockquote><p><strong>传统做法</strong></p><ul><li>在每一个涉及券变动的业务中设置业务埋点</li><li>动态的更新缓存</li></ul></blockquote></li></ol><p>  <font color="red" ><b>缺点:</b></font></p><ol><li>极大的增加业务代码的复杂度。</li><li>极大的增加业务出错概率。</li><li>缓存不一致问题。</li></ol><p>  <font color="Green" ><b>解决方案: canal + kafka</b></font> </p><ol><li>出错率低</li><li>kafka 持久化，失败重试。</li><li>和业务主流程解耦。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka最佳配置实践</title>
      <link href="/2021/12/23/kafka%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/12/23/kafka%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-broker端"><a href="#1-broker端" class="headerlink" title="1. broker端"></a>1. broker端</h2><ul><li><h3 id="broker集群参数"><a href="#broker集群参数" class="headerlink" title="broker集群参数"></a>broker集群参数</h3><ol><li><blockquote><p><strong>log.dirs</strong>: <br>  这是非常重要的参数，指定了 Broker 需要使用的若干个文件目录路径。要知道这个参数是没有默认值的，这说明什么？这说明它必须由你亲自指定。<br>  <strong>log.dir</strong>: <br>  注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。<br>  <font face="幼圆" color="YellowGreen"> <br>  这两个参数应该怎么设置呢？很简单，你只要设置log.dirs，即第一个参数就好了，不要设置log.dir。<br>  而且更重要的是，在线上生产环境中一定要为log.dirs配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径，<br>  比如&#x2F;home&#x2F;kafka1,&#x2F;home&#x2F;kafka2,&#x2F;home&#x2F;kafka3这样。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。</font></p></blockquote></li><li><blockquote><p><strong>zookeeper.connect</strong> <br>  如果我们是单集群，那么很简单，直接设置zookeeper.connect&#x3D;zk1:2181,zk2:2181,zk3:2181即可。 <br>  <font face="幼圆" color="YellowGreen"> <br>  这里我们主要考虑多套kafka集群公用一套zookeeper集群, 这时候我们要使用 zookeeper的 chroot，文件挂载方式实现 \<br>  如果有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的zookeeper.connect参数可以这样指定：<br>  zk1:2181,zk2:2181,zk3:2181&#x2F;kafka1和zk1:2181,zk2:2181,zk3:2181&#x2F;kafka2。<br>  切记 chroot 只需要写一次，而且是加到最后的。\</p>  </font>  <font color=red>zk1:2181/kafka1,zk2:2181/kafka2,zk3:2181/kafka3</font> 这样的格式是不对的。</blockquote></li><li><blockquote><p><strong>listeners: PLAINTEXT:&#x2F;&#x2F;host:9092</strong> <br>  监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。<br>  <font face="幼圆" color="YellowGreen"> <br>  从构成上来说，它是若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;。<br>  这里的协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；<br>  也可能是你自己定义的协议名字，比如CONTROLLER: &#x2F;&#x2F;localhost:9092。<br>  一旦你自己定义了协议名称，你必须还要指定listener.security.protocol.map参数告诉这个协议底层使用了哪种安全协议，<br>  比如指定listener.security.protocol.map&#x3D;CONTROLLER:PLAINTEXT表示CONTROLLER这个自定义协议底层使用明文不加密传输数据。</p>  </font></blockquote></li><li><blockquote><p><strong>advertised.listeners</strong> <br>  和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。</p></blockquote></li><li><blockquote><p><strong>auto.create.topics.enable&#x3D;false</strong> \<br>  是否允许自动创建 Topic。<br>  <font face="幼圆" color="YellowGreen"> <br>  建议最好设置成 false，即不允许自动创建 Topic。<br>  Topic 应该由运维严格把控，决不能允许自行创建任何 Topic</p>  </font></blockquote></li><li><blockquote><p><strong>unclean.leader.election.enable&#x3D;false</strong> <br>  是否允许 Unclean Leader 选举。<br>  <font face="幼圆" color="YellowGreen"> <br>  坚决不能让那些落后太多的副本竞选 Leader。</font></p></blockquote></li><li><blockquote><p><strong>auto.leader.rebalance.enable&#x3D;false</strong> <br>  是否允许定期进行 Leader 选举。<br>  <font face="幼圆" color="YellowGreen"> <br>  换一次 Leader 代价很高的，原本向 A 发送请求的所有客户端都要切换成向 B 发送请求，而且这种换 Leader 本质上没有任何性能收益。<br>  所以建议你在生产环境中把这个参数设置成 false。</font></p></blockquote></li><li><blockquote><p><strong>log.retention.{hours|minutes|ms}</strong> <br>  控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低。<br>  <font face="幼圆" color="YellowGreen"> <br>  虽然 ms 设置有最高的优先级，但是通常情况下我们还是设置 hours 级别的多一些，比如log.retention.hours&#x3D;168表示默认保存 7 天的数据，自动删除 7 天前的数据。<br>  如果把 Kafka 当作存储来使用，那么这个值就要相应地调大。</p>  </font></blockquote></li><li><blockquote><p><strong>log.retention.bytes</strong> <br>  指定 Broker 为消息保存的总磁盘容量大小。<br>  <font face="幼圆" color="YellowGreen"> <br>  这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以，至少在容量方面 Broker 绝对为你开绿灯，不会做任何阻拦。<br>  这个参数真正发挥作用的场景其实是在云上构建多租户的 Kafka 集群：设想你要做一个云上的 Kafka 服务，每个租户只能使用 100GB 的磁盘空间，<br>  为了避免有个“恶意”租户使用过多的磁盘空间，设置这个参数就显得至关重要了。</p>  </font>   </blockquote></li><li><blockquote><p><strong>message.max.bytes</strong> <br>  控制 Broker 能够接收的最大消息大小。<br>  <font face="幼圆" color="YellowGreen"> <br>   默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，<br>   因此在线上环境中设置一个比较大的值还是比较保险的做法。<br>   毕竟它只是一个标尺而已，仅仅衡量 Broker 能够处理的最大消息大小，即使设置大一点也不会耗费什么磁盘空间的。</p>  </font></blockquote></li></ol></li><li><h3 id="防消息丢失"><a href="#防消息丢失" class="headerlink" title="防消息丢失"></a>防消息丢失</h3><ol><li><blockquote><p><strong>unclean.leader.election.enable &#x3D; false</strong> <br>  它控制的是哪些 Broker 有资格竞选分区的 Leader。 <br>  <font face="幼圆" color="YellowGreen"> <br>  如果一个 Broker 落后原先的 Leader 太多，<br>  那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p>  </font></blockquote></li><li><blockquote><p><strong>replication.factor &gt;&#x3D; 3</strong> <br>  副本数，最好将消息多保存几份，防止消息丢失的主要机制就是冗余。</p></blockquote></li><li><blockquote><p><strong>min.insync.replicas &gt; 1</strong> <br>  该参数控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。<br>  千万不要使用默认值 1。 </p></blockquote></li><li><blockquote><p>确保 <strong>replication.factor &gt; min.insync.replicas</strong><br>  如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。<br>  推荐设置成 replication.factor &#x3D; min.insync.replicas + 1。</p></blockquote></li></ol></li><li><h3 id="调优吞吐量"><a href="#调优吞吐量" class="headerlink" title="调优吞吐量"></a>调优吞吐量</h3><ol><li><blockquote><p><strong>num.replica.fetchers&#x3D;不要超过cpu核心数</strong> <br>  该参数值表示的是 Follower 副本用多少个线程来拉取消息，默认使用 1 个线程。<br>  <font face="幼圆" color="YellowGreen"> <br>  如果你的 Broker 端 CPU 资源很充足，不妨适当调大该参数值，加快 Follower 副本的同步速度。<br>  因为在实际生产环境中，配置了 acks&#x3D;all 的 Producer 程序吞吐量被拖累的首要因素，就是副本同步性能。<br>  增加这个值后，你通常可以看到 Producer 端程序的吞吐量增加。\</p>  </font></blockquote></li><li><blockquote><p><strong>调优JVM参数，避免频繁fullGC</strong> </p><ul><li>设置堆大小(6<del>8GB)<br> <font face="幼圆" color="YellowGreen"> <br> 6</del>8GB是一个普适的值，可以安心使用，如果想精确调整，建议你可以查看 GC log，<br> 特别是关注 Full GC 之后堆上存活对象的总大小，然后把堆大小设置为该值的 1.5～2 倍。<br> 如果你发现 Full GC 没有被执行过，手动运行 jmap -histo:live &lt; pid &gt; 就能人为触发 Full GC。\ </font>  &nbsp; </li><li>GC收集器选择(G1)<br> <font face="幼圆" color="YellowGreen"> <br>  竭力避免 Full GC : 如果你的 Kafka 环境中经常出现 Full GC，你可以配置 JVM 参数 -XX:+PrintAdaptiveSizePolicy，来探查一下到底是谁导致的 Full GC。<br>  大对象 :  所谓的大对象，一般是指至少占用半个区域（Region）大小的对象。举个例子，如果你的区域尺寸是 2MB，那么超过 1MB 大小的对象就被视为是大对象。要解决这个问题，除了增加堆大小之外，你还可以适当地增加区域大小，设置方法是增加 JVM 启动参数 -XX:+G1HeapRegionSize&#x3D;N。默认情况下，如果一个对象超过了 N&#x2F;2，就会被视为大对象，从而直接被分配在大对象区。如果你的 Kafka 环境中的消息体都特别大，就很容易出现这种大对象分配的问题。 </font></li></ul></blockquote></li></ol></li><li><h3 id="调优延时"><a href="#调优延时" class="headerlink" title="调优延时"></a>调优延时</h3><ol><li><blockquote><p><strong>num.replica.fetchers</strong> <br>  <font face="幼圆" color="YellowGreen"> <br>  增加 num.replica.fetchers 值以加快 Follower 副本的拉取速度，减少整个消息处理的延时。</p>  </font></blockquote><h2 id="2-producer-端"><a href="#2-producer-端" class="headerlink" title="2. producer 端"></a>2. producer 端</h2></li></ol></li><li><h3 id="防消息丢失-1"><a href="#防消息丢失-1" class="headerlink" title="防消息丢失"></a>防消息丢失</h3><ol><li><blockquote><p>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。</p></blockquote></li><li><blockquote><p><strong>acks &#x3D; all</strong> <br>  acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。<br>  如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p></blockquote></li><li><blockquote><p><strong>retries &gt; 0</strong> <br>  设置 retries 为一个较大的值。这里的 retries 为自动重试次数。、<br>  当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p></blockquote></li></ol></li><li><h3 id="调优吞吐量-1"><a href="#调优吞吐量-1" class="headerlink" title="调优吞吐量"></a>调优吞吐量</h3><ol><li><blockquote><p><strong>batch.size&#x3D;1048576</strong> <br>  该参数值代表生产者一批次发送多少字节大小的数据；<br>  <font face="幼圆" color="YellowGreen"> <br>  如果你想要增加吞吐量，那么尽量调大该参数值，该值默认16KB，<br>  假设你的消息体大小是 1KB，默认一个消息批次也就大约 16 条消息，显然太小了。<br>  我们还是希望 Producer 能一次性发送更多的消息。</p>  </font></blockquote></li><li><blockquote><p><strong>linger.ms</strong> <br>  该值是和batch.size配对使用的参数，表示每批次缓存时间；<br>  <font face="幼圆" color="YellowGreen"> <br>  也就是说，如果你设置batch.size&#x3D;5000，<br>  如果从上一发送批次发送到现在时间，超过了linger.ms设置的时间，那么即使未达到batch.size设置的5000，这时候也会发送。</p>  </font></blockquote></li><li><blockquote><p><strong>compression.type&#x3D;lz4&#x2F;zstd</strong> <br>  配置压缩算法，减少I&#x2F;O传输量，从而提升吞吐量。<br>  <font face="幼圆" color="YellowGreen"> <br>  当前，和 Kafka 适配最好的两个压缩算法是 LZ4 和 zstd，不妨一试。</p>  </font></blockquote></li><li><blockquote><p><strong>acks&#x3D;0&#x2F;1</strong> <br>  该参数设置是和防消息丢失配置想违背，如果你追求高吞吐量，那么就要承担消息丢失的风险。<br>  <font face="幼圆" color="YellowGreen"> <br>  设置为 0, 可以不必等待副本确认就可以直接返回处理下一批数据；<br>  设置为 1, 也只需等待一个broker副本确认提交成功，就进行下一批数据处理。</p>  </font></blockquote></li><li><blockquote><p><strong>retries&#x3D;0</strong> <br>  这个参数也和防消息丢失的配置相违背，同样的追求高吞吐量，就必须承担消息丢失风险。<br>  <font face="幼圆" color="YellowGreen"> <br>  禁用重试当然会提高吞吐量，但是消息发送正确性就得不到保障，这里还是要根据自己的业务做合适的参数调整。</p>  </font></blockquote></li><li><blockquote><p><strong>buffer.memory</strong> <br>  <font face="幼圆" color="YellowGreen"> <br>  如果你在多个线程中共享一个 Producer 实例，就可能会碰到缓冲区不够用的情形。<br>  倘若频繁地遭遇 TimeoutException：Failed to allocate memory within the configured max blocking time 这样的异常，<br>  那么你就必须显式地增加 buffer.memory 参数值，确保缓冲区总是有空间可以申请的。</p>  </font></blockquote></li></ol></li><li><h3 id="调优延时-1"><a href="#调优延时-1" class="headerlink" title="调优延时"></a>调优延时</h3><ol><li><blockquote><p><strong>linger.ms&#x3D;0</strong> <br>  <font face="幼圆" color="YellowGreen"> <br>  低延时，就是我们希望要把消息尽快的送出去，所以，设置这个参数为 0，意味着只要有消息就发送，不用等待。</p>  </font></blockquote></li><li><blockquote><p><strong>compression.type&#x3D;none</strong> <br>  不要设置压缩算法。<br><font face="幼圆" color="YellowGreen"> <br>毕竟压缩也是要耗费一定的时间的。</p></font></blockquote></li><li><blockquote><p><strong>acks&#x3D;1</strong> <br>  该值参数尽量设置的小一点。<br>  <font face="幼圆" color="YellowGreen"> <br>  Follower 副本同步往往是降低 Producer 端吞吐量和增加延时的首要原因。</p>  </font></blockquote><h2 id="3-consumer-端"><a href="#3-consumer-端" class="headerlink" title="3. consumer 端"></a>3. consumer 端</h2></li></ol></li><li><h3 id="防消息丢失-2"><a href="#防消息丢失-2" class="headerlink" title="防消息丢失"></a>防消息丢失</h3><ol><li><blockquote><p><strong>enable.auto.commit&#x3D;false</strong> <br>  确保消息消费完成再提交。并采用手动提交位移的方式。<br>  这对于单 Consumer 多线程处理的场景而言是至关重要的。</p></blockquote></li></ol></li><li><h3 id="调优吞吐量-2"><a href="#调优吞吐量-2" class="headerlink" title="调优吞吐量"></a>调优吞吐量</h3><ol><li><blockquote><p><strong>采用多 Consumer 进程或线程同时消费数据。</strong> <br>  适当采用多线程方案增加吞吐量。<br>  <font face="幼圆" color="YellowGreen"> <br>  不过该方案在实施起来是有一定的复杂度的，操作不当还会造成数据丢失，<br>  我在项目中也写了一个多线程消费者的案例，欢迎大家来讨论。</p>  </font></blockquote></li><li><blockquote><p><strong>fetch.min.bytes</strong> <br>  该参数表示 Kafka Broker 端积攒多少字节，就可以返回给 Consumer端。<br>  <font face="幼圆" color="YellowGreen"> <br>  默认是 1 字节，表示只要 Kafka Broker 端积攒了 1 字节的数据，就可以返回给 Consumer 端，<br>  这实在是太小了。我们还是让 Broker 端一次性多返回点数据吧。</p>  </font></blockquote></li></ol></li><li><h3 id="调优延时-2"><a href="#调优延时-2" class="headerlink" title="调优延时"></a>调优延时</h3><ol><li><blockquote><p><strong>fetch.min.bytes&#x3D;1</strong> <br>  <font face="幼圆" color="YellowGreen"> <br>  在 Consumer 端，我们保持 fetch.min.bytes&#x3D;1 即可，也就是说，<br>  只要 Broker 端有能返回的数据，立即令其返回给 Consumer，缩短 Consumer 消费延时。</p>  </font></blockquote></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql命令</title>
      <link href="/2020/02/23/mysql%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/23/mysql%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络设备状态标识</title>
      <link href="/2019/09/17/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86/"/>
      <url>/2019/09/17/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下网络设备的各个标志都是什么意思；<br>我这里以我的一台虚拟机机为例（虚拟软件：virtualbox，系统：centos7）<br>首先我们运行命令：ip addr 查看网络设备信息：</p></blockquote><p>![image-20220223150205002](&#x2F;Users&#x2F;mayi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220223150205002.png)</p><ol><li><p>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; :net_device flags，网络设备的状态标识</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BROADCAST：表示这个网卡有广播地址，可以发送广播包；</span><br><span class="line">MULTICAST：表示这个网卡可以发送多播包；</span><br><span class="line">UP：表示网卡处于启动状态；</span><br><span class="line">LOWER<span class="built_in">_</span>UP：表示L1是启动的，也就是插着网线；</span><br></pre></td></tr></table></figure></li><li><p>mtu 1500</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MTU: 是二层 MAC 层的概念。</span><br><span class="line">     MAC 层有 MAC 的头，mtu 1500就表示-以太网规定MAC和正文加起来不能超过1500字节。</span><br></pre></td></tr></table></figure></li><li><p>qdisc pfifo_fast：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qdisc: 是queueing discipline （排队规则），内核如果需要通过某个网络接口发送数据包，他们都需要按这个接口配置的 qdisc 把数据包加入队列；</span><br></pre></td></tr></table></figure></li><li><p>scope global : </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在ip地址后面有一个scope global，global说明这张网卡是可以对外的，可以接受来自任何地方的包。</span><br></pre></td></tr></table></figure></li><li><p>scope host :</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像lo这里是个scope host，说明这张网卡仅可以提供本机相互通信。</span><br><span class="line">lo 全称是loopback，又称环回接口，往往会被分配到127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2019/04/13/linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/04/13/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h3><ol><li><p>目录示意</p><ul><li>&#x2F;:根目录<br>整个文件系统，有一个顶层目录，称为根。 bin:存放一些可执行的程序、命令。</li><li>boot: 系统启动所需的一些文件。</li><li>dev:系统中的设备(硬件在linux中通过“文件”来标识) etc:存放系统、软件的配置文件</li><li>home:普通用户目录的主目录，以用户名命名。</li><li>home&#x2F;fred lib:系统库目录(32位)</li><li>lib64: 系统库目录(64位)</li><li>media:媒体</li><li>mnt:挂载外部存储设备的文件目录</li><li>opt</li><li>proc</li><li>root:root用户的主目录</li><li>run</li><li>sbin:系统的可执行命令</li><li>srv</li><li>sys</li><li>test</li><li>tmp:系统临时目录 usr:共享资源目录(多个用户可以共享该目录中的程序)</li><li>var</li></ul></li><li><p>命令</p><ul><li><p>ls命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /: 查看根目录</span><br><span class="line"><span class="built_in">ls</span> -l: 显示详细信息</span><br><span class="line"><span class="built_in">ls</span> -lh: 显示跟符合人类查看方式 </span><br><span class="line"><span class="built_in">ls</span> -a: 显示隐藏文件</span><br></pre></td></tr></table></figure></li><li><p>目录切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>: 查看当前所在目录</span><br><span class="line"><span class="built_in">cd</span>: 切换目录</span><br><span class="line"><span class="built_in">cd</span> ...: 退回到上一级目录<span class="built_in">cat</span></span><br></pre></td></tr></table></figure></li><li><p>创建文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aaa: 相对路径写法</span><br><span class="line"><span class="built_in">mkdir</span> /bbb: 绝对路径写法</span><br><span class="line"><span class="built_in">mkdir</span> -p aaa/bbb/ccc: 级联创建目录</span><br></pre></td></tr></table></figure></li><li><p>删除目录&#x2F;文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span>: 删除目录</span><br><span class="line"><span class="built_in">rm</span> -r: 递归删除</span><br><span class="line"><span class="built_in">rm</span> -rf: 递归删除，不提示</span><br></pre></td></tr></table></figure></li><li><p>查看信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span>: 创建空文件</span><br><span class="line"><span class="built_in">cat</span>: 查看文件内容</span><br></pre></td></tr></table></figure></li><li><p>编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi : 编辑文件</span><br><span class="line">-i: 编辑模式 </span><br><span class="line">-o: 编辑模式(直接到下一行)</span><br><span class="line">-w: 保存</span><br><span class="line">-q: 退出</span><br><span class="line">esc: 退出编辑 </span><br></pre></td></tr></table></figure></li><li><p>Vim快捷键 (非编辑模式下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a: 在光标后一位开始插入</span><br><span class="line">A: 在该行的最后插入</span><br><span class="line">I: 在该行的最前插入</span><br><span class="line">yy: 复制整行 </span><br><span class="line">3yy: 复制三行</span><br><span class="line">p: 粘贴</span><br><span class="line">gg: 直接跳到文件首行</span><br><span class="line">G: 直接跳到文件的末行</span><br><span class="line"><span class="built_in">dd</span>: 删除一行</span><br><span class="line">3dd: 删除三行</span><br><span class="line">/: 搜索内容,n匹配下一个 u:undo(撤销) ctrl+r:redo(执行之前撤销的) :<span class="built_in">set</span> nu: 设置行号</span><br><span class="line">:<span class="built_in">set</span> nonu: 设置不显示行号</span><br><span class="line">:q!: 强制不保存退出</span><br><span class="line"><span class="built_in">fg</span> 程序编号: 切换后台挂起程序</span><br><span class="line"><span class="built_in">jobs</span>: 查看后台挂起的程序</span><br><span class="line">ctrl+z: 将程序挂起</span><br></pre></td></tr></table></figure></li><li><p>拷贝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> a.txt b.txt: 将a.txt 拷贝为b.txt</span><br></pre></td></tr></table></figure></li><li><p>移动&#x2F;改名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> a.txt aa.txt: 将a.txt 改为 aa.txt</span><br><span class="line"><span class="built_in">mv</span> a.txt aa/aa.txt: 将a.txt 移动到 aa/aa.txt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>权限</p><ul><li><p>添加用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd fred passwd 1234: 添加 fred 用户并设置密码为 1234</span><br></pre></td></tr></table></figure></li><li><p>linux文件权限的描述格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d rwx rwx rwx</span><br><span class="line">d: 标识节点类型(d:文件夹 -:文件 |:链接)</span><br><span class="line">r: 可读</span><br><span class="line">w: 可写</span><br><span class="line">x: 可执行</span><br><span class="line">第一组rwx: 表示这个文件的拥有者对它的权限</span><br><span class="line">第二组rwx: 表示这个文件的所属组用户对它的权限</span><br><span class="line">第三组rwx: 表示这个文件的其他用户(除以上两种)对它的权限</span><br><span class="line">使用二进制表示权限:例如-rw-rw-r–二进制表示为110,110,100，十进制表示为664</span><br><span class="line"></span><br><span class="line">补充:</span><br><span class="line">r: 对文件来说，是可读取内容;对文件夹来说，是可以<span class="built_in">ls</span></span><br><span class="line">w: 对文件来说，是可修改文件的内容;对文件夹来说，是可以在其中创建或者删除子节点</span><br><span class="line">x: 对文件来说，是能否运行这个文件;对文件夹来说，是能否<span class="built_in">cd</span>进入这个目录</span><br></pre></td></tr></table></figure></li><li><p>用户管理</p><ul><li><p>增加用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd ant: 增加 ant 用户</span><br><span class="line">passwd ant: 给用户ant设置密码</span><br><span class="line">userdel -r 用户名: 删除用户(加一个-r表示把用户及用户的主目录都删除)</span><br><span class="line"><span class="built_in">exit</span>: 退出会话</span><br></pre></td></tr></table></figure></li><li><p>增加用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名: 增加组</span><br><span class="line">usermod -g 组名 用户名: 将用户添加到组中</span><br><span class="line">usermod -G 组名1,组名2 用户名: 将用户添加到多个组中</span><br><span class="line">gpasswd -d 用户名 组名: 将用户从组中删除</span><br><span class="line">—例如:gpasswd -d jack root | gpasswd -d jack sys</span><br></pre></td></tr></table></figure></li><li><p>查看所属组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span>: 查看当前用户所属组 </span><br><span class="line"><span class="built_in">groups</span> jack: 查看指定用户所属组</span><br></pre></td></tr></table></figure></li><li><p>su 和 sudo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su: 身份切换</span><br><span class="line">su username 输入密码(root切换不需要输入密码)</span><br><span class="line">sudo: 让普通用户具备root的权限(需要配置 /etc/sudoers)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>了解完su和sudo，是不是发现sudo有太多的优点了。</p><p>su方式切换是须要输入目标用户的password。而sudo仅仅须要 输入自己的password，所以sudo能够保护目标用户的password不外流的。</p><p>当帮root管理系统的时候，su是直接将 root全部权利交给用户。而sudo能够更好分工，仅仅要配置好&#x2F;etc&#x2F;sudoers，这样sudo能够保护系统更安全，并且分 工明白，有条不紊。</p></blockquote></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java指令码 字节码 对别</title>
      <link href="/2019/04/03/java%E6%8C%87%E4%BB%A4%E7%A0%81-%E5%AD%97%E8%8A%82%E7%A0%81-%E5%AF%B9%E5%88%AB/"/>
      <url>/2019/04/03/java%E6%8C%87%E4%BB%A4%E7%A0%81-%E5%AD%97%E8%8A%82%E7%A0%81-%E5%AF%B9%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="java-【指令码】【子节码】-对比"><a href="#java-【指令码】【子节码】-对比" class="headerlink" title="java 【指令码】【子节码】 对比"></a>java 【指令码】【子节码】 对比</h3><p> 指令从0x00-0xc9 没有0xba</p><table><thead><tr><th><strong>常量入栈指令</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x01</td><td>aconst_null</td><td></td><td>null值入栈。</td></tr><tr><td>0x02</td><td>iconst_m1</td><td></td><td>-1(int)值入栈。</td></tr><tr><td>0x03</td><td>iconst_0</td><td></td><td>0(int)值入栈。</td></tr><tr><td>0x04</td><td>iconst_1</td><td></td><td>1(int)值入栈。</td></tr><tr><td>0x05</td><td>iconst_2</td><td></td><td>2(int)值入栈。</td></tr><tr><td>0x06</td><td>iconst_3</td><td></td><td>3(int)值入栈。</td></tr><tr><td>0x07</td><td>iconst_4</td><td></td><td>4(int)值入栈。</td></tr><tr><td>0x08</td><td>iconst_5</td><td></td><td>5(int)值入栈。</td></tr><tr><td>0x09</td><td>lconst_0</td><td></td><td>0(long)值入栈。</td></tr><tr><td>0x0a</td><td>lconst_1</td><td></td><td>1(long)值入栈。</td></tr><tr><td>0x0b</td><td>fconst_0</td><td></td><td>0(float)值入栈。</td></tr><tr><td>0x0c</td><td>fconst_1</td><td></td><td>1(float)值入栈。</td></tr><tr><td>0x0d</td><td>fconst_2</td><td></td><td>2(float)值入栈。</td></tr><tr><td>0x0e</td><td>dconst_0</td><td></td><td>0(double)值入栈。</td></tr><tr><td>0x0f</td><td>dconst_1</td><td></td><td>1(double)值入栈。</td></tr><tr><td>0x10</td><td>bipush</td><td>valuebyte</td><td>valuebyte值带符号扩展成int值入栈。</td></tr><tr><td>0x11</td><td>sipush</td><td>valuebyte1             valuebyte2</td><td>(valuebyte1 &lt;&lt; 8) | valuebyte2 值带符号扩展成int值入栈。</td></tr><tr><td>0x12</td><td>ldc</td><td>indexbyte1</td><td>常量池中的常量值（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x13</td><td>ldc_w</td><td>indexbyte1             indexbyte2</td><td>常量池中常量（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x14</td><td>ldc2_w</td><td>indexbyte1             indexbyte2</td><td>常量池中常量（long, double）入栈。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>局部变量值转载到栈中指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x19</td><td>(wide)aload</td><td>indexbyte</td><td>从局部变量indexbyte中装载引用类型值入栈。</td></tr><tr><td>0x2a</td><td>aload_0</td><td></td><td>从局部变量0中装载引用类型值入栈。</td></tr><tr><td>0x2b</td><td>aload_1</td><td></td><td>从局部变量1中装载引用类型值入栈。</td></tr><tr><td>0x2c</td><td>aload_2</td><td></td><td>从局部变量2中装载引用类型值入栈。</td></tr><tr><td>0x2d</td><td>aload_3</td><td></td><td>从局部变量3中装载引用类型值入栈。</td></tr><tr><td>0x15</td><td>(wide)iload</td><td>indexbyte</td><td>从局部变量indexbyte中装载int类型值入栈。</td></tr><tr><td>0x1a</td><td>iload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1b</td><td>iload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x1c</td><td>iload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x1d</td><td>iload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x16</td><td>(wide)lload</td><td>indexbyte</td><td>从局部变量indexbyte中装载long类型值入栈。</td></tr><tr><td>0x1e</td><td>lload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1f</td><td>lload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x20</td><td>lload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x21</td><td>lload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x17</td><td>(wide)fload</td><td>indexbyte</td><td>从局部变量indexbyte中装载float类型值入栈。</td></tr><tr><td>0x22</td><td>fload_0</td><td></td><td>从局部变量0中装载float类型值入栈。</td></tr><tr><td>0x23</td><td>fload_1</td><td></td><td>从局部变量1中装载float类型值入栈。</td></tr><tr><td>0x24</td><td>fload_2</td><td></td><td>从局部变量2中装载float类型值入栈。</td></tr><tr><td>0x25</td><td>fload_3</td><td></td><td>从局部变量3中装载float类型值入栈。</td></tr><tr><td>0x18</td><td>(wide)dload</td><td>indexbyte</td><td>从局部变量indexbyte中装载double类型值入栈。</td></tr><tr><td>0x26</td><td>dload_0</td><td></td><td>从局部变量0中装载double类型值入栈。</td></tr><tr><td>0x27</td><td>dload_1</td><td></td><td>从局部变量1中装载double类型值入栈。</td></tr><tr><td>0x28</td><td>dload_2</td><td></td><td>从局部变量2中装载double类型值入栈。</td></tr><tr><td>0x29</td><td>dload_3</td><td></td><td>从局部变量3中装载double类型值入栈。</td></tr><tr><td>0x32</td><td>aaload</td><td></td><td>从引用类型数组中装载指定项的值。</td></tr><tr><td>0x2e</td><td>iaload</td><td></td><td>从int类型数组中装载指定项的值。</td></tr><tr><td>0x2f</td><td>laload</td><td></td><td>从long类型数组中装载指定项的值。</td></tr><tr><td>0x30</td><td>faload</td><td></td><td>从float类型数组中装载指定项的值。</td></tr><tr><td>0x31</td><td>daload</td><td></td><td>从double类型数组中装载指定项的值。</td></tr><tr><td>0x33</td><td>baload</td><td></td><td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x34</td><td>caload</td><td></td><td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x35</td><td>saload</td><td></td><td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>将栈顶值保存到局部变量中指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x3a</td><td>(wide)astore</td><td>indexbyte</td><td>将栈顶引用类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x4b</td><td>astroe_0</td><td></td><td>将栈顶引用类型值保存到局部变量0中。</td></tr><tr><td>0x4c</td><td>astore_1</td><td></td><td>将栈顶引用类型值保存到局部变量1中。</td></tr><tr><td>0x4d</td><td>astore_2</td><td></td><td>将栈顶引用类型值保存到局部变量2中。</td></tr><tr><td>0x4e</td><td>astore_3</td><td></td><td>将栈顶引用类型值保存到局部变量3中。</td></tr><tr><td>0x36</td><td>(wide)istore</td><td>indexbyte</td><td>将栈顶int类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3b</td><td>istore_0</td><td></td><td>将栈顶int类型值保存到局部变量0中。</td></tr><tr><td>0x3c</td><td>istore_1</td><td></td><td>将栈顶int类型值保存到局部变量1中。</td></tr><tr><td>0x3d</td><td>istore_2</td><td></td><td>将栈顶int类型值保存到局部变量2中。</td></tr><tr><td>0x3e</td><td>istore_3</td><td></td><td>将栈顶int类型值保存到局部变量3中。</td></tr><tr><td>0x37</td><td>(wide)lstore</td><td>indexbyte</td><td>将栈顶long类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3f</td><td>lstore_0</td><td></td><td>将栈顶long类型值保存到局部变量0中。</td></tr><tr><td>0x40</td><td>lstore_1</td><td></td><td>将栈顶long类型值保存到局部变量1中。</td></tr><tr><td>0x41</td><td>lstore_2</td><td></td><td>将栈顶long类型值保存到局部变量2中。</td></tr><tr><td>0x42</td><td>lstroe_3</td><td></td><td>将栈顶long类型值保存到局部变量3中。</td></tr><tr><td>0x38</td><td>(wide)fstore</td><td>indexbyte</td><td>将栈顶float类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x43</td><td>fstore_0</td><td></td><td>将栈顶float类型值保存到局部变量0中。</td></tr><tr><td>0x44</td><td>fstore_1</td><td></td><td>将栈顶float类型值保存到局部变量1中。</td></tr><tr><td>0x45</td><td>fstore_2</td><td></td><td>将栈顶float类型值保存到局部变量2中。</td></tr><tr><td>0x46</td><td>fstore_3</td><td></td><td>将栈顶float类型值保存到局部变量3中。</td></tr><tr><td>0x39</td><td>(wide)dstore</td><td>indexbyte</td><td>将栈顶double类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x47</td><td>dstore_0</td><td></td><td>将栈顶double类型值保存到局部变量0中。</td></tr><tr><td>0x48</td><td>dstore_1</td><td></td><td>将栈顶double类型值保存到局部变量1中。</td></tr><tr><td>0x49</td><td>dstore_2</td><td></td><td>将栈顶double类型值保存到局部变量2中。</td></tr><tr><td>0x4a</td><td>dstore_3</td><td></td><td>将栈顶double类型值保存到局部变量3中。</td></tr><tr><td>0x53</td><td>aastore</td><td></td><td>将栈顶引用类型值保存到指定引用类型数组的指定项。</td></tr><tr><td>0x4f</td><td>iastore</td><td></td><td>将栈顶int类型值保存到指定int类型数组的指定项。</td></tr><tr><td>0x50</td><td>lastore</td><td></td><td>将栈顶long类型值保存到指定long类型数组的指定项。</td></tr><tr><td>0x51</td><td>fastore</td><td></td><td>将栈顶float类型值保存到指定float类型数组的指定项。</td></tr><tr><td>0x52</td><td>dastore</td><td></td><td>将栈顶double类型值保存到指定double类型数组的指定项。</td></tr><tr><td>0x54</td><td>bastroe</td><td></td><td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。</td></tr><tr><td>0x55</td><td>castore</td><td></td><td>将栈顶char类型值保存到指定char类型数组的指定项。</td></tr><tr><td>0x56</td><td>sastore</td><td></td><td>将栈顶short类型值保存到指定short类型数组的指定项。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>wide指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xc4</td><td>wide</td><td></td><td>使用附加字节扩展局部变量索引（iinc指令特殊）。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>通用（无类型）栈操作指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x00</td><td>nop</td><td></td><td>空操作。</td></tr><tr><td>0x57</td><td>pop</td><td></td><td>从栈顶弹出一个字长的数据。</td></tr><tr><td>0x58</td><td>pop2</td><td></td><td>从栈顶弹出两个字长的数据。</td></tr><tr><td>0x59</td><td>dup</td><td></td><td>复制栈顶一个字长的数据，将复制后的数据压栈。</td></tr><tr><td>0x5a</td><td>dup_x1</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td></tr><tr><td>0x5b</td><td>dup_x2</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5c</td><td>dup2</td><td></td><td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td></tr><tr><td>0x5f</td><td>swap</td><td></td><td>交换栈顶两个字长的数据的位置。<a href="http://lib.csdn.net/base/javaee">Java</a>指令中没有提供以两个字长为单位的交换指令。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>类型转换指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x86</td><td>i2f</td><td></td><td>将栈顶int类型值转换为float类型值。</td></tr><tr><td>0x85</td><td>i2l</td><td></td><td>将栈顶int类型值转换为long类型值。</td></tr><tr><td>0x87</td><td>i2d</td><td></td><td>将栈顶int类型值转换为double类型值。</td></tr><tr><td>0x8b</td><td>f2i</td><td></td><td>将栈顶float类型值转换为int类型值。</td></tr><tr><td>0x8c</td><td>f2l</td><td></td><td>将栈顶float类型值转换为long类型值。</td></tr><tr><td>0x8d</td><td>f2d</td><td></td><td>将栈顶float类型值转换为double类型值。</td></tr><tr><td>0x88</td><td>l2i</td><td></td><td>将栈顶long类型值转换为int类型值。</td></tr><tr><td>0x89</td><td>l2f</td><td></td><td>将栈顶long类型值转换为float类型值。</td></tr><tr><td>0x8a</td><td>l2d</td><td></td><td>将栈顶long类型值转换double类型值。</td></tr><tr><td>0x8e</td><td>d2i</td><td></td><td>将栈顶double类型值转换为int类型值。</td></tr><tr><td>0x90</td><td>d2f</td><td></td><td>将栈顶double类型值转换为float类型值。</td></tr><tr><td>0x8f</td><td>d2l</td><td></td><td>将栈顶double类型值转换为long类型值。</td></tr><tr><td>0x91</td><td>i2b</td><td></td><td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x92</td><td>i2c</td><td></td><td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x93</td><td>i2s</td><td></td><td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>整数运算</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x60</td><td>iadd</td><td></td><td>将栈顶两int类型数相加，结果入栈。</td></tr><tr><td>0x64</td><td>isub</td><td></td><td>将栈顶两int类型数相减，结果入栈。</td></tr><tr><td>0x68</td><td>imul</td><td></td><td>将栈顶两int类型数相乘，结果入栈。</td></tr><tr><td>0x6c</td><td>idiv</td><td></td><td>将栈顶两int类型数相除，结果入栈。</td></tr><tr><td>0x70</td><td>irem</td><td></td><td>将栈顶两int类型数取模，结果入栈。</td></tr><tr><td>0x74</td><td>ineg</td><td></td><td>将栈顶int类型值取负，结果入栈。</td></tr><tr><td>0x61</td><td>ladd</td><td></td><td>将栈顶两long类型数相加，结果入栈。</td></tr><tr><td>0x65</td><td>lsub</td><td></td><td>将栈顶两long类型数相减，结果入栈。</td></tr><tr><td>0x69</td><td>lmul</td><td></td><td>将栈顶两long类型数相乘，结果入栈。</td></tr><tr><td>0x6d</td><td>ldiv</td><td></td><td>将栈顶两long类型数相除，结果入栈。</td></tr><tr><td>0x71</td><td>lrem</td><td></td><td>将栈顶两long类型数取模，结果入栈。</td></tr><tr><td>0x75</td><td>lneg</td><td></td><td>将栈顶long类型值取负，结果入栈。</td></tr><tr><td>0x84</td><td>(wide)iinc</td><td>indexbyte             constbyte</td><td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>浮点运算</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x62</td><td>fadd</td><td></td><td>将栈顶两float类型数相加，结果入栈。</td></tr><tr><td>0x66</td><td>fsub</td><td></td><td>将栈顶两float类型数相减，结果入栈。</td></tr><tr><td>0x6a</td><td>fmul</td><td></td><td>将栈顶两float类型数相乘，结果入栈。</td></tr><tr><td>0x6e</td><td>fdiv</td><td></td><td>将栈顶两float类型数相除，结果入栈。</td></tr><tr><td>0x72</td><td>frem</td><td></td><td>将栈顶两float类型数取模，结果入栈。</td></tr><tr><td>0x76</td><td>fneg</td><td></td><td>将栈顶float类型值取反，结果入栈。</td></tr><tr><td>0x63</td><td>dadd</td><td></td><td>将栈顶两double类型数相加，结果入栈。</td></tr><tr><td>0x67</td><td>dsub</td><td></td><td>将栈顶两double类型数相减，结果入栈。</td></tr><tr><td>0x6b</td><td>dmul</td><td></td><td>将栈顶两double类型数相乘，结果入栈。</td></tr><tr><td>0x6f</td><td>ddiv</td><td></td><td>将栈顶两double类型数相除，结果入栈。</td></tr><tr><td>0x73</td><td>drem</td><td></td><td>将栈顶两double类型数取模，结果入栈。</td></tr><tr><td>0x77</td><td>dneg</td><td></td><td>将栈顶double类型值取负，结果入栈。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>逻辑运算——移位运算</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x78</td><td>ishl</td><td></td><td>左移int类型值。</td></tr><tr><td>0x79</td><td>lshl</td><td></td><td>左移long类型值。</td></tr><tr><td>0x7a</td><td>ishr</td><td></td><td>算术右移int类型值。</td></tr><tr><td>0x7b</td><td>lshr</td><td></td><td>算术右移long类型值。</td></tr><tr><td>0x7c</td><td>iushr</td><td></td><td>逻辑右移int类型值。</td></tr><tr><td>0x7d</td><td>lushr</td><td></td><td>逻辑右移long类型值。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>逻辑运算——按位布尔运算</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x73</td><td>iand</td><td></td><td>对int类型按位与运算。</td></tr><tr><td>0x7f</td><td>land</td><td></td><td>对long类型的按位与运算。</td></tr><tr><td>0x80</td><td>ior</td><td></td><td>对int类型的按位或运算。</td></tr><tr><td>0x81</td><td>lor</td><td></td><td>对long类型的按位或运算。</td></tr><tr><td>0x82</td><td>ixor</td><td></td><td>对int类型的按位异或运算。</td></tr><tr><td>0x83</td><td>lxor</td><td></td><td>对long类型的按位异或运算。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>控制流指令——条件跳转指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x99</td><td>ifeq</td><td>branchbyte1             branchbyte2</td><td>若栈顶int类型值为0则跳转。</td></tr><tr><td>0x9a</td><td>ifne</td><td>branchbyte1             branchbyte2</td><td>若栈顶int类型值不为0则跳转。</td></tr><tr><td>0x9b</td><td>iflt</td><td>branchbyte1             branchbyte2</td><td>若栈顶int类型值小于0则跳转。</td></tr><tr><td>0x9e</td><td>ifle</td><td>branchbyte1             branchbyte2</td><td>若栈顶int类型值小于等于0则跳转。</td></tr><tr><td>0x9d</td><td>ifgt</td><td>branchbyte1             branchbyte2</td><td>若栈顶int类型值大于0则跳转。</td></tr><tr><td>0x9c</td><td>ifge</td><td>branchbyte1             branchbyte2</td><td>若栈顶int类型值大于等于0则跳转。</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>branchbyte1             branchbyte2</td><td>若栈顶两int类型值相等则跳转。</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>branchbyte1             branchbyte2</td><td>若栈顶两int类型值不相等则跳转。</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>branchbyte1             branchbyte2</td><td>若栈顶两int类型值前小于后则跳转。</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>branchbyte1             branchbyte2</td><td>若栈顶两int类型值前小于等于后则跳转。</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>branchbyte1             branchbyte2</td><td>若栈顶两int类型值前大于后则跳转。</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>branchbyte1             branchbyte2</td><td>若栈顶两int类型值前大于等于后则跳转。</td></tr><tr><td>0xc6</td><td>ifnull</td><td>branchbyte1             branchbyte2</td><td>若栈顶引用值为null则跳转。</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>branchbyte1             branchbyte2</td><td>若栈顶引用值不为null则跳转。</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>branchbyte1             branchbyte2</td><td>若栈顶两引用类型值相等则跳转。</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>branchbyte1             branchbyte2</td><td>若栈顶两引用类型值不相等则跳转。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>控制流指令——比较指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0x94</td><td>lcmp</td><td></td><td>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</td></tr><tr><td>0x95</td><td>fcmpl</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x96</td><td>fcmpg</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x97</td><td>dcmpl</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x98</td><td>dcmpg</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>控制流指令——无条件跳转指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xa7</td><td>goto</td><td>branchbyte1             branchbyte2</td><td>无条件跳转到指定位置。</td></tr><tr><td>0xc8</td><td>goto_w</td><td>branchbyte1             branchbyte2             branchbyte3             branchbyte4</td><td>无条件跳转到指定位置（宽索引）。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>控制流指令——表跳转指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xaa</td><td>tableswitch</td><td>&lt;0-3bytepad&gt;             defaultbyte1             defaultbyte2             defaultbyte3             defaultbyte4             lowbyte1             lowbyte2             lowbyte3             lowbyte4             highbyte1             highbyte2             highbyte3             highbyte4             jump offsets…</td><td>通过索引访问跳转表，并跳转。</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>&lt;0-3bytepad&gt;             defaultbyte1             defaultbyte2             defaultbyte3             defaultbyte4             npairs1             npairs2             npairs3             npairs4             match offsets</td><td>通过键值访问跳转表，并跳转。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>控制流指令——异常和finally</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xbf</td><td>athrow</td><td></td><td>抛出异常。</td></tr><tr><td>0xa8</td><td>jsr</td><td>branchbyte1             branchbyte2</td><td>跳转到子例程序。</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>branchbyte1             branchbyte2             branchbyte3             branchbyte4</td><td>跳转到子例程序（宽索引）。</td></tr><tr><td>0xa9</td><td>(wide)ret</td><td>indexbyte</td><td>返回子例程序。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>对象操作指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xbb</td><td>new</td><td>indexbyte1             indexbyte2</td><td>创建新的对象实例。</td></tr><tr><td>0xc0</td><td>checkcast</td><td>indexbyte1             indexbyte</td><td>类型强转。</td></tr><tr><td>0xc1</td><td>instanceof</td><td>indexbyte1             indexbyte2</td><td>判断类型。</td></tr><tr><td>0xb4</td><td>getfield</td><td>indexbyte1             indexbyte2</td><td>获取对象字段的值。</td></tr><tr><td>0xb5</td><td>putfield</td><td>indexbyte1             indexbyte2</td><td>给对象字段赋值。</td></tr><tr><td>0xb2</td><td>getstatic</td><td>indexbyte1             indexbyte2</td><td>获取静态字段的值。</td></tr><tr><td>0xb3</td><td>putstatic</td><td>indexbyte1             indexbyte2</td><td>给静态字段赋值。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>数组操作指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xbc</td><td>newarray</td><td>atype</td><td>创建type类型的数组。</td></tr><tr><td>0xbd</td><td>anewarray</td><td>indexbyte1             indexbyte2</td><td>创建引用类型的数组。</td></tr><tr><td>0xbe</td><td>arraylength</td><td></td><td>获取一维数组的长度。</td></tr><tr><td>0xc5</td><td>multianewarray</td><td>indexbyte1             indexbyte2             dimension</td><td>创建dimension维度的数组。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>方法调用指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xb7</td><td>invokespecial</td><td>indexbyte1             indexbyte2</td><td>编译时方法绑定调用方法。</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>indexbyte1             indexbyte2</td><td>运行时方法绑定调用方法。</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>indexbyte1             indexbyte2</td><td>调用静态方法。</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>indexbyte1             indexbyte2             count             0</td><td>调用接口方法。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>方法返回指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xac</td><td>ireturn</td><td></td><td>返回int类型值。</td></tr><tr><td>0xad</td><td>lreturn</td><td></td><td>返回long类型值。</td></tr><tr><td>0xae</td><td>freturn</td><td></td><td>返回float类型值。</td></tr><tr><td>0xaf</td><td>dreturn</td><td></td><td>返回double类型值。</td></tr><tr><td>0xb0</td><td>areturn</td><td></td><td>返回引用类型值。</td></tr><tr><td>0xb1</td><td>return</td><td></td><td>void函数返回。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>线程同步指令</strong></td><td></td><td></td><td></td></tr><tr><td><strong>指令码</strong></td><td><strong>操作码（助记符）</strong></td><td><strong>操作数</strong></td><td><strong>描述（栈指操作数栈）</strong></td></tr><tr><td>0xc2</td><td>monitorenter</td><td></td><td>进入并获得对象监视器。</td></tr><tr><td>0xc3</td><td>monitorexit</td><td></td><td>释放并退出对象监视器。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用静态内部类实现单例</title>
      <link href="/2018/11/23/%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/"/>
      <url>/2018/11/23/%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式之利用静态类实现单例"><a href="#单例模式之利用静态类实现单例" class="headerlink" title="单例模式之利用静态类实现单例"></a>单例模式之利用静态类实现单例</h2><blockquote><p>利用静态类在jvm内存模型中存储在静态块且只有一个实例的属性，可以轻松实现单例，保证了线程的安全性；</p></blockquote><p><strong>具体代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ant.innerclass;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ant gxstax@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: HolderSingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 静态内部类实现单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2018/11/23 14:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HolderSingleton</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HolderSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HolderSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HolderSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HolderSingleton <span class="title function_">getInstance</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(HolderSingleton.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
