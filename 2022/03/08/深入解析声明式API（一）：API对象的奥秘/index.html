<!DOCTYPE html>
<html  lang="zh-CN" >
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <title>深入解析声明式API（一）：API对象的奥秘 | 马以的博客</title>
    <meta name="description" content="Kubernetes 声明式 API 的工作原理 如何利用这套 API 机制，在 Kubernetes 里添加自定义的 API 对象。  你可能一直就很好奇：当我把一个 YAML 文件提交给 Kubernetes 之后，它究竟是如何创建出一个 API 对象的呢？ 这得从声明式 API 的设计谈起了。 在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Grou">
<meta property="og:type" content="article">
<meta property="og:title" content="深入解析声明式API（一）：API对象的奥秘">
<meta property="og:url" content="https://gxstax.github.io/2022/03/08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPI%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98/index.html">
<meta property="og:site_name" content="马以的博客">
<meta property="og:description" content="Kubernetes 声明式 API 的工作原理 如何利用这套 API 机制，在 Kubernetes 里添加自定义的 API 对象。  你可能一直就很好奇：当我把一个 YAML 文件提交给 Kubernetes 之后，它究竟是如何创建出一个 API 对象的呢？ 这得从声明式 API 的设计谈起了。 在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Grou">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gxstax.github.io/Users/mayi/work/Ant/projects/blog/source/images/k8s/k8s-api-tree.png">
<meta property="og:image" content="https://gxstax.github.io/Users/mayi/work/Ant/projects/blog/source/images/k8s/api-server-build.png">
<meta property="article:published_time" content="2022-03-08T02:09:49.000Z">
<meta property="article:modified_time" content="2022-03-08T07:35:50.576Z">
<meta property="article:author" content="马以">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gxstax.github.io/Users/mayi/work/Ant/projects/blog/source/images/k8s/k8s-api-tree.png">

    
    <link rel="icon" href="/images/favicon.png" type="image/x-icon">

    
<link rel="stylesheet" href="/css/common.min.css">



    
    
    
        <link href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css" rel="stylesheet">
    
    
        <link href="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/css/lightgallery.min.css" rel="stylesheet">
    
    
    
<link rel="stylesheet" href="/css/iconfont.min.css">

    
<meta name="generator" content="Hexo 5.4.1"></head>

    <body>
        <header class="header header-fixture">
    <div class="profile-search-wrap flex sm:block">
        
        
        <div class="profile sm:text-center md:px-1 lg:px-3 sm:pb-4 sm:pt-6">
            <a id="avatar" role="link" href="https://github.com/gxstax" class="inline-block lg:w-16 lg:h-16 w-8 h-8 m-2" target="_blank" rel="noopener" rel="noreferrer" >
                <img src="/images/avatar.jpg" class="rounded-full" alt="avatar">
            </a>
            <h2 id="name" class="hidden lg:block">Ant</h2>
            <h3 id="title" class="hidden xl:block">笔耕不辍，钟情翰墨</h3>
            
            <small id="location" class="hidden lg:block">
                <i class="iconfont icon-map-icon"></i>
                ShenZhen, GuangDong
            </small>
            
        </div>
        
        
<div class="search flex-1 flex lg:inline-block sm:hidden lg:px-4 lg:mt-2 lg:mb-4 lg:w-full">
    <form id="search-form" class="my-auto flex-1 lg:border lg:border-solid lg:border-gray-200">
        <div class="input-group table bg-gray-100 lg:bg-white w-full">
            <input id="search-input" type="text" placeholder="搜索" class="inline-block w-full bg-gray-100 lg:bg-white">
            <span class="table-cell">
                <button name="search tigger button" disabled>
                    <i class="iconfont icon-search m-2"></i>
                </button>
            </span>
        </div>
    </form>
        
<div id="content-json" data-placeholder="搜索" class="invisible hidden">/content.json</div>
<script id="search-teamplate" type="text/html" data-path="/content.json">
    <div>
        <div class="search-header bg-gray-400">
            <input id="actual-search-input" model="keyword" ref="input" class="inline-block w-full h-10 px-2 py-1" placeholder="搜索" type="text">
        </div>
        <div class="search-result bg-gray-200">
            {{#each searchPosts}}
            <a href="/{{ path }}" class="result-item block px-2 pb-3 mb-1 pt-1 hover:bg-indigo-100">
                <i class="iconfont icon-file"></i>
                <h1 class="result-title inline font-medium text-lg">{{ title }}</h1>
                <p class="result-content text-gray-600 text-sm">{{{ text }}}</p>
            </a>
            {{/each}}
        </div>
    </div>
</script>

</div>


        <button name="menu toogle button" id="menu-toggle-btn" class="block sm:hidden p-3" role="button" aria-expanded="false">
            <i class="iconfont icon-hamburger"></i>
        </button>
    </div>
    <nav id="menu-nav" class="hidden sm:flex flex-col">
        
        
            <div class="menu-item menu-home" role="menuitem">
                <a href="/.">
                    <i class="iconfont icon-home" aria-hidden="true"></i>
                    <span class="menu-title">首页</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-archives" role="menuitem">
                <a href="/archives">
                    <i class="iconfont icon-archive" aria-hidden="true"></i>
                    <span class="menu-title">归档</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-categories" role="menuitem">
                <a href="/categories">
                    <i class="iconfont icon-folder" aria-hidden="true"></i>
                    <span class="menu-title">分类</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-tags" role="menuitem">
                <a href="/tags">
                    <i class="iconfont icon-tag" aria-hidden="true"></i>
                    <span class="menu-title">标签</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-repository" role="menuitem">
                <a href="/repository">
                    <i class="iconfont icon-project" aria-hidden="true"></i>
                    <span class="menu-title">项目</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-links" role="menuitem">
                <a href="/links">
                    <i class="iconfont icon-friend" aria-hidden="true"></i>
                    <span class="menu-title">友链</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-about" role="menuitem">
                <a href="/about">
                    <i class="iconfont icon-cup" aria-hidden="true"></i>
                    <span class="menu-title">关于</span>
                </a>
            </div>
        
        
<div class="social-links flex sm:flex-col lg:hidden mt-5">
    
        <span class="social-item text-center">
            <a target="_blank" rel="noopener" href="https://github.com/gxstax">
                <i class="iconfont social-icon icon-github"></i>
                <span class="menu-title hidden lg:inline">menu.github</span>
            </a>
        </span>
    
        <span class="social-item text-center">
            <a target="_blank" rel="noopener" href="https://t.me/gxstax">
                <i class="iconfont social-icon icon-telegram"></i>
                <span class="menu-title hidden lg:inline">menu.telegram</span>
            </a>
        </span>
    
        <span class="social-item text-center">
            <a target="_blank" rel="noopener" href="https://twitter.com/Ant78261681">
                <i class="iconfont social-icon icon-twitter"></i>
                <span class="menu-title hidden lg:inline">menu.twitter</span>
            </a>
        </span>
    
        <span class="social-item text-center">
            <a target="_blank" rel="noopener" href="https://rss.com/podcasts/ant/">
                <i class="iconfont social-icon icon-rss"></i>
                <span class="menu-title hidden lg:inline">menu.rss</span>
            </a>
        </span>
    
</div>


    </nav>
</header>

        <section class="main-section">
            
    <main class="flex-1 px-4 py-14 md:px-5 lg:px-8 lg:py-4 relative min-h-screen">
    

    <article class="content article article-archives article-type-list" itemscope="">
        <header class="article-header">
            
    
        <h1 class="article-title text-lg" itemprop="name">
            深入解析声明式API（一）：API对象的奥秘
        </h1>
    



            <p class="article-meta mb-3 text-xs">
                <span class="article-date">
    <i class="iconfont icon-calendar-check"></i>
	<a href="/2022/03/08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPI%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98/" class="article-date">
	  <time datetime="2022-03-08T02:09:49.000Z" itemprop="datePublished">3月 8</time>
	</a>
</span>

                
    <span class="article-category">
    <i class="iconfont icon-folder"></i>
    <a class="article-category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a> , <a class="article-category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/">k8s</a>
  </span>


                
    <span class="article-tags">
    <i class="iconfont icon-tag"></i>
    <a class="article-tag-none-link" href="/tags/k8s/" rel="tag">k8s</a>
  </span>


                <span class="_partial/post-comment"><i class="icon icon-comment"></i>
                    <a href="/2022/03/08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPI%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98/#comments" class="article-comment-link">
                        评论
                    </a>
                </span>
                
    
        <span class="post-wordcount" itemprop="wordCount">字数统计: 4.8k(字)</span>
    
    
        <span class="post-readcount" itemprop="timeRequired">阅读时长: 19(分)</span>
    


            </p>
        </header>
        <div class="marked-body article-body">
            <h2 id="Kubernetes-声明式-API-的工作原理"><a href="#Kubernetes-声明式-API-的工作原理" class="headerlink" title="Kubernetes 声明式 API 的工作原理"></a>Kubernetes 声明式 API 的工作原理</h2><blockquote>
<p>如何利用这套 API 机制，在 Kubernetes 里添加自定义的 API 对象。</p>
</blockquote>
<p>你可能一直就很好奇：当我把一个 YAML 文件提交给 Kubernetes 之后，它究竟是如何创建出一个 API 对象的呢？</p>
<p>这得从声明式 API 的设计谈起了。</p>
<p>在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。</p>
<p>通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：</p>
<p><img src="/Users/mayi/work/Ant/projects/blog/source/images/k8s/k8s-api-tree.png" alt="image-20220308101716245"></p>
<p>在这幅图中，你可以很清楚地看到 <strong>Kubernetes 里 API 对象的组织方式，其实是层层递进的。</strong></p>
<p>比如，现在我要声明要创建一个 CronJob 对象，那么我的 YAML 文件的开始部分会这么写：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v2alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>在这个 YAML 文件中，“CronJob”就是这个 API 对象的资源类型（Resource），“batch”就是它的组（Group），v2alpha1 就是它的版本（Version）。</p>
<p>当我们提交了这个 YAML 文件之后，Kubernetes 就会把这个 YAML 文件里描述的内容，转换成 Kubernetes 里的一个 CronJob 对象。</p>
<p>那么，<font color=orange>Kubernetes 是如何对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项目里找到 CronJob 对象的定义呢？</font></p>
<p><strong>首先，Kubernetes 会匹配 API 对象的组。</strong></p>
<p>需要明确的是，对于 Kubernetes 里的核心 API 对象，比如：Pod、Node 等，是不需要 Group 的（即：它们的 Group 是“”）。所以，对于这些 API 对象来说，Kubernetes 会直接在 /api 这个层级进行下一步的匹配过程。</p>
<p>而对于 CronJob 等非核心 API 对象来说，Kubernetes 就必须在 /apis 这个层级里查找它对应的 Group，进而根据“batch”这个 Group 的名字，找到 /apis/batch。</p>
<p>不难发现，这些 API Group 的分类是以对象功能为依据的，比如 Job 和 CronJob 就都属于“batch” （离线业务）这个 Group。</p>
<p><strong>然后，Kubernetes 会进一步匹配到 API 对象的版本号。</strong></p>
<p>对于 CronJob 这个 API 对象来说，Kubernetes 在 batch 这个 Group 下，匹配到的版本号就是 v2alpha1。</p>
<p>在 Kubernetes 中，同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。这样，比如在 CronJob 的开发过程中，对于会影响到用户的变更就可以通过升级新版本来处理，从而保证了向后兼容。</p>
<p><strong>最后，Kubernetes 会匹配 API 对象的资源类型。</strong></p>
<p>在前面匹配到正确的版本之后，Kubernetes 就知道，我要创建的原来是一个 /apis/batch/v2alpha1 下的 CronJob 对象。</p>
<p>这时候，<font color=orange>APIServer 就可以继续创建这个 CronJob 对象了。</font>为了方便理解，我为你总结了一个如下所示流程图来阐述这个创建过程：</p>
<p><img src="/Users/mayi/work/Ant/projects/blog/source/images/k8s/api-server-build.png" alt="img"></p>
<p><strong>首先，</strong>当我们发起了创建 CronJob 的 POST 请求之后，我们编写的 YAML 的信息就被提交给了 APIServer。</p>
<p>而 APIServer 的第一个功能，就是过滤这个请求，并完成一些前置性的工作，比如授权、超时处理、审计等。</p>
<p><strong>然后，</strong>请求会进入 MUX 和 Routes 流程。如果你编写过 Web Server 的话就会知道，MUX 和 Routes 是 APIServer 完成 URL 和 Handler 绑定的场所。而 APIServer 的 Handler 要做的事情，就是按照我刚刚介绍的匹配过程，找到对应的 CronJob 类型定义。</p>
<p><strong>接着，</strong>APIServer 最重要的职责就来了：根据这个 CronJob 类型定义，使用用户提交的 YAML 文件里的字段，创建一个 CronJob 对象。</p>
<p>而在这个过程中，APIServer 会进行一个 Convert 工作，即：把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。这样用户提交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理了。</p>
<p><strong>接下来，</strong>APIServer 会先后进行 Admission() 和 Validation() 操作。比如，我在上一篇文章中提到的 Admission Controller 和 Initializer，就都属于 Admission 的内容。</p>
<p>而 Validation，则负责验证这个对象里的各个字段是否合法。这个被验证过的 API 对象，都保存在了 APIServer 里一个叫作 Registry 的数据结构中。也就是说，只要一个 API 对象的定义能在 Registry 里查到，它就是一个有效的 Kubernetes API 对象。</p>
<p><strong>最后，</strong>APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 把它保存起来。</p>
<p>由此可见，声明式 API 对于 Kubernetes 来说非常重要。所以，<strong>APIServer 这样一个在其他项目里“平淡无奇”的组件，却成了 Kubernetes 项目的重中之重。</strong>它不仅是 Google Borg 设计思想的集中体现，也是 Kubernetes 项目里唯一一个被 Google 公司和 RedHat 公司双重控制、其他势力根本无法参与其中的组件。</p>
<p>此外，由于同时要兼顾性能、API 完备性、版本化、向后兼容等很多工程化指标，所以 Kubernetes 团队在 APIServer 项目里大量使用了 Go 语言的代码生成功能，来自动化诸如 Convert、DeepCopy 等与 API 资源相关的操作。这部分自动生成的代码，曾一度占到 Kubernetes 项目总代码的 20%~30%。</p>
<p>这也是为何，在过去很长一段时间里，在这样一个极其“复杂”的 APIServer 中，添加一个 Kubernetes 风格的 API 资源类型，是一个非常困难的工作。</p>
<p>不过，在 Kubernetes v1.7 之后，这个工作就变得轻松得多了。这，当然得益于一个全新的 API 插件机制：CRD。</p>
<p>CRD 的全称是 Custom Resource Definition。顾名思义，它指的就是，允许用户在 Kubernetes 中添加一个跟 Pod、Node 类似的、新的 API 资源类型，即：自定义 API 资源。</p>
<p>举个例子，<font color=orange>我现在要为 Kubernetes 添加一个名叫 Network 的 API 资源类型。</font></p>
<p>它的作用是，一旦用户创建一个 Network 对象，那么 Kubernetes 就应该使用这个对象定义的网络参数，调用真实的网络插件，比如 Neutron 项目，为用户创建一个真正的“网络”。这样，将来用户创建的 Pod，就可以声明使用这个“网络”了。</p>
<p>这个 Network 对象的 YAML 文件，名叫 example-network.yaml，它的内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">samplecrd.x-k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Network</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-network</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">cidr:</span> <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">  <span class="attr">gateway:</span> <span class="string">&quot;192.168.0.1&quot;</span></span><br></pre></td></tr></table></figure>



<p>可以看到，我想要描述“网络”的 API 资源类型是 Network；API 组是samplecrd.k8s.io；API 版本是 v1。</p>
<p>那么，<font color=orange>Kubernetes 又该如何知道这个 API（samplecrd.k8s.io/v1/network）的存在呢？</font></p>
<p>其实，上面的这个 YAML 文件，就是一个具体的“自定义 API 资源”实例，也叫 CR（Custom Resource）。而为了能够让 Kubernetes 认识这个 CR，你就需要让 Kubernetes 明白这个 CR 的宏观定义是什么，也就是 CRD（Custom Resource Definition）。</p>
<p>这就好比，你想让计算机认识各种兔子的照片，就得先让计算机明白，兔子的普遍定义是什么。比如，兔子“是哺乳动物”“有长耳朵，三瓣嘴”。</p>
<p>所以，接下来，我就先编写一个 CRD 的 YAML 文件，它的名字叫作 network.yaml，内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">networks.samplecrd.x-k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">samplecrd.x-k8s.io</span></span><br><span class="line">  <span class="attr">versions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">      <span class="comment"># Each version can be enabled/disabled by Served flag.</span></span><br><span class="line">      <span class="attr">served:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># One and only one version must be marked as the storage version.</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">schema:</span></span><br><span class="line">        <span class="attr">openAPIV3Schema:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">          <span class="attr">properties:</span></span><br><span class="line">            <span class="attr">spec:</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">              <span class="attr">properties:</span></span><br><span class="line">                <span class="attr">cidr:</span></span><br><span class="line">                  <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">                <span class="attr">gateway:</span></span><br><span class="line">                  <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">  <span class="comment"># either Namespaced or Cluster</span></span><br><span class="line">  <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="comment"># plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span></span><br><span class="line">    <span class="attr">plural:</span> <span class="string">networks</span></span><br><span class="line">    <span class="comment"># singular name to be used as an alias on the CLI and for display</span></span><br><span class="line">    <span class="attr">singular:</span> <span class="string">network</span></span><br><span class="line">    <span class="comment"># kind is normally the CamelCased singular type. Your resource manifests use this.</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Network</span></span><br><span class="line">    <span class="attr">shortNames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nw</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在这个 CRD 中，我指定了“group: samplecrd.x-k8s.io” “version: v1”这样的 API 信息，也指定了这个 CR 的资源类型叫作 Network，复数（plural）是 networks。</p>
<blockquote>
<p><font color=red>**注意: **</font> 这里最新的1.23.0版本的k8s不能使用*.k8s.io后缀，最好替换为.x-k8s.io。</p>
</blockquote>
<p>然后，我还声明了它的 scope 是 Namespaced，即：我们定义的这个 Network 是一个属于 Namespace 的对象，类似于 Pod。</p>
<p>这就是一个 Network API 资源类型的 API 部分的宏观定义了。这就等同于告诉了计算机：“兔子是哺乳动物”。所以这时候，Kubernetes 就能够认识和处理所有声明了 API 类型是“samplecrd.k8s.io/v1/network”的 YAML 文件了。</p>
<p>接下来，我还需要让 Kubernetes“认识”这种 YAML 文件里描述的“网络”部分，比如“cidr”（网段），“gateway”（网关）这些字段的含义。这就相当于我要告诉计算机：“兔子有长耳朵和三瓣嘴”。</p>
<p>这时候呢，我就需要稍微做些代码工作了。</p>
<p><strong>首先，我要在 GOPATH 下，创建一个结构如下的项目：</strong></p>
<blockquote>
<p>备注：在这里，我并不要求你具有完备的 Go 语言知识体系，但我会假设你已经了解了 Golang 的一些基本知识（比如，知道什么是 GOPATH）。而如果你还不了解的话，可以在涉及到相关内容时，再去查阅一些相关资料。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ tree <span class="variable">$GOPATH</span>/src/github.com/&lt;your-name&gt;/k8s-controller-custom-resource</span><br><span class="line">.</span><br><span class="line">├── controller.go</span><br><span class="line">├── crd</span><br><span class="line">│   └── network.yaml</span><br><span class="line">├── example</span><br><span class="line">│   └── example-network.yaml</span><br><span class="line">├── main.go</span><br><span class="line">└── pkg</span><br><span class="line">    └── apis</span><br><span class="line">        └── samplecrd</span><br><span class="line">            ├── register.go</span><br><span class="line">            └── v1</span><br><span class="line">                ├── doc.go</span><br><span class="line">                ├── register.go</span><br><span class="line">                └── types.go</span><br></pre></td></tr></table></figure>

<p>其中，pkg/apis/samplecrd 就是 API 组的名字，v1 是版本，而 v1 下面的 types.go 文件里，则定义了 Network 对象的完整描述。我已经把这个<a target="_blank" rel="noopener" href="https://github.com/gxstax/k8s-custom-controller" title="github地址">项目上传到了 GitHub 上</a>，你可以随时参考。</p>
<p><strong>然后，我在 pkg/apis/samplecrd 目录下创建了一个 register.go 文件，用来放置后面要用到的全局变量。</strong>这个文件的内容如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> samplecrd</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> GroupName = <span class="string">&quot;samplecrd.k8s.io&quot;</span></span><br><span class="line"> Version   = <span class="string">&quot;v1&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>接着，我需要在 pkg/apis/samplecrd 目录下添加一个 doc.go 文件（Golang 的文档源文件）。</strong>这个文件里的内容如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +groupName=samplecrd.k8s.io</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure>

<p>在这个文件中，你会看到 +&lt; tag_name &gt;[=value]格式的注释，这就是 Kubernetes 进行代码生成要用的 Annotation 风格的注释。</p>
<p>其中，+k8s:deepcopy-gen=package 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；而+groupName=samplecrd.k8s.io，则定义了这个包对应的 API 组的名字。</p>
<p>可以看到，这些定义在 doc.go 文件的注释，起到的是全局的代码生成控制的作用，所以也被称为 Global Tags。</p>
<p><strong>接下来，我需要添加 types.go 文件。</strong>顾名思义，它的作用就是定义一个 Network 类型到底有哪些字段（比如，spec 字段里的内容）。这个文件的主要内容如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> v1</span><br><span class="line">...</span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Network describes a Network resource</span></span><br><span class="line"><span class="keyword">type</span> Network <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="comment">// TypeMeta is the metadata for the resource, like kind and apiversion</span></span><br><span class="line"> metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line"> <span class="comment">// ObjectMeta contains the metadata for the particular object, including</span></span><br><span class="line"> <span class="comment">// things like...</span></span><br><span class="line"> <span class="comment">//  - name</span></span><br><span class="line"> <span class="comment">//  - namespace</span></span><br><span class="line"> <span class="comment">//  - self link</span></span><br><span class="line"> <span class="comment">//  - labels</span></span><br><span class="line"> <span class="comment">//  - ... etc ...</span></span><br><span class="line"> metav1.ObjectMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line"> </span><br><span class="line"> Spec networkspec <span class="string">`json:&quot;spec&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// networkspec is the spec for a Network resource</span></span><br><span class="line"><span class="keyword">type</span> networkspec <span class="keyword">struct</span> &#123;</span><br><span class="line"> Cidr    <span class="type">string</span> <span class="string">`json:&quot;cidr&quot;`</span></span><br><span class="line"> Gateway <span class="type">string</span> <span class="string">`json:&quot;gateway&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NetworkList is a list of Network resources</span></span><br><span class="line"><span class="keyword">type</span> NetworkList <span class="keyword">struct</span> &#123;</span><br><span class="line"> metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line"> metav1.ListMeta <span class="string">`json:&quot;metadata&quot;`</span></span><br><span class="line"> </span><br><span class="line"> Items []Network <span class="string">`json:&quot;items&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这部分代码里，你可以看到 Network 类型定义方法跟标准的 Kubernetes 对象一样，都包括了 TypeMeta（API 元数据）和 ObjectMeta（对象元数据）字段。</p>
<p>而其中的 Spec 字段，就是需要我们自己定义的部分。所以，在 networkspec 里，我定义了 Cidr 和 Gateway 两个字段。其中，每个字段最后面的部分比如json:”cidr”，指的就是这个字段被转换成 JSON 格式之后的名字，也就是 YAML 文件里的字段名字。</p>
<blockquote>
<p>如果你不熟悉这个用法的话，可以查阅一下 Golang 的文档。</p>
</blockquote>
<p>此外，除了定义 Network 类型，你还需要定义一个 NetworkList 类型，用来描述一组 Network 对象应该包括哪些字段。之所以需要这样一个类型，是因为在 Kubernetes 中，获取所有 X 对象的 List() 方法，返回值都是List 类型，而不是 X 类型的数组。这是不一样的。</p>
<p>同样地，在 Network 和 NetworkList 类型上，也有代码生成注释。</p>
<p>其中，+genclient 的意思是：请为下面这个 API 资源类型生成对应的 Client 代码（这个 Client，我马上会讲到）。而 +genclient:noStatus 的意思是：这个 API 资源类型定义里，没有 Status 字段。否则，生成的 Client 就会自动带上 UpdateStatus 方法。</p>
<p>如果你的类型定义包括了 Status 字段的话，就不需要这句 +genclient:noStatus 注释了。比如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Network is a specification for a Network resource</span></span><br><span class="line"><span class="keyword">type</span> Network <span class="keyword">struct</span> &#123;</span><br><span class="line"> metav1.TypeMeta   <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line"> metav1.ObjectMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line"> </span><br><span class="line"> Spec   NetworkSpec   <span class="string">`json:&quot;spec&quot;`</span></span><br><span class="line"> Status NetworkStatus <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，+genclient 只需要写在 Network 类型上，而不用写在 NetworkList 上。因为 NetworkList 只是一个返回值类型，Network 才是“主类型”。</p>
<p>而由于我在 Global Tags 里已经定义了为所有类型生成 DeepCopy 方法，所以这里就不需要再显式地加上 +k8s:deepcopy-gen=true 了。当然，这也就意味着你可以用 +k8s:deepcopy-gen=false 来阻止为某些类型生成 DeepCopy。</p>
<p>你可能已经注意到，在这两个类型上面还有一句+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object的注释。它的意思是，请在生成 DeepCopy 的时候，实现 Kubernetes 提供的 runtime.Object 接口。否则，在某些版本的 Kubernetes 里，你的这个类型定义会出现编译错误。这是一个固定的操作，记住即可。</p>
<p>不过，你或许会有这样的顾虑：这些代码生成注释这么灵活，我该怎么掌握呢？</p>
<p>其实，上面我所讲述的内容，已经足以应对 99% 的场景了。当然，如果你对代码生成感兴趣的话，我推荐你阅读这篇博客，它详细地介绍了 Kubernetes 的代码生成语法。</p>
<p><strong>最后，我需要再编写一个 pkg/apis/samplecrd/v1/register.go 文件。</strong></p>
<p>在前面对 APIServer 工作原理的讲解中，我已经提到，“registry”的作用就是注册一个类型（Type）给 APIServer。其中，Network 资源类型在服务器端注册的工作，APIServer 会自动帮我们完成。但与之对应的，我们还需要让客户端也能“知道”Network 资源类型的定义。这就需要我们在项目里添加一个 register.go 文件。它最主要的功能，就是定义了如下所示的 addKnownTypes() 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line">...</span><br><span class="line"><span class="comment">// addKnownTypes adds our types to the API scheme by registering</span></span><br><span class="line"><span class="comment">// Network and NetworkList</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> scheme.AddKnownTypes(</span><br><span class="line">  SchemeGroupVersion,</span><br><span class="line">  &amp;Network&#123;&#125;,</span><br><span class="line">  &amp;NetworkList&#123;&#125;,</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// register the type in the scheme</span></span><br><span class="line"> metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有了这个方法，Kubernetes 就能够在后面生成客户端的时候，“知道”Network 以及 NetworkList 类型的定义了。</p>
<p>像上面这种 <strong>register.go 文件里的内容其实是非常固定的，你以后可以直接使用我提供的这部分代码做模板，然后把其中的资源类型、GroupName 和 Version 替换成你自己的定义即可。</strong></p>
<p>这样，Network 对象的定义工作就全部完成了。可以看到，它其实定义了两部分内容：</p>
<ul>
<li>第一部分是，自定义资源类型的 API 描述，包括：组（Group）、版本（Version）、资源类型（Resource）等。这相当于告诉了计算机：兔子是哺乳动物。</li>
<li>第二部分是，自定义资源类型的对象描述，包括：Spec、Status 等。这相当于告诉了计算机：兔子有长耳朵和三瓣嘴。</li>
</ul>
<p>接下来，<font color=orange>我就要使用 Kubernetes 提供的代码生成工具，为上面定义的 Network 资源类型自动生成 clientset、informer 和 lister。</font>其中，clientset 就是操作 Network 对象所需要使用的客户端，而 informer 和 lister 这两个包的主要功能，我会在下一篇文章中重点讲解。</p>
<p>这个代码生成工具名叫k8s.io/code-generator，使用方法如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 代码生成的工作目录，也就是我们的项目路径</span></span><br><span class="line">$ ROOT_PACKAGE=<span class="string">&quot;github.com/gxstax/k8s-custom-controller&quot;</span></span><br><span class="line"><span class="comment"># API Group</span></span><br><span class="line">$ CUSTOM_RESOURCE_NAME=<span class="string">&quot;samplecrd&quot;</span></span><br><span class="line"><span class="comment"># API Version</span></span><br><span class="line">$ CUSTOM_RESOURCE_VERSION=<span class="string">&quot;v1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装k8s.io/code-generator</span></span><br><span class="line">$ go get -u k8s.io/code-generator/...</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/k8s.io/code-generator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行代码自动生成，其中pkg/client是生成目标目录，pkg/apis是类型定义目录</span></span><br><span class="line">$ ./generate-groups.sh all <span class="string">&quot;<span class="variable">$ROOT_PACKAGE</span>/pkg/client&quot;</span> <span class="string">&quot;<span class="variable">$ROOT_PACKAGE</span>/pkg/apis&quot;</span> <span class="string">&quot;<span class="variable">$CUSTOM_RESOURCE_NAME</span>:<span class="variable">$CUSTOM_RESOURCE_VERSION</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>代码生成工作完成之后，我们再查看一下这个项目的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">└── pkg</span><br><span class="line">    ├── apis</span><br><span class="line">    │   └── samplecrd</span><br><span class="line">    │       ├── register.go</span><br><span class="line">    │       └── v1</span><br><span class="line">    │           ├── doc.go</span><br><span class="line">    │           ├── register.go</span><br><span class="line">    │           └── types.go</span><br><span class="line">    └── client</span><br><span class="line">        └── clientset</span><br><span class="line">            └── versioned</span><br><span class="line">                ├── clientset.go</span><br><span class="line">                ├── doc.go</span><br><span class="line">                ├── fake</span><br><span class="line">                │   ├── clientset_generated.go</span><br><span class="line">                │   ├── doc.go</span><br><span class="line">                │   └── register.go</span><br><span class="line">                ├── scheme</span><br><span class="line">                │   ├── doc.go</span><br><span class="line">                │   └── register.go</span><br><span class="line">                └── typed</span><br><span class="line">                    └── samplecrd</span><br><span class="line">                        └── v1</span><br><span class="line">                            ├── doc.go</span><br><span class="line">                            ├── fake</span><br><span class="line">                            │   ├── doc.go</span><br><span class="line">                            │   └── fake_samplecrd_client.go</span><br><span class="line">                            ├── generated_expansion.go</span><br><span class="line">                            └── samplecrd_client.go</span><br></pre></td></tr></table></figure>

<p>其中，pkg/apis/samplecrd/v1 下面的 zz_generated.deepcopy.go 文件，就是自动生成的 DeepCopy 代码文件。</p>
<p>而整个 client 目录，以及下面的三个包（clientset、informers、 listers），都是 Kubernetes 为 Network 类型生成的客户端库，这些库会在后面编写自定义控制器的时候用到。</p>
<p>可以看到，到目前为止的这些工作，其实并不要求你写多少代码，主要考验的是“复制、粘贴、替换”这样的“基本功”。</p>
<p>而有了这些内容，现在你就可以<font color=orange>在 Kubernetes 集群里创建一个 Network 类型的 API 对象了。</font>我们不妨一起来试验下。</p>
<p><strong>首先，</strong> 使用 network.yaml 文件，在 Kubernetes 中创建 Network 对象的 CRD（Custom Resource Definition）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f crd/network.yaml</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networks.samplecrd.x-k8s.io created</span><br></pre></td></tr></table></figure>

<p>这个操作，就告诉了 Kubernetes，我现在要添加一个自定义的 API 对象。而这个对象的 API 信息，正是 network.yaml 里定义的内容。我们可以通过 kubectl get 命令，查看这个 CRD：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get crd</span><br><span class="line">NAME                                         CREATED AT</span><br><span class="line">networks.samplecrd.x-k8s.io                  2022-03-08T07:26:58Z</span><br></pre></td></tr></table></figure>

<p><strong>然后，</strong>我们就可以创建一个 Network 对象了，这里用到的是 example-network.yaml：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f example/example-network.yaml</span><br><span class="line">network.samplecrd.x-k8s.io/example-network created</span><br></pre></td></tr></table></figure>

<p>通过这个操作，你就在 Kubernetes 集群里创建了一个 Network 对象。它的 API 资源路径是samplecrd.k8s.io/v1/networks。</p>
<p>这时候，你就可以通过 kubectl get 命令，查看到新创建的 Network 对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get network</span><br><span class="line">NAME              AGE</span><br><span class="line">example-network   101s</span><br></pre></td></tr></table></figure>

<p>你还可以通过 kubectl describe 命令，看到这个 Network 对象的细节：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe network example-network</span><br><span class="line">Name:         example-network</span><br><span class="line">Namespace:    default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">API Version:  samplecrd.x-k8s.io/v1</span><br><span class="line">Kind:         Network</span><br><span class="line">Metadata:</span><br><span class="line">  Creation Timestamp:  2022-03-08T07:27:22Z</span><br><span class="line">  Generation:          1</span><br><span class="line">  Managed Fields:</span><br><span class="line">    API Version:  samplecrd.x-k8s.io/v1</span><br><span class="line">    Fields Type:  FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:annotations:</span><br><span class="line">          .:</span><br><span class="line">          f:kubectl.kubernetes.io/last-applied-configuration:</span><br><span class="line">      f:spec:</span><br><span class="line">        .:</span><br><span class="line">        f:cidr:</span><br><span class="line">        f:gateway:</span><br><span class="line">    Manager:         kubectl-client-side-apply</span><br><span class="line">    Operation:       Update</span><br><span class="line">    Time:            2022-03-08T07:27:22Z</span><br><span class="line">  Resource Version:  4582056</span><br><span class="line">  UID:               86a7188c-4dec-4479-9e72-36ac92b0af63</span><br><span class="line">Spec:</span><br><span class="line">  Cidr:     192.168.0.0/16</span><br><span class="line">  Gateway:  192.168.0.1</span><br><span class="line">Events:     &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>当然 ，你也可以编写更多的 YAML 文件来创建更多的 Network 对象，这和创建 Pod、Deployment 的操作，没有任何区别。</p>

        </div>
        
<blockquote class="copyright">
    <p><strong>本文链接 : </strong><a class="permalink" href="https://gxstax.github.io/2022/03/08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPI%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98/">https://gxstax.github.io/2022/03/08/深入解析声明式API（一）：API对象的奥秘/</a></p>
    <p><strong>This article is available under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a> License</strong></p>
</blockquote>


    </article>
    
    <section id="comments">
        

        
    </section>


    

</main>


<aside style="" id="sidebar" class="aside aside-fixture">
    <div class="toc-sidebar">
        <nav id="toc" class="article-toc">
            <h3 class="toc-title">文章目录</h3>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-%E5%A3%B0%E6%98%8E%E5%BC%8F-API-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes 声明式 API 的工作原理</span></a></li></ol>
        </nav>
    </div>
</aside>





        </section>
        <footer class="hidden lg:block fixed bottom-0 left-0 sm:w-1/12 lg:w-1/6 bg-gray-100 z-40">
    
    <div class="footer-social-links">
        
            <a target="_blank" rel="noopener" href="https://github.com/gxstax">
                <i class="iconfont icon-github"></i>
            </a>
        
            <a target="_blank" rel="noopener" href="https://t.me/gxstax">
                <i class="iconfont icon-telegram"></i>
            </a>
        
            <a target="_blank" rel="noopener" href="https://twitter.com/Ant78261681">
                <i class="iconfont icon-twitter"></i>
            </a>
        
            <a target="_blank" rel="noopener" href="https://rss.com/podcasts/ant/">
                <i class="iconfont icon-rss"></i>
            </a>
        
    </div>
    
    
</footer>

        <div id="mask" class="hidden mask fixed inset-0 bg-gray-900 opacity-75 z-40"></div>
        <div id="search-view-container" class="hidden shadow-xl"></div>
        
<script src="/js/dom-event.min.js"></script>



<script src="/js/local-search.min.js"></script>


    <script src="//cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'gxstax.github.io',
        owner: 'gxstax',
        admin: ['gxstax'],
        id: md5(location.pathname),
        distractionFreeMode: true
    })
    gitalk.render('comments')
</script>



    <script src="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/js/lightgallery.min.js"></script>
    
<script src="/js/light-gallery.min.js"></script>






    </body>
</html>
