{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/purer/source/css/common.min.css","path":"css/common.min.css","modified":0,"renderable":1},{"_id":"themes/purer/source/css/iconfont.min.css","path":"css/iconfont.min.css","modified":0,"renderable":1},{"_id":"themes/purer/source/js/dom-event.min.js","path":"js/dom-event.min.js","modified":0,"renderable":1},{"_id":"themes/purer/source/js/light-gallery.min.js","path":"js/light-gallery.min.js","modified":0,"renderable":1},{"_id":"themes/purer/source/js/local-search.min.js","path":"js/local-search.min.js","modified":0,"renderable":1},{"_id":"themes/purer/source/js/repository.min.js","path":"js/repository.min.js","modified":0,"renderable":1},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"themes/purer/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/purer/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"source/images/k8s/k8s-api-tree.png","path":"images/k8s/k8s-api-tree.png","modified":0,"renderable":0},{"_id":"source/images/k8s/api-server-build.png","path":"images/k8s/api-server-build.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"bbf6fbfb252fdbbf21a284005523791a6f24da90","modified":1646104640780},{"_id":"themes/hexo-theme-purer/layout/_common/fancybox.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1624442795000},{"_id":"themes/hexo-theme-purer/README.md","hash":"ecd2818f1505aca592cfd7d295432f257fb6adae","modified":1624442795000},{"_id":"themes/hexo-theme-purer/.browserslistrc","hash":"eb6d54d28955dc1d46af02707cb8058b21949f14","modified":1624442795000},{"_id":"themes/hexo-theme-purer/.gitignore","hash":"ec5f56c4dc92ea4c64119bbe5f334e48ce7aa2ec","modified":1624442795000},{"_id":"themes/hexo-theme-purer/.eslintrc.json","hash":"414df91e71ec5c0fa9f452ebe8ce600e1cbf9e27","modified":1624442795000},{"_id":"themes/hexo-theme-purer/gulpfile.js","hash":"89d934c4d71a913ded01542cf547858b6d0b274a","modified":1624442795000},{"_id":"themes/hexo-theme-purer/_config.example.yml","hash":"5c5e327fc5a3f9ff2c41e72145b4cc6f38295392","modified":1624442795000},{"_id":"themes/hexo-theme-purer/LICENSE","hash":"c7e216f59494ddc7b7c02f8a198ddb08d87e1242","modified":1624442795000},{"_id":"themes/hexo-theme-purer/tailwind.config.js","hash":"755966d42a7c0b818d12424e49f1b9bb498487bb","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/archive.ejs","hash":"17b62ba9a3eff4caad2f32893a2b12d93f4fbe58","modified":1645962482738},{"_id":"themes/hexo-theme-purer/layout/category.ejs","hash":"38d1387564333449659c76d92a71b1acfb2caa77","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/index.ejs","hash":"70b3c41ffd67774a24d0f176f25612ccb3ebf2d5","modified":1645962401610},{"_id":"themes/hexo-theme-purer/layout/post.ejs","hash":"f5c10f7472ec0ffc882c93be05ab69325914b07e","modified":1624442795000},{"_id":"themes/hexo-theme-purer/package.json","hash":"e878ee522d429a751fcfc10492dcd8e91f69f521","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/layout.ejs","hash":"81252ed8767d1d31df71959492180d837faa312f","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/tag.ejs","hash":"a4d323c8ceb0ba9d907c17cf7b6db45d9d26a6d9","modified":1624442795000},{"_id":"themes/hexo-theme-purer/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1624442795000},{"_id":"themes/hexo-theme-purer/languages/en.yml","hash":"4b0365376150241b27ff18a82dc0599a422b35e3","modified":1624442795000},{"_id":"themes/hexo-theme-purer/languages/zh-CN.yml","hash":"30e1f76fdbefce2336e0dfd0009cd2981943975e","modified":1624442795000},{"_id":"themes/hexo-theme-purer/scripts/page_title.js","hash":"5163e25788bebcdb89cbededa97ec980ad0bdfba","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_comment/gitalk.ejs","hash":"41e447512bf85359733d6c87e2991f5ad6efc9b7","modified":1624442795000},{"_id":"themes/hexo-theme-purer/languages/zh-TW.yml","hash":"296596bd9c5bd3d6ab242ae5ab5734919708d195","modified":1624442795000},{"_id":"themes/hexo-theme-purer/.github/workflows/build.yml","hash":"7aa6addcf9ef2ae03dee4fdd2edab998f552f163","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_comment/livere.ejs","hash":"bda6ade3f4671304dcbdb5b2acd56295f07d6cac","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_comment/disqus.ejs","hash":"624e637d219db57290fe68d2179bffb619f3cdb8","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_comment/valine.ejs","hash":"f952bc69a55b5ab9aa3de6b146903fdcb7f44616","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_common/aside.ejs","hash":"84ff19181f05803135a6bc665afa02187c96b486","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_common/head.ejs","hash":"a1ed99a6d04367f102fe40aa4adc6f9c5ed56b86","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_common/footer.ejs","hash":"17068dd236917325cca3358df3109f8dcf07b9e7","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_common/header.ejs","hash":"a432767dd35522ae5a0d9fda7a2b4037e9bcc504","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_common/scripts.ejs","hash":"0b9c8eec6e53c8c1c66f873450c60dab4fb3e1e2","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_page/categories.ejs","hash":"dc38223fe6aa5fe4ecfebd09348f617eeec89957","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_common/social.ejs","hash":"5c1f46accb08e34a3ac5650f112adaa0f41ca9dc","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_page/links.ejs","hash":"75ab089c4c2a88882fc09bf7de1de218cf6ce154","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_page/repository.ejs","hash":"6c068739c6d18a02fdcfdb9b075280c53ef7ce5f","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_page/post.ejs","hash":"26b54901a4882aa6510a0eb15d833050a0b9e0e9","modified":1645962838143},{"_id":"themes/hexo-theme-purer/layout/_page/tagcloud.ejs","hash":"5f5a4f5d94123f86f096fcca50f77c1edb79a4b9","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/archive.ejs","hash":"bbe8a6d8d9198312c04fea9e4a945ea18e4d4cd8","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/article-list.ejs","hash":"28a84fa66c6a1520dd7abb375b4caabeb16da592","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/article-post.ejs","hash":"bc262bee3f75dfaec7d47279e034450e1b9167c9","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/comment.ejs","hash":"d90d9568cd248d50b302140998827bd6816d70f4","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post-item-list.ejs","hash":"55eb78c1ec9e6c566558e6f6f45fd4a9827f7f32","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/pagination.ejs","hash":"8f0475281d6f4d5e166940d051b20a85703261e6","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/sidebar-about.ejs","hash":"01a081c878faf8c95311fdbdb9088b901159e30f","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/sidebar-toc.ejs","hash":"09403da4f35fc238c275e7595be771fd3c3b8b76","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_search/index.ejs","hash":"67c7e748035526d2d05dec25b3d0c84f286dcbfe","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_search/local.ejs","hash":"e6665eeb1a518f3e2c3bafb7a9a377a37246f81c","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_widget/archive.ejs","hash":"a0a92a6ec51545fe6bb35fae633f68fa3d96d92b","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_widget/category.ejs","hash":"7fa7de678815575c63f2f1c088fd5b695e5dfcf4","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_widget/tag.ejs","hash":"af79f60890cc21500269ade140f594dbd6f6c653","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_widget/recent_posts.ejs","hash":"baa2a1f61ae52d22058ed73908cb254cd4e0b880","modified":1624442795000},{"_id":"themes/hexo-theme-purer/source/js/dom-event.min.js","hash":"cca69743e4f5987f686726b5ca066bf9015c0bd9","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_widget/tagcloud.ejs","hash":"4b7508757eb752730c98a26052e9a273b6c1b8f3","modified":1624442795000},{"_id":"themes/hexo-theme-purer/source/js/light-gallery.min.js","hash":"8c35c7d21474427dcd1956f8c0e5fd9dfe27d643","modified":1624442795000},{"_id":"themes/hexo-theme-purer/source/js/local-search.min.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1624442795000},{"_id":"themes/hexo-theme-purer/source/js/repository.min.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/css/common.css","hash":"1b9fefbea8576528bcd067ea27ca985839ac7f58","modified":1624442795000},{"_id":"themes/hexo-theme-purer/source/css/iconfont.min.css","hash":"ad1368ebb996376abb4e4fec22fbc1efe55cdc6a","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post/copyright.ejs","hash":"7d4cf2e704d497c8203b071b3e2ada0b4ba663b3","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/css/iconfont.css","hash":"02eaa919fc6a5649b2ad28c84dcfc363a2b919b7","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post/gallery.ejs","hash":"a1c54188e90d81f64705591e8ea79bf56ce120ae","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post/tag.ejs","hash":"3c69334ea699ebea0dd2a4f897b3f48da26644da","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post/date.ejs","hash":"7a784cc9a9b14b9df59221417fdeac58f8287d8e","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post/category.ejs","hash":"6b5e5d432a3e80eed4e0ffa49e436e0ca5d8fec8","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post/wordcount.ejs","hash":"1fb385db6e3ab0e6f64857201d672b52a304a86d","modified":1624442795000},{"_id":"themes/hexo-theme-purer/layout/_partial/post/title.ejs","hash":"8deee3f1b8af1e7d2b8877f9397cfa87fd29c9bd","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/dom-event/menu-toggle-btn.js","hash":"d45c1261603e745dca32a2f6c9a7e9df6b639a7f","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/dom-event/search-toggle.js","hash":"7baf6610fd7132f0d8c2520bc98192deb7b79a86","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/light-gallery/lg-fullscreen.js","hash":"ad98f80f4a9528be6b0360c2a5146984369f9bb2","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/light-gallery/light-gallery.js","hash":"317975101786a68fb62ecb0ddb2cbcc7c2eced2d","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/light-gallery/lg-zoom.js","hash":"460c3a25afde37a76c77e90b8d1a0b7a3e8716dd","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/README.md","hash":"6a0bf5dc5289473fcdc334f99ec329c48ef536f5","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/.gitignore","hash":"fdfe659641b002acb68924bd4ca0daa13c4b61c1","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/package.json","hash":"0f8dce34d768a3282267b0b8449ed075957a15f7","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/rollup.config.js","hash":"f2eb9a3ae605cc4860c5fb6788ee0d939cb6679f","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/dist/bundle.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/src/App.svelte","hash":"d75fd9f0a551d7b343e597400edaa3b6a944bcac","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/README.md","hash":"6a0bf5dc5289473fcdc334f99ec329c48ef536f5","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/tsconfig.json","hash":"b22d2f4a63df7a7bffdab77cefca49f93bedc224","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/.gitignore","hash":"fdfe659641b002acb68924bd4ca0daa13c4b61c1","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/src/main.ts","hash":"b219544a58231cd95cd6ba9a3acaa9f0697b4da0","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/rollup.config.js","hash":"683cc79836279df64dbe5ae2907155aa752cd5c9","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/package.json","hash":"0f8dce34d768a3282267b0b8449ed075957a15f7","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/dist/bundle.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/src/App.svelte","hash":"a48e50da3c31365301713405899fa223d1329d05","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/tsconfig.json","hash":"b1bd60b911b0cbf2957f4e0676498ab38ba54895","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/src/main.ts","hash":"6a1ca1fbea921438cf6bf1ba4e0146d9decf3a35","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/repository/package-lock.json","hash":"052f2c4da6e7a4b11c3a932f1b848c5e449f6a9e","modified":1624442795000},{"_id":"themes/hexo-theme-purer/src/js/search/local-search/package-lock.json","hash":"052f2c4da6e7a4b11c3a932f1b848c5e449f6a9e","modified":1624442795000},{"_id":"themes/hexo-theme-purer/package-lock.json","hash":"795463bbc575aba245387dd9a229a4df19ae1cf3","modified":1624442795000},{"_id":"themes/hexo-theme-purer/source/css/common.min.css","hash":"df3460335c6e2817790bc11836ccc9489a92882a","modified":1624442795000},{"_id":"public/2022/02/27/hello-world/index.html","hash":"5ab48244c72a0e519a6601ecd3bf34e7267d0a99","modified":1646104141513},{"_id":"public/archives/index.html","hash":"83d24593b321b98b367d8018c8f61cc7026854c0","modified":1648970620712},{"_id":"public/archives/2022/index.html","hash":"990efb2b3e29a5f318d456fa442e0b4a7b33539a","modified":1648970620712},{"_id":"public/archives/2022/02/index.html","hash":"73ce94557b9510e2a9cc19f030b724fd0abc669f","modified":1648970620712},{"_id":"public/index.html","hash":"dc62e836cd5c3ff59ef7aec6919f07ffc638af4c","modified":1648970620712},{"_id":"public/js/dom-event.min.js","hash":"cca69743e4f5987f686726b5ca066bf9015c0bd9","modified":1645962138724},{"_id":"public/js/repository.min.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1645962138724},{"_id":"public/js/light-gallery.min.js","hash":"8c35c7d21474427dcd1956f8c0e5fd9dfe27d643","modified":1645962138724},{"_id":"public/css/iconfont.min.css","hash":"ad1368ebb996376abb4e4fec22fbc1efe55cdc6a","modified":1645962138724},{"_id":"public/js/local-search.min.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1645962138724},{"_id":"public/css/common.min.css","hash":"df3460335c6e2817790bc11836ccc9489a92882a","modified":1645962138724},{"_id":"themes/hexo-theme-purer/.DS_Store","hash":"cddda3c9d08808ed83dfd6557ab63d46d5d83db3","modified":1645962261474},{"_id":"themes/hexo-theme-purer/layout/.DS_Store","hash":"bcbfec4d4530e93a23e5b4bbceda21b72a20310b","modified":1645962689099},{"_id":"themes/purer/layout/_common/fancybox.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1645963472623},{"_id":"themes/purer/.browserslistrc","hash":"eb6d54d28955dc1d46af02707cb8058b21949f14","modified":1645963472620},{"_id":"themes/purer/.eslintrc.json","hash":"414df91e71ec5c0fa9f452ebe8ce600e1cbf9e27","modified":1645963472620},{"_id":"themes/purer/.gitignore","hash":"ec5f56c4dc92ea4c64119bbe5f334e48ce7aa2ec","modified":1645963472620},{"_id":"themes/purer/LICENSE","hash":"c7e216f59494ddc7b7c02f8a198ddb08d87e1242","modified":1645963472621},{"_id":"themes/purer/README.md","hash":"ecd2818f1505aca592cfd7d295432f257fb6adae","modified":1645963472621},{"_id":"themes/purer/_config.example.yml","hash":"5c5e327fc5a3f9ff2c41e72145b4cc6f38295392","modified":1645963472621},{"_id":"themes/purer/gulpfile.js","hash":"89d934c4d71a913ded01542cf547858b6d0b274a","modified":1645963472621},{"_id":"themes/purer/package.json","hash":"30c30c740e119a37c4e0e23e4acd27fe8a6dd7f7","modified":1645963991366},{"_id":"themes/purer/tailwind.config.js","hash":"755966d42a7c0b818d12424e49f1b9bb498487bb","modified":1645963472649},{"_id":"themes/purer/languages/en.yml","hash":"4569d8b7bc0894f5b5de49046e9b9f19181a10f0","modified":1646017408886},{"_id":"themes/purer/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1645963472622},{"_id":"themes/purer/languages/zh-CN.yml","hash":"4c30455b7282ce73f7fe26f052f9d40e89eee3b6","modified":1646019386287},{"_id":"themes/purer/languages/zh-TW.yml","hash":"296596bd9c5bd3d6ab242ae5ab5734919708d195","modified":1645963472622},{"_id":"themes/purer/layout/archive.ejs","hash":"291a1e98b49e7a2bc848b37408ebc09650327af2","modified":1645963472628},{"_id":"themes/purer/layout/category.ejs","hash":"38d1387564333449659c76d92a71b1acfb2caa77","modified":1645963472628},{"_id":"themes/purer/layout/index.ejs","hash":"cfca463c79c8bc689c0c68a642295933cbdafbfa","modified":1645963472628},{"_id":"themes/purer/layout/layout.ejs","hash":"81252ed8767d1d31df71959492180d837faa312f","modified":1645963472628},{"_id":"themes/purer/layout/post.ejs","hash":"f5c10f7472ec0ffc882c93be05ab69325914b07e","modified":1645963472628},{"_id":"themes/purer/layout/tag.ejs","hash":"a4d323c8ceb0ba9d907c17cf7b6db45d9d26a6d9","modified":1645963472628},{"_id":"themes/purer/scripts/page_title.js","hash":"5163e25788bebcdb89cbededa97ec980ad0bdfba","modified":1645963472631},{"_id":"themes/purer/.github/workflows/build.yml","hash":"7aa6addcf9ef2ae03dee4fdd2edab998f552f163","modified":1645963472620},{"_id":"themes/purer/layout/_comment/disqus.ejs","hash":"624e637d219db57290fe68d2179bffb619f3cdb8","modified":1645963472622},{"_id":"themes/purer/layout/_comment/gitalk.ejs","hash":"41e447512bf85359733d6c87e2991f5ad6efc9b7","modified":1645963472622},{"_id":"themes/purer/layout/_comment/livere.ejs","hash":"bda6ade3f4671304dcbdb5b2acd56295f07d6cac","modified":1645963472622},{"_id":"themes/purer/layout/_comment/valine.ejs","hash":"f952bc69a55b5ab9aa3de6b146903fdcb7f44616","modified":1645963472623},{"_id":"themes/purer/layout/_common/aside.ejs","hash":"84ff19181f05803135a6bc665afa02187c96b486","modified":1645963472623},{"_id":"themes/purer/layout/_common/footer.ejs","hash":"17068dd236917325cca3358df3109f8dcf07b9e7","modified":1645963472623},{"_id":"themes/purer/layout/_common/head.ejs","hash":"a1ed99a6d04367f102fe40aa4adc6f9c5ed56b86","modified":1645963472623},{"_id":"themes/purer/layout/_common/header.ejs","hash":"a432767dd35522ae5a0d9fda7a2b4037e9bcc504","modified":1645963472623},{"_id":"themes/purer/layout/_common/scripts.ejs","hash":"0b9c8eec6e53c8c1c66f873450c60dab4fb3e1e2","modified":1645963472623},{"_id":"themes/purer/layout/_common/social.ejs","hash":"5c1f46accb08e34a3ac5650f112adaa0f41ca9dc","modified":1645963472623},{"_id":"themes/purer/layout/_page/categories.ejs","hash":"dc38223fe6aa5fe4ecfebd09348f617eeec89957","modified":1645963472624},{"_id":"themes/purer/layout/_page/links.ejs","hash":"75ab089c4c2a88882fc09bf7de1de218cf6ce154","modified":1645963472624},{"_id":"themes/purer/layout/_page/post.ejs","hash":"5323d12c0ea932c428a37dabefd4b91001dcaf88","modified":1645963472624},{"_id":"themes/purer/layout/_page/repository.ejs","hash":"6c068739c6d18a02fdcfdb9b075280c53ef7ce5f","modified":1645963472624},{"_id":"themes/purer/layout/_page/tagcloud.ejs","hash":"5f5a4f5d94123f86f096fcca50f77c1edb79a4b9","modified":1645963472624},{"_id":"themes/purer/layout/_partial/archive.ejs","hash":"bbe8a6d8d9198312c04fea9e4a945ea18e4d4cd8","modified":1645963472624},{"_id":"themes/purer/layout/_partial/article-list.ejs","hash":"28a84fa66c6a1520dd7abb375b4caabeb16da592","modified":1645963472624},{"_id":"themes/purer/layout/_partial/article-post.ejs","hash":"bc262bee3f75dfaec7d47279e034450e1b9167c9","modified":1645963472625},{"_id":"themes/purer/layout/_partial/comment.ejs","hash":"d90d9568cd248d50b302140998827bd6816d70f4","modified":1645963472625},{"_id":"themes/purer/layout/_partial/pagination.ejs","hash":"8f0475281d6f4d5e166940d051b20a85703261e6","modified":1645963472625},{"_id":"themes/purer/layout/_partial/post-item-list.ejs","hash":"55eb78c1ec9e6c566558e6f6f45fd4a9827f7f32","modified":1645963472625},{"_id":"themes/purer/layout/_partial/sidebar-about.ejs","hash":"01a081c878faf8c95311fdbdb9088b901159e30f","modified":1645963472626},{"_id":"themes/purer/layout/_partial/sidebar-toc.ejs","hash":"09403da4f35fc238c275e7595be771fd3c3b8b76","modified":1645963472626},{"_id":"themes/purer/layout/_search/index.ejs","hash":"67c7e748035526d2d05dec25b3d0c84f286dcbfe","modified":1645963472626},{"_id":"themes/purer/layout/_search/local.ejs","hash":"e6665eeb1a518f3e2c3bafb7a9a377a37246f81c","modified":1645963472626},{"_id":"themes/purer/layout/_widget/archive.ejs","hash":"a0a92a6ec51545fe6bb35fae633f68fa3d96d92b","modified":1645963472627},{"_id":"themes/purer/layout/_widget/category.ejs","hash":"7fa7de678815575c63f2f1c088fd5b695e5dfcf4","modified":1645963472627},{"_id":"themes/purer/layout/_widget/recent_posts.ejs","hash":"baa2a1f61ae52d22058ed73908cb254cd4e0b880","modified":1645963472627},{"_id":"themes/purer/layout/_widget/tag.ejs","hash":"af79f60890cc21500269ade140f594dbd6f6c653","modified":1645963472627},{"_id":"themes/purer/layout/_widget/tagcloud.ejs","hash":"4b7508757eb752730c98a26052e9a273b6c1b8f3","modified":1645963472627},{"_id":"themes/purer/source/css/iconfont.min.css","hash":"ad1368ebb996376abb4e4fec22fbc1efe55cdc6a","modified":1645963472640},{"_id":"themes/purer/src/css/iconfont.css","hash":"02eaa919fc6a5649b2ad28c84dcfc363a2b919b7","modified":1645963472642},{"_id":"themes/purer/src/css/common.css","hash":"1b9fefbea8576528bcd067ea27ca985839ac7f58","modified":1645963472642},{"_id":"themes/purer/source/js/dom-event.min.js","hash":"cca69743e4f5987f686726b5ca066bf9015c0bd9","modified":1645963472640},{"_id":"themes/purer/source/js/light-gallery.min.js","hash":"8c35c7d21474427dcd1956f8c0e5fd9dfe27d643","modified":1645963472641},{"_id":"themes/purer/source/js/local-search.min.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1645963472641},{"_id":"themes/purer/source/js/repository.min.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1645963472641},{"_id":"themes/purer/layout/_partial/post/date.ejs","hash":"7a784cc9a9b14b9df59221417fdeac58f8287d8e","modified":1645963472625},{"_id":"themes/purer/layout/_partial/post/tag.ejs","hash":"3c69334ea699ebea0dd2a4f897b3f48da26644da","modified":1645963472626},{"_id":"themes/purer/layout/_partial/post/copyright.ejs","hash":"7d4cf2e704d497c8203b071b3e2ada0b4ba663b3","modified":1645963472625},{"_id":"themes/purer/layout/_partial/post/category.ejs","hash":"6b5e5d432a3e80eed4e0ffa49e436e0ca5d8fec8","modified":1645963472625},{"_id":"themes/purer/layout/_partial/post/gallery.ejs","hash":"a1c54188e90d81f64705591e8ea79bf56ce120ae","modified":1645963472625},{"_id":"themes/purer/layout/_partial/post/title.ejs","hash":"8deee3f1b8af1e7d2b8877f9397cfa87fd29c9bd","modified":1645963472626},{"_id":"themes/purer/layout/_partial/post/wordcount.ejs","hash":"1fb385db6e3ab0e6f64857201d672b52a304a86d","modified":1645963472626},{"_id":"themes/purer/src/js/dom-event/menu-toggle-btn.js","hash":"d45c1261603e745dca32a2f6c9a7e9df6b639a7f","modified":1645963472642},{"_id":"themes/purer/src/js/dom-event/search-toggle.js","hash":"7baf6610fd7132f0d8c2520bc98192deb7b79a86","modified":1645963472643},{"_id":"themes/purer/src/js/light-gallery/lg-fullscreen.js","hash":"ad98f80f4a9528be6b0360c2a5146984369f9bb2","modified":1645963472643},{"_id":"themes/purer/src/js/light-gallery/lg-zoom.js","hash":"460c3a25afde37a76c77e90b8d1a0b7a3e8716dd","modified":1645963472643},{"_id":"themes/purer/src/js/repository/.gitignore","hash":"fdfe659641b002acb68924bd4ca0daa13c4b61c1","modified":1645963472644},{"_id":"themes/purer/src/js/light-gallery/light-gallery.js","hash":"317975101786a68fb62ecb0ddb2cbcc7c2eced2d","modified":1645963472644},{"_id":"themes/purer/src/js/repository/README.md","hash":"6a0bf5dc5289473fcdc334f99ec329c48ef536f5","modified":1645963472644},{"_id":"themes/purer/src/js/repository/package.json","hash":"0f8dce34d768a3282267b0b8449ed075957a15f7","modified":1645963472645},{"_id":"themes/purer/src/js/repository/rollup.config.js","hash":"f2eb9a3ae605cc4860c5fb6788ee0d939cb6679f","modified":1645963472645},{"_id":"themes/purer/src/js/repository/tsconfig.json","hash":"b22d2f4a63df7a7bffdab77cefca49f93bedc224","modified":1645963472646},{"_id":"themes/purer/src/js/repository/dist/bundle.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1645963472644},{"_id":"themes/purer/src/js/repository/src/App.svelte","hash":"d75fd9f0a551d7b343e597400edaa3b6a944bcac","modified":1645963472646},{"_id":"themes/purer/src/js/repository/src/main.ts","hash":"b219544a58231cd95cd6ba9a3acaa9f0697b4da0","modified":1645963472646},{"_id":"themes/purer/src/js/search/local-search/.gitignore","hash":"fdfe659641b002acb68924bd4ca0daa13c4b61c1","modified":1645963472647},{"_id":"themes/purer/src/js/search/local-search/README.md","hash":"6a0bf5dc5289473fcdc334f99ec329c48ef536f5","modified":1645963472647},{"_id":"themes/purer/src/js/search/local-search/package.json","hash":"0f8dce34d768a3282267b0b8449ed075957a15f7","modified":1645963472648},{"_id":"themes/purer/src/js/search/local-search/rollup.config.js","hash":"683cc79836279df64dbe5ae2907155aa752cd5c9","modified":1645963472648},{"_id":"themes/purer/src/js/search/local-search/tsconfig.json","hash":"b1bd60b911b0cbf2957f4e0676498ab38ba54895","modified":1645963472649},{"_id":"themes/purer/src/js/search/local-search/dist/bundle.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1645963472647},{"_id":"themes/purer/src/js/search/local-search/src/App.svelte","hash":"a48e50da3c31365301713405899fa223d1329d05","modified":1645963472648},{"_id":"themes/purer/src/js/search/local-search/src/main.ts","hash":"6a1ca1fbea921438cf6bf1ba4e0146d9decf3a35","modified":1645963472649},{"_id":"themes/purer/src/js/repository/package-lock.json","hash":"052f2c4da6e7a4b11c3a932f1b848c5e449f6a9e","modified":1645963472645},{"_id":"themes/purer/src/js/search/local-search/package-lock.json","hash":"052f2c4da6e7a4b11c3a932f1b848c5e449f6a9e","modified":1645963472648},{"_id":"themes/purer/package-lock.json","hash":"dd51207d3370b88e25ff746ba1e842dc41f9bf05","modified":1645963991454},{"_id":"themes/purer/source/css/common.min.css","hash":"df3460335c6e2817790bc11836ccc9489a92882a","modified":1645963472640},{"_id":"source/.DS_Store","hash":"484d1f2e346ed0ece817c01e7d98ed873fc4f688","modified":1646705978558},{"_id":"themes/purer/.DS_Store","hash":"951e63aa6c511ec49dfe7efd56dbad2cd4eb9015","modified":1646103179959},{"_id":"themes/purer/_config.yml","hash":"5f2c4ab901c6c71f3735c6f743487f5b643a34d6","modified":1646104735482},{"_id":"public/content.json","hash":"eefe695afcd95a1b18ec44f5ea89e658b62036a2","modified":1648970620712},{"_id":"source/_posts/项目发布流程.md","hash":"941d9211402acc3b2e983f5266c9618be034960a","modified":1646104600033},{"_id":"source/云原生/index.md","hash":"1661b92f84fa220ce51b7242190e8fde32a414d7","modified":1646016050504},{"_id":"public/云原生/index.html","hash":"6be99e87ff350c156d8319240604d4f514d34593","modified":1648970620712},{"_id":"public/2022/02/28/项目发布流程/index.html","hash":"03f9b95668c0bc428225abb666c328683969c2a2","modified":1646104141513},{"_id":"source/categories/index.md","hash":"7871581e570ab3b76aca7e11387992a8766f1805","modified":1646016496286},{"_id":"public/categories/index.html","hash":"1929956d851efe18d5f2e5713ca4177d45e262eb","modified":1648970620712},{"_id":"source/_posts/解决k8s相关组件安装镜像无法拉取.md","hash":"afc58226c0dd64b79e4a2d122a527b8170f0cec0","modified":1646304399850},{"_id":"themes/purer/layout/.DS_Store","hash":"21b6c508aeb99add308d751103d80f73d3632210","modified":1646102188205},{"_id":"source/tags/index.md","hash":"afea093a50ae0331aa2787468084b8744465cf0b","modified":1646018589148},{"_id":"source/操作系统/index.md","hash":"dbb3019a80ab7868425b88caa22b700e21b65778","modified":1646017217477},{"_id":"source/_posts/StatefulSet之存储状态.md","hash":"cebfbe70b92c18adebdf38f55e97c987cd8c1cb2","modified":1646018751390},{"_id":"source/_posts/k8s命令.md","hash":"c5cadf31b6a4d2433c815ffc07ca8bc218e7ec40","modified":1646018714264},{"_id":"source/_posts/java指令码-字节码-对别.md","hash":"625236425c22b84f0d1a1197dec13afd1a01f3c5","modified":1645961400837},{"_id":"source/_posts/kafka最佳配置实践.md","hash":"d64c82534e1d4869a2296ba47520288646696e55","modified":1645961400837},{"_id":"source/_posts/linux命令.md","hash":"8a9d741b744197e2d86a06c58aae80d1ceb68c4e","modified":1645961400837},{"_id":"source/_posts/k8s-Headless-Service.md","hash":"7a697ae2ff16a40b8ea71d4c2da6bf6cdf82cea4","modified":1646018733139},{"_id":"source/_posts/linux编程-文件读取操作.md","hash":"873629815cc64cf7af20ec3172c920b0fab2894b","modified":1645961400838},{"_id":"source/_posts/mysql命令.md","hash":"40462f12d39e76d6f0c0755757f4444b4c38d94f","modified":1645961400838},{"_id":"source/_posts/rabbitmq.md","hash":"62323acaa0f7c7742dac9051eabe07f9027907ff","modified":1645961400838},{"_id":"source/_posts/使用静态内部类实现单例.md","hash":"a6dfcf469c6b984304f27144fbe083338039b663","modified":1645961400838},{"_id":"source/_posts/缓存数据库数据一致性保证演进过程.md","hash":"48763f65f87e0cfaf6e3df77c386bf03b3884d79","modified":1645961400838},{"_id":"source/_posts/网络设备状态标识.md","hash":"742495e20926cc11e13001917494f509c127c11c","modified":1645961400838},{"_id":"source/repository/index.md","hash":"c382806fef77e99afdd5eb3b2b901f29703a4274","modified":1646019027855},{"_id":"source/links/index.md","hash":"8a2e42a59661e076ef1deffa5add1e8536202cf0","modified":1646019263283},{"_id":"source/about/index.md","hash":"16fbfcc0474bddccba957de57ddcb8ed61953824","modified":1646019471965},{"_id":"public/repository/index.html","hash":"3e120bd025f4e21bccee6fdeaf879f9242a30c5a","modified":1646104141513},{"_id":"public/2022/02/23/rabbitmq/index.html","hash":"9b2a2fcdb54a36c452075ccdb36ebbc68a77aa39","modified":1646104141513},{"_id":"public/2020/02/23/mysql命令/index.html","hash":"6cfe802723987574386b1487ac9b85fba7c0b003","modified":1646104141513},{"_id":"public/2019/09/17/网络设备状态标识/index.html","hash":"e30d77c78053e78c53f70dc5e4b46ddf2e316113","modified":1646104141513},{"_id":"public/categories/云原生/index.html","hash":"54a26815959f8e2dbe7b7cf2a3de6734cc7ef29a","modified":1646724965926},{"_id":"public/categories/云原生/k8s/index.html","hash":"7a6e513cd2d067d9f16c71ad677fb3ba048d4393","modified":1646724965926},{"_id":"public/categories/middleware/index.html","hash":"10f71443f8ac68604a7cfa115a4f8356071cc256","modified":1646104141513},{"_id":"public/categories/java/index.html","hash":"fd7f32d27c54d8a39dbd45b35cee69d3368e8e1c","modified":1646104141513},{"_id":"public/categories/network/index.html","hash":"25e638b223b841167ba8f30ca9475aa627eae47d","modified":1646104141513},{"_id":"public/categories/jvm/index.html","hash":"1559dda74eb67d96733dcd7e3f5cffb3623817bf","modified":1646104141513},{"_id":"public/categories/db/index.html","hash":"d32d371c4470035587eb5c7cad350ca4e0446dbf","modified":1646104141513},{"_id":"public/categories/linux/index.html","hash":"8a11835b089728692790f70180401d37a6822d07","modified":1646104141513},{"_id":"public/categories/linuxProgram/index.html","hash":"ba71e4fa21fa8936ab44a4edf033b21a55ca997d","modified":1646104141513},{"_id":"public/tags/k8s/index.html","hash":"8d1f6ffd20a1b803bd0cec249945fa7720736f03","modified":1648970620712},{"_id":"public/tags/middleware/index.html","hash":"dbedb86d2c14a6094383b4a34c37059f7a38c8bf","modified":1646104141513},{"_id":"public/tags/java/index.html","hash":"1e1b6cbc58e06d2e34e36f39a7f41121c86b5a36","modified":1646104141513},{"_id":"public/tags/network/index.html","hash":"66961f775d9d820535a7a13871b46740b4e18c4d","modified":1646104141513},{"_id":"public/tags/db/index.html","hash":"22958f864f123c210ba8a512005f177c605dd73a","modified":1646104141513},{"_id":"public/tags/linux/index.html","hash":"6af3a285ce4c73d3448147cce1a48fe2a6cab63c","modified":1646104141513},{"_id":"public/tags/jvm/index.html","hash":"141c65a5d014f97e1ce7428411139fe742195f9f","modified":1646104141513},{"_id":"public/tags/linuxProgram/index.html","hash":"bd9834de9416afd279ec8769e105f7b05e9f2d2a","modified":1646104141513},{"_id":"public/tags/index.html","hash":"77d66ee4566cfb7cce58ac54fa376ba955ce8e3f","modified":1648970620712},{"_id":"public/links/index.html","hash":"9ce1449deee7f1e9274439c3e440903bf64c9d3d","modified":1648970620712},{"_id":"public/操作系统/index.html","hash":"b35b23d7ccfbc98df07fcf5917f6107a08ddaea4","modified":1648970620712},{"_id":"public/about/index.html","hash":"e02bed01593193ec899e528ec410dd01104a4b91","modified":1646104141513},{"_id":"public/2022/02/25/StatefulSet之存储状态/index.html","hash":"4f61e296a696b0e2c634ca01f6420c052f042316","modified":1646104141513},{"_id":"public/2022/02/25/k8s-Headless-Service/index.html","hash":"c2155a75989a59981f193fc15b2314faf560f1d6","modified":1646104141513},{"_id":"public/2022/02/22/k8s命令/index.html","hash":"b083a82e21fc16815b20efa175531d6c80eabd40","modified":1646104141513},{"_id":"public/2022/02/18/解决k8s相关组件安装镜像无法拉取/index.html","hash":"e4c1d3db8313a615abc1839365fa1a9e637c335a","modified":1646724965926},{"_id":"public/2021/12/23/缓存数据库数据一致性保证演进过程/index.html","hash":"7c6ab6de3ad3bd32aaf854c05a0ffa233adb7482","modified":1646104141513},{"_id":"public/2021/12/23/kafka最佳配置实践/index.html","hash":"453f7e6f538750c843e52dd42264d29d7e52d54a","modified":1646104141513},{"_id":"public/2019/05/28/linux编程-文件读取操作/index.html","hash":"92eacb1771ac506a2f62c03a02b7cd422bd4e729","modified":1646104141513},{"_id":"public/2019/04/13/linux命令/index.html","hash":"fbe9e78a97f5bb0c99b255af196787b84d4aac7a","modified":1646104141513},{"_id":"public/2019/04/03/java指令码-字节码-对别/index.html","hash":"fd9c1b744a56b4ea8c92352836d4fdad0226d9f3","modified":1646104141513},{"_id":"public/2018/11/23/使用静态内部类实现单例/index.html","hash":"f8b04cf99979cd455ab2e7315e0125ccecb97eec","modified":1646104141513},{"_id":"public/archives/page/2/index.html","hash":"bd2a09f24e42a7b61ff91b49cf6e5e013a591d7a","modified":1648970620712},{"_id":"public/archives/2018/index.html","hash":"1685e36895f3518ac8d646d6d6858119458c9e3f","modified":1648970620712},{"_id":"public/archives/2018/11/index.html","hash":"e85c85a1bf948be950028579deb4f6609118c20b","modified":1648970620712},{"_id":"public/archives/2019/index.html","hash":"9029cdbbb8522623fddd54852611fb81e8906bc2","modified":1648970620712},{"_id":"public/archives/2019/05/index.html","hash":"03de51ccc2330a93b9caad7fbd14c4fff553aee7","modified":1648970620712},{"_id":"public/archives/2019/04/index.html","hash":"3d6ca066bad9afe94927823fc082421a520b430c","modified":1648970620712},{"_id":"public/archives/2019/09/index.html","hash":"9010652e27d82ddc5fa853198060a20ce0061ddd","modified":1648970620712},{"_id":"public/archives/2020/index.html","hash":"42e73e6e6689d8a8bcfe6b292d3de3fcae5e1187","modified":1648970620712},{"_id":"public/archives/2020/02/index.html","hash":"76c9363f70f7aa6d6f533dd9ce5b70d7376fa5f2","modified":1648970620712},{"_id":"public/archives/2021/index.html","hash":"bd9fb1995001e04eb7994ba15bcb33e4e071ae4d","modified":1648970620712},{"_id":"public/archives/2021/12/index.html","hash":"437b339785222db94c4634c005a839daf65d405b","modified":1648970620712},{"_id":"public/page/2/index.html","hash":"f990278ec8135ae6b920f9d54f3356ad4011bb53","modified":1648970620712},{"_id":"themes/purer/src/.DS_Store","hash":"773421aeab2fac5f54a5916250cdc689080dcb5c","modified":1646103189284},{"_id":"themes/purer/source/.DS_Store","hash":"bf32fb57a16784ad16ff2fc164cb07dfd07fd281","modified":1646103179958},{"_id":"themes/purer/source/_data/links.yml","hash":"821b46b0b6bddd3d1716468e9cce56d858949a2e","modified":1646025329762},{"_id":"themes/purer/src/js/.DS_Store","hash":"2d061d21754b5360ff4ed93acf23a62f5fd8eee9","modified":1646100656644},{"_id":"themes/purer/src/js/repository/.DS_Store","hash":"fed41167d717c7c835d465f24b329cc22a4ce9db","modified":1646100656643},{"_id":"themes/purer/src/js/search/.DS_Store","hash":"7cd3b781886aa08a4961f66944bd81a8d96a93ed","modified":1646025067645},{"_id":"source/_data/links.yml","hash":"821b46b0b6bddd3d1716468e9cce56d858949a2e","modified":1646025329762},{"_id":"themes/purer/src/images/avatar.jpg","hash":"5957d7ce7993c0165eeed4a8cc987c86708a7185","modified":1646101175893},{"_id":"themes/purer/src/images/.DS_Store","hash":"73df56c7c140b855d8f367e3882becbe7929daeb","modified":1646102145477},{"_id":"themes/purer/source/images/favicon.ico","hash":"850ee186e01cc9ad7a3de48c13ad7698d7564e1e","modified":1645961400869},{"_id":"public/images/favicon.ico","hash":"850ee186e01cc9ad7a3de48c13ad7698d7564e1e","modified":1646102565249},{"_id":"source/images/favicon.ico","hash":"850ee186e01cc9ad7a3de48c13ad7698d7564e1e","modified":1645961400869},{"_id":"themes/purer/source/images/.DS_Store","hash":"37499e2e79ebf5a877bb1e7ac1fc80bd7c921289","modified":1646104588166},{"_id":"themes/purer/source/images/avatar.jpg","hash":"5957d7ce7993c0165eeed4a8cc987c86708a7185","modified":1646101175893},{"_id":"themes/purer/source/images/favicon.png","hash":"850ee186e01cc9ad7a3de48c13ad7698d7564e1e","modified":1645961400869},{"_id":"public/images/favicon.png","hash":"850ee186e01cc9ad7a3de48c13ad7698d7564e1e","modified":1646104141513},{"_id":"public/images/avatar.jpg","hash":"5957d7ce7993c0165eeed4a8cc987c86708a7185","modified":1646104141513},{"_id":"public/2016/12/28/hello-world/index.html","hash":"eb1f6cf24c0159e201273245ac4969c761dbb44a","modified":1646104655679},{"_id":"public/2017/02/28/项目发布流程/index.html","hash":"f1b869bfdbeb8b368bb58b898b4cc50f0207c1f7","modified":1646104655679},{"_id":"public/archives/2016/index.html","hash":"f82f3ae3ed0fbe9c77e8e49098351b3635deefaf","modified":1648970620712},{"_id":"public/archives/2016/12/index.html","hash":"06e3d94beb205e692328b03b4c936150e45ef84e","modified":1648970620712},{"_id":"public/archives/2017/index.html","hash":"ea632455f82d145721bebf53fa478b8e1ba45f0c","modified":1648970620712},{"_id":"public/archives/2017/02/index.html","hash":"64f9fd0f9077e33fee789974684aa69595a24394","modified":1648970620712},{"_id":"source/_posts/深入解析声明式API（一）：API对象的奥秘.md","hash":"367885c73678950f29d1eae54eb7472d5db5aa35","modified":1646724950576},{"_id":"source/images/.DS_Store","hash":"7b750838b42b15232d49983514790785bbd3fc82","modified":1647064345632},{"_id":"source/images/k8s/.DS_Store","hash":"bc31442c8cea18d00b280dd05ed318eade901993","modified":1646706478014},{"_id":"source/images/k8s/api-server-build.png","hash":"04730e4dadfa55c61306aa16289e3c853cc90a3b","modified":1646707139203},{"_id":"source/images/k8s/k8s-api-tree.png","hash":"d3f600bf47b1b193959e206610de238507b4e099","modified":1646705836248},{"_id":"public/2022/03/08/深入解析声明式API（一）：API对象的奥秘/index.html","hash":"2f72a48e417d92c2ee3853b5c018f6f3855b5a25","modified":1646724965926},{"_id":"public/archives/2022/03/index.html","hash":"e5e3c743a0a5bdaec7724e115f61fdea818d7499","modified":1648970620712},{"_id":"public/images/k8s/api-server-build.png","hash":"04730e4dadfa55c61306aa16289e3c853cc90a3b","modified":1646724965926},{"_id":"public/images/k8s/k8s-api-tree.png","hash":"d3f600bf47b1b193959e206610de238507b4e099","modified":1646724965926},{"_id":"source/_posts/k8s心得.md","hash":"db1dc10db43d10329e0c760f1cf52a630f326429","modified":1648970598282},{"_id":"public/2018/10/22/k8s心得/index.html","hash":"1c4ae0d0b133a3cd1d4182193b96a1acbc29efb4","modified":1648970620712},{"_id":"public/categories/k8s/index.html","hash":"0a540aae9706df19b0f2d51884a7be456a72568d","modified":1648970620712},{"_id":"public/archives/2018/10/index.html","hash":"3b551ce0bb3796eec62d90bf71e61e824875519e","modified":1648970620712}],"Category":[{"name":"k8s","_id":"cl063u5bh00018rrbclkib2lw"},{"name":"云原生","_id":"cl063uleq00058rrb5z97hix9"},{"name":"k8s","parent":"cl063uleq00058rrb5z97hix9","_id":"cl063wtdp0000asrb6en1cfqi"},{"name":"middleware","_id":"cl064wjvq0002lcrbcmk54q8e"},{"name":"java","_id":"cl064wjvt0006lcrbd9x3bdvo"},{"name":"network","_id":"cl064wjvv000blcrb2x7d87pw"},{"name":"jvm","_id":"cl064wjw3000klcrbc9g72swh"},{"name":"db","_id":"cl064wjw8000xlcrb38un5h7x"},{"name":"linux","_id":"cl064wjwc0016lcrb9ksp8amh"},{"name":"linuxProgram","_id":"cl064wjwd0018lcrbcumd2g7z"}],"Data":[{"_id":"links","data":{"马以":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"马以的网站"},"Ant":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"Ant"}}}],"Page":[{"title":"云原生","date":"2022-02-28T02:39:25.000Z","type":"cloudnative","comments":1,"_content":"","source":"云原生/index.md","raw":"---\ntitle: 云原生\ndate: 2022-02-28 10:39:25\ntype: \"cloudnative\"\ncomments: true\n---\n","updated":"2022-02-28T02:40:50.504Z","path":"云原生/index.html","layout":"page","_id":"cl063hbce000034rbdjdx6fgq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2022-02-28T02:43:34.000Z","layout":"categories","type":"categories","comments":1,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2022-02-28 10:43:34\nlayout: categories\ntype: \"categories\"\ncomments: true\n---\n","updated":"2022-02-28T02:50:00.845Z","path":"categories/index.html","_id":"cl063lu6l000068rbfpsn3g9l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2022-02-28T03:04:09.000Z","layout":"tagcloud","type":"tags","comments":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-02-28 11:04:09\nlayout: tagcloud\ntype: \"tags\"\ncomments: true\n---\n","updated":"2022-02-28T03:23:09.148Z","path":"tags/index.html","_id":"cl064c4420000jfrb7qm779fo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"操作系统","date":"2022-02-28T02:59:32.000Z","layout":"categories","type":"categories","comments":1,"_content":"","source":"操作系统/index.md","raw":"---\ntitle: 操作系统\ndate: 2022-02-28 10:59:32\nlayout: categories\ntype: \"categories\"\ncomments: true\n---\n","updated":"2022-02-28T03:00:17.477Z","path":"操作系统/index.html","_id":"cl064c4450001jfrb40ai13dc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"repository","date":"2022-02-28T03:28:39.000Z","layout":"repository","type":"repository","comments":0,"sidebar":"none","_content":"","source":"repository/index.md","raw":"---\ntitle: repository\ndate: 2022-02-28 11:28:39\nlayout: repository\ntype: \"repository\"\ncomments: false\nsidebar: none\n\n---\n","updated":"2022-02-28T03:46:33.808Z","path":"repository/index.html","_id":"cl0658eov000009rbeghn3ye5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"links","date":"2022-02-28T03:33:28.000Z","layout":"links","type":"links","comments":0,"sidebar":"none","_content":"","source":"links/index.md","raw":"---\ntitle: links\ndate: 2022-02-28 11:33:28\nlayout: links\ntype: \"links\"\ncomments: false\nsidebar: none\n---\n","updated":"2022-02-28T03:34:23.283Z","path":"links/index.html","_id":"cl065dgo600003prbfgngbn27","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2022-02-28T03:37:14.000Z","layout":"about","type":"about","comments":0,"sidebar":"none","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-02-28 11:37:14\nlayout: about\ntype: \"about\"\ncomments: false\nsidebar: none\n---\n","updated":"2022-02-28T03:37:51.965Z","path":"about/index.html","_id":"cl065hxt000006brb64b28v91","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","date":"2016-12-28T02:24:25.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-12-28 10:24:25\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2022-03-01T03:17:20.780Z","_id":"cl057cyly000057rb9gpn1uod","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"links":{"马以":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"马以的网站"},"Ant":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"Ant"}}}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"项目发布流程","date":"2017-02-28T02:24:25.000Z","_content":"\n## 博客发布流程\n\n1. #### 新增 categories 分类页面\n\n   * **新建页面**\n\n     ```bash\n     $ hexo new page k8s\n     ```\n\n   * **配置**\n\n     打开 blog/source/k8s/index.md，默认是下列内容：\n\n     ```markdown\n     ---\n     title: 分类\n     date: 2018-10-22 14:25:08\n     ---\n     ```\n\n     修改为：\n\n     ```markdown\n     ---\n     title: 分类\n     date: 2018-10-22 14:25:08\n     type: \"categories\"\n     comments: false\n     ---\n     ```\n\n   * **新建文章**\n\n     ```bash\n     $ hexo new \"k8s集群搭建\"\n     ```\n\n     打开 blog/source/_posts/k8s集群搭建.md, 默认头部信息如下:\n\n     ```markdown\n     ---\n     title: k8s集群搭建\n     date: 2018-10-22 23:03:42\n     tags:\n     ---\n     ```\n\n     修改为\n\n     ```markdown\n     ---\n     title: k8s集群搭建\n     comments: true\n     date: 2018-10-22 23:03:42\n     updated: 2019-10-22 23:03:42\n     desc: 云服务器k8s集群搭建\n     categories:\n         - k8s\n     tags: [k8s]\n     keywords: k8s, cloudnative\n     ---\n     ## k8s 集群搭建\n     具体的文章内容..........\n     ```\n\n   * **重启服务**\n\n     ```bash\n     # 如果修改了 _config.theme.yml 注意执行 npm run build\n     $ npm run build\n     $ npm run server\n     \n     # 如果未修改过，执行下面命令\n     $ hexo g && hexo s\n     ```\n\n     \n\n### 友链\n\n​\t友链与主题分离，数据存放在[数据文件夹](https://hexo.io/docs/data-files)的`links.yml`中\n​\t例子:\n\n```yaml\n# links\n马以:\n  link: https://www.ant.top\n  avatar: https://www.ant.top/images/avatar.jpg\n  desc: 马以\n\nAnt:\n  link: https://www.ant.top\n  avatar: https://www.ant.top/images/avatar.jpg\n  desc: Ant\n```\n\n\n\n### 本地搜索\n需要安装`hexo-generator-json-content`\n\n```bash\n$ npm i -S hexo-generator-json-content\n```\n\n\n\n\n### 主题配置\n* **menu**\n\n  是否显示左侧 header 中的菜单，如果不需要可以注释掉。\n\n* **menu_icons**\n\n  `enable`左侧菜单是否显示图标，如不需要可以设置成`false`\n  其他配置项的值为`iconfont`的`class`。一般不需要更改，如果你需要新增图标可以提 [Issue](https://github.com/fengkx/hexo-theme-purer/issues) 或者更改图标可以更改主题的`src/css/iconfont.css`。图标来自阿里的 [iconfont.cn](https://iconfont.cn/)。\n\n* **site**\n\n  **favicon**\n\n  站点 favicon，相对`source`或主题根目录下的`source`\n  例如`/images.fvicon.ico`相当于在`source/images/favicon.ico`中找。\n\n  **site_verfication**\n\n  Google 或 Baidu 提供的 HTML meta 验证。形如\n\n  ```html\n  <meta name=\"google-site-verification\" content=\"your verification string\">\n  ```\n\n  将 content 里的内容粘贴到对应的属性中。\n\n  **google_analytics**\n\n  在 Google Analytics 找到跟踪 ID(一般是以 UA- 开头)填入。留空不启用。\n\n* **pagination**\n\n  prev， next 是否总是显示，默认为 `true`。仅当多于一页时有效。\n\n* **comment**\n\n  **type**\n\n  选择启用哪一种评论系统。留空则不启用。\n  你可以通过`front-matter`的`comment: boolean`控制具体一篇 post 是否开启评论。默认开启。\n\n* **github**\n\n  **username**\n\n  GitHub username\n\n* **postCount**\n\n  **enable**\n\n  是否启用。需要安装相关的插件\n\n  ```bash\n  $ npm i --save hexo-wordcount\n  ```\n\n  **wordocunt**\n\n  是否显示文章字数统计\n\n  **min2read**\n\n  是否显示阅读时长预计\n\n* **toc**\n\n  TOC 全局开关\n  你可以通过`front-matter`的`toc: boolean`控制是否具体一篇 post 是否开启 toc。默认开启。\n\n* **fancybox**\n\n  是否开启基于[LightGallery](https://sachinchoolur.github.io/lightgallery.js/)图片 FancyBox 效果。默认开启。\n\n* **license**\n\n  Copyright 显示的 HTML 片段。注释掉则不显示Copyright\n\n* **footer**\n\n  **custom**\n\n  自定义 Footer 的 HTML 片段。注释掉则不显示。\n\n  具体例子可参考 [Demo](https://purer.netlify.com/)\n  Demo 源文件 [Source](https://github.com/fengkx/purer-theme-demo)\n\n* **profile**\n\n  **enable**\n\n  是否显示 profile\n  效果可以参考 [Demo](https://purer.netlify.com/)\n  Demo 源文件 [Source](https://github.com/fengkx/purer-theme-demo)\n\n  **social**\n\n  * **links**\n\n    Footer 显示的社交联系图标和链接。如需要添加图标可以提 [Issue](https://github.com/fengkx/hexo-theme-purer/issues)\n\n* **links**\n\n  About 页面侧栏显示的链接\n\n* **labels**\n\n  About 页面侧栏显示的 Labels\n\n* **skills**\n\n  About 页面侧栏显示的 Skills\n\n* **works**\n\n  About 页面侧栏显示的个人项目\n\n* **widgets**\n\n  侧栏显示的 widget， 注释则关闭。\n\n* **show_count**\n\n  侧栏的 tag， archive，category widget 中是否显示文章数量\n\n* **cdn**\n\n  用到的 CDN 地址，如果你不知道是什么就不要改动。","source":"_posts/项目发布流程.md","raw":"---\ntitle: 项目发布流程\ndate: 2017-02-28 10:24:25\ntags:\n---\n\n## 博客发布流程\n\n1. #### 新增 categories 分类页面\n\n   * **新建页面**\n\n     ```bash\n     $ hexo new page k8s\n     ```\n\n   * **配置**\n\n     打开 blog/source/k8s/index.md，默认是下列内容：\n\n     ```markdown\n     ---\n     title: 分类\n     date: 2018-10-22 14:25:08\n     ---\n     ```\n\n     修改为：\n\n     ```markdown\n     ---\n     title: 分类\n     date: 2018-10-22 14:25:08\n     type: \"categories\"\n     comments: false\n     ---\n     ```\n\n   * **新建文章**\n\n     ```bash\n     $ hexo new \"k8s集群搭建\"\n     ```\n\n     打开 blog/source/_posts/k8s集群搭建.md, 默认头部信息如下:\n\n     ```markdown\n     ---\n     title: k8s集群搭建\n     date: 2018-10-22 23:03:42\n     tags:\n     ---\n     ```\n\n     修改为\n\n     ```markdown\n     ---\n     title: k8s集群搭建\n     comments: true\n     date: 2018-10-22 23:03:42\n     updated: 2019-10-22 23:03:42\n     desc: 云服务器k8s集群搭建\n     categories:\n         - k8s\n     tags: [k8s]\n     keywords: k8s, cloudnative\n     ---\n     ## k8s 集群搭建\n     具体的文章内容..........\n     ```\n\n   * **重启服务**\n\n     ```bash\n     # 如果修改了 _config.theme.yml 注意执行 npm run build\n     $ npm run build\n     $ npm run server\n     \n     # 如果未修改过，执行下面命令\n     $ hexo g && hexo s\n     ```\n\n     \n\n### 友链\n\n​\t友链与主题分离，数据存放在[数据文件夹](https://hexo.io/docs/data-files)的`links.yml`中\n​\t例子:\n\n```yaml\n# links\n马以:\n  link: https://www.ant.top\n  avatar: https://www.ant.top/images/avatar.jpg\n  desc: 马以\n\nAnt:\n  link: https://www.ant.top\n  avatar: https://www.ant.top/images/avatar.jpg\n  desc: Ant\n```\n\n\n\n### 本地搜索\n需要安装`hexo-generator-json-content`\n\n```bash\n$ npm i -S hexo-generator-json-content\n```\n\n\n\n\n### 主题配置\n* **menu**\n\n  是否显示左侧 header 中的菜单，如果不需要可以注释掉。\n\n* **menu_icons**\n\n  `enable`左侧菜单是否显示图标，如不需要可以设置成`false`\n  其他配置项的值为`iconfont`的`class`。一般不需要更改，如果你需要新增图标可以提 [Issue](https://github.com/fengkx/hexo-theme-purer/issues) 或者更改图标可以更改主题的`src/css/iconfont.css`。图标来自阿里的 [iconfont.cn](https://iconfont.cn/)。\n\n* **site**\n\n  **favicon**\n\n  站点 favicon，相对`source`或主题根目录下的`source`\n  例如`/images.fvicon.ico`相当于在`source/images/favicon.ico`中找。\n\n  **site_verfication**\n\n  Google 或 Baidu 提供的 HTML meta 验证。形如\n\n  ```html\n  <meta name=\"google-site-verification\" content=\"your verification string\">\n  ```\n\n  将 content 里的内容粘贴到对应的属性中。\n\n  **google_analytics**\n\n  在 Google Analytics 找到跟踪 ID(一般是以 UA- 开头)填入。留空不启用。\n\n* **pagination**\n\n  prev， next 是否总是显示，默认为 `true`。仅当多于一页时有效。\n\n* **comment**\n\n  **type**\n\n  选择启用哪一种评论系统。留空则不启用。\n  你可以通过`front-matter`的`comment: boolean`控制具体一篇 post 是否开启评论。默认开启。\n\n* **github**\n\n  **username**\n\n  GitHub username\n\n* **postCount**\n\n  **enable**\n\n  是否启用。需要安装相关的插件\n\n  ```bash\n  $ npm i --save hexo-wordcount\n  ```\n\n  **wordocunt**\n\n  是否显示文章字数统计\n\n  **min2read**\n\n  是否显示阅读时长预计\n\n* **toc**\n\n  TOC 全局开关\n  你可以通过`front-matter`的`toc: boolean`控制是否具体一篇 post 是否开启 toc。默认开启。\n\n* **fancybox**\n\n  是否开启基于[LightGallery](https://sachinchoolur.github.io/lightgallery.js/)图片 FancyBox 效果。默认开启。\n\n* **license**\n\n  Copyright 显示的 HTML 片段。注释掉则不显示Copyright\n\n* **footer**\n\n  **custom**\n\n  自定义 Footer 的 HTML 片段。注释掉则不显示。\n\n  具体例子可参考 [Demo](https://purer.netlify.com/)\n  Demo 源文件 [Source](https://github.com/fengkx/purer-theme-demo)\n\n* **profile**\n\n  **enable**\n\n  是否显示 profile\n  效果可以参考 [Demo](https://purer.netlify.com/)\n  Demo 源文件 [Source](https://github.com/fengkx/purer-theme-demo)\n\n  **social**\n\n  * **links**\n\n    Footer 显示的社交联系图标和链接。如需要添加图标可以提 [Issue](https://github.com/fengkx/hexo-theme-purer/issues)\n\n* **links**\n\n  About 页面侧栏显示的链接\n\n* **labels**\n\n  About 页面侧栏显示的 Labels\n\n* **skills**\n\n  About 页面侧栏显示的 Skills\n\n* **works**\n\n  About 页面侧栏显示的个人项目\n\n* **widgets**\n\n  侧栏显示的 widget， 注释则关闭。\n\n* **show_count**\n\n  侧栏的 tag， archive，category widget 中是否显示文章数量\n\n* **cdn**\n\n  用到的 CDN 地址，如果你不知道是什么就不要改动。","slug":"项目发布流程","published":1,"updated":"2022-03-01T03:16:40.033Z","_id":"cl0633a4h0000v8rbdfoq0c39","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"博客发布流程\"><a href=\"#博客发布流程\" class=\"headerlink\" title=\"博客发布流程\"></a>博客发布流程</h2><ol>\n<li><h4 id=\"新增-categories-分类页面\"><a href=\"#新增-categories-分类页面\" class=\"headerlink\" title=\"新增 categories 分类页面\"></a>新增 categories 分类页面</h4><ul>\n<li><p><strong>新建页面</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page k8s</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>配置</strong></p>\n<p>打开 blog/source/k8s/index.md，默认是下列内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\"><span class=\"section\">date: 2018-10-22 14:25:08</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>修改为：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2018-10-22 14:25:08</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\"><span class=\"section\">comments: false</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>新建文章</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;k8s集群搭建&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>打开 blog/source/_posts/k8s集群搭建.md, 默认头部信息如下:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: k8s集群搭建</span><br><span class=\"line\">date: 2018-10-22 23:03:42</span><br><span class=\"line\"><span class=\"section\">tags:</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>修改为</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: k8s集群搭建</span><br><span class=\"line\">comments: true</span><br><span class=\"line\">date: 2018-10-22 23:03:42</span><br><span class=\"line\">updated: 2019-10-22 23:03:42</span><br><span class=\"line\">desc: 云服务器k8s集群搭建</span><br><span class=\"line\">categories:</span><br><span class=\"line\"><span class=\"bullet\">    -</span> k8s</span><br><span class=\"line\">tags: [k8s]</span><br><span class=\"line\"><span class=\"section\">keywords: k8s, cloudnative</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"><span class=\"section\">## k8s 集群搭建</span></span><br><span class=\"line\">具体的文章内容..........</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>重启服务</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果修改了 _config.theme.yml 注意执行 npm run build</span></span><br><span class=\"line\">$ npm run build</span><br><span class=\"line\">$ npm run server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果未修改过，执行下面命令</span></span><br><span class=\"line\">$ hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"友链\"><a href=\"#友链\" class=\"headerlink\" title=\"友链\"></a>友链</h3><p>​    友链与主题分离，数据存放在<a href=\"https://hexo.io/docs/data-files\">数据文件夹</a>的<code>links.yml</code>中<br>​    例子:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># links</span></span><br><span class=\"line\"><span class=\"string\">马以:</span></span><br><span class=\"line\">  <span class=\"attr\">link:</span> <span class=\"string\">https://www.ant.top</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">https://www.ant.top/images/avatar.jpg</span></span><br><span class=\"line\">  <span class=\"attr\">desc:</span> <span class=\"string\">马以</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Ant:</span></span><br><span class=\"line\">  <span class=\"attr\">link:</span> <span class=\"string\">https://www.ant.top</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">https://www.ant.top/images/avatar.jpg</span></span><br><span class=\"line\">  <span class=\"attr\">desc:</span> <span class=\"string\">Ant</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"本地搜索\"><a href=\"#本地搜索\" class=\"headerlink\" title=\"本地搜索\"></a>本地搜索</h3><p>需要安装<code>hexo-generator-json-content</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -S hexo-generator-json-content</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h3><ul>\n<li><p><strong>menu</strong></p>\n<p>是否显示左侧 header 中的菜单，如果不需要可以注释掉。</p>\n</li>\n<li><p><strong>menu_icons</strong></p>\n<p><code>enable</code>左侧菜单是否显示图标，如不需要可以设置成<code>false</code><br>其他配置项的值为<code>iconfont</code>的<code>class</code>。一般不需要更改，如果你需要新增图标可以提 <a href=\"https://github.com/fengkx/hexo-theme-purer/issues\">Issue</a> 或者更改图标可以更改主题的<code>src/css/iconfont.css</code>。图标来自阿里的 <a href=\"https://iconfont.cn/\">iconfont.cn</a>。</p>\n</li>\n<li><p><strong>site</strong></p>\n<p><strong>favicon</strong></p>\n<p>站点 favicon，相对<code>source</code>或主题根目录下的<code>source</code><br>例如<code>/images.fvicon.ico</code>相当于在<code>source/images/favicon.ico</code>中找。</p>\n<p><strong>site_verfication</strong></p>\n<p>Google 或 Baidu 提供的 HTML meta 验证。形如</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;google-site-verification&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;your verification string&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将 content 里的内容粘贴到对应的属性中。</p>\n<p><strong>google_analytics</strong></p>\n<p>在 Google Analytics 找到跟踪 ID(一般是以 UA- 开头)填入。留空不启用。</p>\n</li>\n<li><p><strong>pagination</strong></p>\n<p>prev， next 是否总是显示，默认为 <code>true</code>。仅当多于一页时有效。</p>\n</li>\n<li><p><strong>comment</strong></p>\n<p><strong>type</strong></p>\n<p>选择启用哪一种评论系统。留空则不启用。<br>你可以通过<code>front-matter</code>的<code>comment: boolean</code>控制具体一篇 post 是否开启评论。默认开启。</p>\n</li>\n<li><p><strong>github</strong></p>\n<p><strong>username</strong></p>\n<p>GitHub username</p>\n</li>\n<li><p><strong>postCount</strong></p>\n<p><strong>enable</strong></p>\n<p>是否启用。需要安装相关的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure>\n\n<p><strong>wordocunt</strong></p>\n<p>是否显示文章字数统计</p>\n<p><strong>min2read</strong></p>\n<p>是否显示阅读时长预计</p>\n</li>\n<li><p><strong>toc</strong></p>\n<p>TOC 全局开关<br>你可以通过<code>front-matter</code>的<code>toc: boolean</code>控制是否具体一篇 post 是否开启 toc。默认开启。</p>\n</li>\n<li><p><strong>fancybox</strong></p>\n<p>是否开启基于<a href=\"https://sachinchoolur.github.io/lightgallery.js/\">LightGallery</a>图片 FancyBox 效果。默认开启。</p>\n</li>\n<li><p><strong>license</strong></p>\n<p>Copyright 显示的 HTML 片段。注释掉则不显示Copyright</p>\n</li>\n<li><p><strong>footer</strong></p>\n<p><strong>custom</strong></p>\n<p>自定义 Footer 的 HTML 片段。注释掉则不显示。</p>\n<p>具体例子可参考 <a href=\"https://purer.netlify.com/\">Demo</a><br>Demo 源文件 <a href=\"https://github.com/fengkx/purer-theme-demo\">Source</a></p>\n</li>\n<li><p><strong>profile</strong></p>\n<p><strong>enable</strong></p>\n<p>是否显示 profile<br>效果可以参考 <a href=\"https://purer.netlify.com/\">Demo</a><br>Demo 源文件 <a href=\"https://github.com/fengkx/purer-theme-demo\">Source</a></p>\n<p><strong>social</strong></p>\n<ul>\n<li><p><strong>links</strong></p>\n<p>Footer 显示的社交联系图标和链接。如需要添加图标可以提 <a href=\"https://github.com/fengkx/hexo-theme-purer/issues\">Issue</a></p>\n</li>\n</ul>\n</li>\n<li><p><strong>links</strong></p>\n<p>About 页面侧栏显示的链接</p>\n</li>\n<li><p><strong>labels</strong></p>\n<p>About 页面侧栏显示的 Labels</p>\n</li>\n<li><p><strong>skills</strong></p>\n<p>About 页面侧栏显示的 Skills</p>\n</li>\n<li><p><strong>works</strong></p>\n<p>About 页面侧栏显示的个人项目</p>\n</li>\n<li><p><strong>widgets</strong></p>\n<p>侧栏显示的 widget， 注释则关闭。</p>\n</li>\n<li><p><strong>show_count</strong></p>\n<p>侧栏的 tag， archive，category widget 中是否显示文章数量</p>\n</li>\n<li><p><strong>cdn</strong></p>\n<p>用到的 CDN 地址，如果你不知道是什么就不要改动。</p>\n</li>\n</ul>\n","site":{"data":{"links":{"马以":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"马以的网站"},"Ant":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"Ant"}}}},"excerpt":"","more":"<h2 id=\"博客发布流程\"><a href=\"#博客发布流程\" class=\"headerlink\" title=\"博客发布流程\"></a>博客发布流程</h2><ol>\n<li><h4 id=\"新增-categories-分类页面\"><a href=\"#新增-categories-分类页面\" class=\"headerlink\" title=\"新增 categories 分类页面\"></a>新增 categories 分类页面</h4><ul>\n<li><p><strong>新建页面</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page k8s</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>配置</strong></p>\n<p>打开 blog/source/k8s/index.md，默认是下列内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\"><span class=\"section\">date: 2018-10-22 14:25:08</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>修改为：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2018-10-22 14:25:08</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\"><span class=\"section\">comments: false</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>新建文章</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;k8s集群搭建&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>打开 blog/source/_posts/k8s集群搭建.md, 默认头部信息如下:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: k8s集群搭建</span><br><span class=\"line\">date: 2018-10-22 23:03:42</span><br><span class=\"line\"><span class=\"section\">tags:</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>修改为</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: k8s集群搭建</span><br><span class=\"line\">comments: true</span><br><span class=\"line\">date: 2018-10-22 23:03:42</span><br><span class=\"line\">updated: 2019-10-22 23:03:42</span><br><span class=\"line\">desc: 云服务器k8s集群搭建</span><br><span class=\"line\">categories:</span><br><span class=\"line\"><span class=\"bullet\">    -</span> k8s</span><br><span class=\"line\">tags: [k8s]</span><br><span class=\"line\"><span class=\"section\">keywords: k8s, cloudnative</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"><span class=\"section\">## k8s 集群搭建</span></span><br><span class=\"line\">具体的文章内容..........</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>重启服务</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果修改了 _config.theme.yml 注意执行 npm run build</span></span><br><span class=\"line\">$ npm run build</span><br><span class=\"line\">$ npm run server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果未修改过，执行下面命令</span></span><br><span class=\"line\">$ hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"友链\"><a href=\"#友链\" class=\"headerlink\" title=\"友链\"></a>友链</h3><p>​    友链与主题分离，数据存放在<a href=\"https://hexo.io/docs/data-files\">数据文件夹</a>的<code>links.yml</code>中<br>​    例子:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># links</span></span><br><span class=\"line\"><span class=\"string\">马以:</span></span><br><span class=\"line\">  <span class=\"attr\">link:</span> <span class=\"string\">https://www.ant.top</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">https://www.ant.top/images/avatar.jpg</span></span><br><span class=\"line\">  <span class=\"attr\">desc:</span> <span class=\"string\">马以</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Ant:</span></span><br><span class=\"line\">  <span class=\"attr\">link:</span> <span class=\"string\">https://www.ant.top</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">https://www.ant.top/images/avatar.jpg</span></span><br><span class=\"line\">  <span class=\"attr\">desc:</span> <span class=\"string\">Ant</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"本地搜索\"><a href=\"#本地搜索\" class=\"headerlink\" title=\"本地搜索\"></a>本地搜索</h3><p>需要安装<code>hexo-generator-json-content</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i -S hexo-generator-json-content</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h3><ul>\n<li><p><strong>menu</strong></p>\n<p>是否显示左侧 header 中的菜单，如果不需要可以注释掉。</p>\n</li>\n<li><p><strong>menu_icons</strong></p>\n<p><code>enable</code>左侧菜单是否显示图标，如不需要可以设置成<code>false</code><br>其他配置项的值为<code>iconfont</code>的<code>class</code>。一般不需要更改，如果你需要新增图标可以提 <a href=\"https://github.com/fengkx/hexo-theme-purer/issues\">Issue</a> 或者更改图标可以更改主题的<code>src/css/iconfont.css</code>。图标来自阿里的 <a href=\"https://iconfont.cn/\">iconfont.cn</a>。</p>\n</li>\n<li><p><strong>site</strong></p>\n<p><strong>favicon</strong></p>\n<p>站点 favicon，相对<code>source</code>或主题根目录下的<code>source</code><br>例如<code>/images.fvicon.ico</code>相当于在<code>source/images/favicon.ico</code>中找。</p>\n<p><strong>site_verfication</strong></p>\n<p>Google 或 Baidu 提供的 HTML meta 验证。形如</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;google-site-verification&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;your verification string&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将 content 里的内容粘贴到对应的属性中。</p>\n<p><strong>google_analytics</strong></p>\n<p>在 Google Analytics 找到跟踪 ID(一般是以 UA- 开头)填入。留空不启用。</p>\n</li>\n<li><p><strong>pagination</strong></p>\n<p>prev， next 是否总是显示，默认为 <code>true</code>。仅当多于一页时有效。</p>\n</li>\n<li><p><strong>comment</strong></p>\n<p><strong>type</strong></p>\n<p>选择启用哪一种评论系统。留空则不启用。<br>你可以通过<code>front-matter</code>的<code>comment: boolean</code>控制具体一篇 post 是否开启评论。默认开启。</p>\n</li>\n<li><p><strong>github</strong></p>\n<p><strong>username</strong></p>\n<p>GitHub username</p>\n</li>\n<li><p><strong>postCount</strong></p>\n<p><strong>enable</strong></p>\n<p>是否启用。需要安装相关的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure>\n\n<p><strong>wordocunt</strong></p>\n<p>是否显示文章字数统计</p>\n<p><strong>min2read</strong></p>\n<p>是否显示阅读时长预计</p>\n</li>\n<li><p><strong>toc</strong></p>\n<p>TOC 全局开关<br>你可以通过<code>front-matter</code>的<code>toc: boolean</code>控制是否具体一篇 post 是否开启 toc。默认开启。</p>\n</li>\n<li><p><strong>fancybox</strong></p>\n<p>是否开启基于<a href=\"https://sachinchoolur.github.io/lightgallery.js/\">LightGallery</a>图片 FancyBox 效果。默认开启。</p>\n</li>\n<li><p><strong>license</strong></p>\n<p>Copyright 显示的 HTML 片段。注释掉则不显示Copyright</p>\n</li>\n<li><p><strong>footer</strong></p>\n<p><strong>custom</strong></p>\n<p>自定义 Footer 的 HTML 片段。注释掉则不显示。</p>\n<p>具体例子可参考 <a href=\"https://purer.netlify.com/\">Demo</a><br>Demo 源文件 <a href=\"https://github.com/fengkx/purer-theme-demo\">Source</a></p>\n</li>\n<li><p><strong>profile</strong></p>\n<p><strong>enable</strong></p>\n<p>是否显示 profile<br>效果可以参考 <a href=\"https://purer.netlify.com/\">Demo</a><br>Demo 源文件 <a href=\"https://github.com/fengkx/purer-theme-demo\">Source</a></p>\n<p><strong>social</strong></p>\n<ul>\n<li><p><strong>links</strong></p>\n<p>Footer 显示的社交联系图标和链接。如需要添加图标可以提 <a href=\"https://github.com/fengkx/hexo-theme-purer/issues\">Issue</a></p>\n</li>\n</ul>\n</li>\n<li><p><strong>links</strong></p>\n<p>About 页面侧栏显示的链接</p>\n</li>\n<li><p><strong>labels</strong></p>\n<p>About 页面侧栏显示的 Labels</p>\n</li>\n<li><p><strong>skills</strong></p>\n<p>About 页面侧栏显示的 Skills</p>\n</li>\n<li><p><strong>works</strong></p>\n<p>About 页面侧栏显示的个人项目</p>\n</li>\n<li><p><strong>widgets</strong></p>\n<p>侧栏显示的 widget， 注释则关闭。</p>\n</li>\n<li><p><strong>show_count</strong></p>\n<p>侧栏的 tag， archive，category widget 中是否显示文章数量</p>\n</li>\n<li><p><strong>cdn</strong></p>\n<p>用到的 CDN 地址，如果你不知道是什么就不要改动。</p>\n</li>\n</ul>\n"},{"title":"解决k8s相关组件安装镜像无法拉取","date":"2022-02-18T15:30:26.000Z","_content":"\n### k8s 集群搭建过程相关组件安装\n\n>  在k8s 集群搭建过程中，我们在安装rook存储组件 以及ingress相关组件时，因为要访问https://k8s.gcr.io 去拉取镜像，而在墙内我们时访问不了这个组件的；\n\n所以，我们采用的办法是，从阿里云把相应的镜像版本拉取到本地，然后打tag为官方镜像名称，这样，在拉取镜像的时候就直接从本地拉取，而不用访问https://k8s.gcr.io 去拉取了；\n\n+ rook 镜像\n\n  注意这里的版本要和具体报错的拉取镜像失败的版本一致，相关日志请用命令：\n\n  ```bash\n  $ kubectl describe pod ${pod_name} -n rook-ceph\n  ```\n\n  查看；\n\n  ```bash\n  $ docker pull registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0 k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0 k8s.gcr.io/sig-storage/csi-provisioner:v3.1.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0 k8s.gcr.io/sig-storage/csi-resizer:v1.4.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0 k8s.gcr.io/sig-storage/csi-attacher:v3.4.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0\n  \n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1\n  $ docker tag registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1 k8s.gcr.io/sig-storage/csi-snapshotter:v5.0.1\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1\n  \n  ```\n\n  \n\n+ Ingress 镜像（版本获取同rook）\n\n  ```bash\n  $ docker pull registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0\n  $ docker tag registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0 k8s.gcr.io/ingress-nginx/controller:v1.0.0\n  $ docker rmi registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0\n  $ docker tag registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0 k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0\n  $ docker rmi registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0\n  ```\n\n  \n  \n+ fluentd-elasticsearch\n\n  ```bash\n  # 1.20 版本\n  $ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20\n  $ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20 k8s.gcr.io/fluentd-elasticsearch:1.20\n  $ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20\n  \n  # 2.2.0版本\n  $ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0\n  $ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0 k8s.gcr.io/fluentd-elasticsearch:v2.2.0\n  $ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0\n  ```\n\n  \n\n  \n\n+ <font color=red>注意 :</font> <font color=orange>上面的命令在每个节点都要执行（比如我的环境 k8s-master、k8s-node1、k8s-node2）</font>\n\n  ","source":"_posts/解决k8s相关组件安装镜像无法拉取.md","raw":"---\ntitle: 解决k8s相关组件安装镜像无法拉取\ndate: 2022-02-18 23:30:26\ncategories: \n    - [云原生, k8s]\ntags: [k8s]\n---\n\n### k8s 集群搭建过程相关组件安装\n\n>  在k8s 集群搭建过程中，我们在安装rook存储组件 以及ingress相关组件时，因为要访问https://k8s.gcr.io 去拉取镜像，而在墙内我们时访问不了这个组件的；\n\n所以，我们采用的办法是，从阿里云把相应的镜像版本拉取到本地，然后打tag为官方镜像名称，这样，在拉取镜像的时候就直接从本地拉取，而不用访问https://k8s.gcr.io 去拉取了；\n\n+ rook 镜像\n\n  注意这里的版本要和具体报错的拉取镜像失败的版本一致，相关日志请用命令：\n\n  ```bash\n  $ kubectl describe pod ${pod_name} -n rook-ceph\n  ```\n\n  查看；\n\n  ```bash\n  $ docker pull registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0 k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0 k8s.gcr.io/sig-storage/csi-provisioner:v3.1.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0 k8s.gcr.io/sig-storage/csi-resizer:v1.4.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0\n  $ docker tag registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0 k8s.gcr.io/sig-storage/csi-attacher:v3.4.0\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0\n  \n  \n  $ docker pull registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1\n  $ docker tag registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1 k8s.gcr.io/sig-storage/csi-snapshotter:v5.0.1\n  $ docker rmi registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1\n  \n  ```\n\n  \n\n+ Ingress 镜像（版本获取同rook）\n\n  ```bash\n  $ docker pull registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0\n  $ docker tag registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0 k8s.gcr.io/ingress-nginx/controller:v1.0.0\n  $ docker rmi registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0\n  \n  $ docker pull registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0\n  $ docker tag registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0 k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0\n  $ docker rmi registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0\n  ```\n\n  \n  \n+ fluentd-elasticsearch\n\n  ```bash\n  # 1.20 版本\n  $ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20\n  $ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20 k8s.gcr.io/fluentd-elasticsearch:1.20\n  $ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20\n  \n  # 2.2.0版本\n  $ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0\n  $ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0 k8s.gcr.io/fluentd-elasticsearch:v2.2.0\n  $ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0\n  ```\n\n  \n\n  \n\n+ <font color=red>注意 :</font> <font color=orange>上面的命令在每个节点都要执行（比如我的环境 k8s-master、k8s-node1、k8s-node2）</font>\n\n  ","slug":"解决k8s相关组件安装镜像无法拉取","published":1,"updated":"2022-03-03T10:46:39.850Z","_id":"cl063u5bd00008rrb8ylocx5k","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"k8s-集群搭建过程相关组件安装\"><a href=\"#k8s-集群搭建过程相关组件安装\" class=\"headerlink\" title=\"k8s 集群搭建过程相关组件安装\"></a>k8s 集群搭建过程相关组件安装</h3><blockquote>\n<p> 在k8s 集群搭建过程中，我们在安装rook存储组件 以及ingress相关组件时，因为要访问<a href=\"https://k8s.gcr.io/\">https://k8s.gcr.io</a> 去拉取镜像，而在墙内我们时访问不了这个组件的；</p>\n</blockquote>\n<p>所以，我们采用的办法是，从阿里云把相应的镜像版本拉取到本地，然后打tag为官方镜像名称，这样，在拉取镜像的时候就直接从本地拉取，而不用访问<a href=\"https://k8s.gcr.io/\">https://k8s.gcr.io</a> 去拉取了；</p>\n<ul>\n<li><p>rook 镜像</p>\n<p>注意这里的版本要和具体报错的拉取镜像失败的版本一致，相关日志请用命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe pod <span class=\"variable\">$&#123;pod_name&#125;</span> -n rook-ceph</span><br></pre></td></tr></table></figure>\n\n<p>查看；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0 k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0 k8s.gcr.io/sig-storage/csi-provisioner:v3.1.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0 k8s.gcr.io/sig-storage/csi-resizer:v1.4.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0 k8s.gcr.io/sig-storage/csi-attacher:v3.4.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1 k8s.gcr.io/sig-storage/csi-snapshotter:v5.0.1</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>Ingress 镜像（版本获取同rook）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0 k8s.gcr.io/ingress-nginx/controller:v1.0.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0 k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0</span><br></pre></td></tr></table></figure></li>\n<li><p>fluentd-elasticsearch</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.20 版本</span></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20 k8s.gcr.io/fluentd-elasticsearch:1.20</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2.0版本</span></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0 k8s.gcr.io/fluentd-elasticsearch:v2.2.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0</span><br></pre></td></tr></table></figure></li>\n<li><p><font color=red>注意 :</font> <font color=orange>上面的命令在每个节点都要执行（比如我的环境 k8s-master、k8s-node1、k8s-node2）</font></p>\n</li>\n</ul>\n","site":{"data":{"links":{"马以":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"马以的网站"},"Ant":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"Ant"}}}},"excerpt":"","more":"<h3 id=\"k8s-集群搭建过程相关组件安装\"><a href=\"#k8s-集群搭建过程相关组件安装\" class=\"headerlink\" title=\"k8s 集群搭建过程相关组件安装\"></a>k8s 集群搭建过程相关组件安装</h3><blockquote>\n<p> 在k8s 集群搭建过程中，我们在安装rook存储组件 以及ingress相关组件时，因为要访问<a href=\"https://k8s.gcr.io/\">https://k8s.gcr.io</a> 去拉取镜像，而在墙内我们时访问不了这个组件的；</p>\n</blockquote>\n<p>所以，我们采用的办法是，从阿里云把相应的镜像版本拉取到本地，然后打tag为官方镜像名称，这样，在拉取镜像的时候就直接从本地拉取，而不用访问<a href=\"https://k8s.gcr.io/\">https://k8s.gcr.io</a> 去拉取了；</p>\n<ul>\n<li><p>rook 镜像</p>\n<p>注意这里的版本要和具体报错的拉取镜像失败的版本一致，相关日志请用命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe pod <span class=\"variable\">$&#123;pod_name&#125;</span> -n rook-ceph</span><br></pre></td></tr></table></figure>\n\n<p>查看；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0 k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.5.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0 k8s.gcr.io/sig-storage/csi-provisioner:v3.1.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-provisioner:v3.1.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0 k8s.gcr.io/sig-storage/csi-resizer:v1.4.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-resizer:v1.4.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0 k8s.gcr.io/sig-storage/csi-attacher:v3.4.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-attacher:v3.4.0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1 k8s.gcr.io/sig-storage/csi-snapshotter:v5.0.1</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/csi-snapshotter:v5.0.1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>Ingress 镜像（版本获取同rook）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0 k8s.gcr.io/ingress-nginx/controller:v1.0.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0 k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/kube-webhook-certgen:v1.0</span><br></pre></td></tr></table></figure></li>\n<li><p>fluentd-elasticsearch</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.20 版本</span></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20 k8s.gcr.io/fluentd-elasticsearch:1.20</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:1.20</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2.0版本</span></span><br><span class=\"line\">$ docker pull registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0</span><br><span class=\"line\">$ docker tag registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0 k8s.gcr.io/fluentd-elasticsearch:v2.2.0</span><br><span class=\"line\">$ docker rmi registry.aliyuncs.com/google_containers/fluentd-elasticsearch:v2.2.0</span><br></pre></td></tr></table></figure></li>\n<li><p><font color=red>注意 :</font> <font color=orange>上面的命令在每个节点都要执行（比如我的环境 k8s-master、k8s-node1、k8s-node2）</font></p>\n</li>\n</ul>\n"},{"title":"缓存数据库数据一致性保证演进过程","date":"2021-12-23T11:17:10.000Z","_content":"\n# DTC 解决的业务痛点\n\n---\n\n## 1. 缓存数据库一致性问题\n- ### 传统解决方案\n  1. > **全量数据刷新缓存** \n     > - 数据库的数据,全量刷入缓存（不设置失效时间）。\n     > - 写请求只更新数据库，不更新缓存。\n     > - 启动一个定时任务，定时把数据库的数据，更新到缓存中。\n     \n     <font color=\"green\" ><b>优点:</b></font> \n     - 读请求可以直接命中缓存，不需查库，所以性能高。\n      \n     <font color=\"red\" ><b>缺点:</b></font>  \n      1. 缓存利用率低: 不经常使用的数据还一直留在缓存中，全量数据，耗费缓存空间;\n      2. 数据不一致: 定时刷新缓存，缓存中数据的更新节点完全依赖于定时任务频率和执行效率。\n    \n  2. > **优化缓存利用率低和一致性** \n     > - 写请求只写数据库\n     > - 读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存。\n     > - 同时，写入缓存的数据，都设置失效时间。\n\n     <font color=\"green\" ><b>优点:</b></font>\n      - 缓存中设置了过期时间，这样，缓存中保存的都是热点数据，解决了缓存利用率问题.\n    \n      <font color=\"red\" ><b>缺点:</b></font>\n      - **异常引发数据不一致问题（这里分两种情况讨论）:** \n        \n        ① <font color=\"Coral\" face=\"华文彩云\"><b>「先更新缓存，后更新数据库」</b></font> \n        \n        如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库是<font color=\"Maroon\">「旧值」</font>。\n   \n        虽然此时读请求可以命中缓存，拿到正确的值，但是一旦<font color=\"Maroon\">「缓存失效」</font>。 \\\n        就会从数据库中读取<font color=\"Maroon\">「旧值」</font>， 这时更新进缓存的也是这个旧值。\n        \n        这时，用户就会发现之前修改过的数据，突然又<font color=\"Maroon\">「变回去」</font>了。\n        \n        ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font> \n        \n        数据库更新成功，写缓存失败，那么数据库是最新值，缓存中是<font color=\"Maroon\">「旧值」</font>。\n        \n        这时用户从缓存中读到的全是旧数据，直到<font color=\"Maroon\">「缓存失效」</font>后，读数据库才能读到最新的值。\n   \n        这时用户发现，自己修改的值，迟迟不能生效。\n        \n      - **并发引发数据不一致问题:** \n        \n        ① <font color=\"Coral\" face=\"华文彩云\"><b> 「先更新缓存，后更新数据库」</b></font>\n          \n          接下来我们看，即使数据库和缓存都更新成功，会不会就没什么问题了？\n          \n          假设现在又线程 A 和线程 B 两个线程，需要更新<font color=\"Maroon\">「同一条」</font>数据，时序如下:\n          ```text\n          T1): 线程 A 更新数据库 (X = 1) \n          T2): 线程 B 更新数据库 (X = 2) \n          T3): 线程 B 更新缓存 (X = 2) \n          T4): 线程 A 更新缓存 (X = 1) \n          ```\n          最后结果：缓存中（X=1） 数据库（X=2），从而造成数据不一致。\n   \n        ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font>\n        \n           同 ① ，这里不在详述。\n      - **缓存利用率低** \n        \n        因为该方案是每次数据库发生变更，都会去写缓存，但是缓存中的数据很多都不会被访问到，留在内存中耗费资源。\n  3. > **旁路缓存策略方案**  \n     > - 读请求先读缓存，缓存不命中，再读库\n     > - 写请求做两个动作：写数据库+删除数据缓存\n\n     <font color=\"red\" ><b>缺点:</b></font>\n     - **异常引发数据不一致问题（这里分两种情况讨论）:** \n     \n         这里的场景和 ii.中的异常场景相同，两步中只要有其中一步发生失败，就会引发数据不一致。\n     \n     - **并发引发数据不一致问题:**\n\n         ① <font color=\"Coral\" face=\"华文彩云\"><b>「先删除缓存，后更新数据库」</b></font> \n     \n         如果有 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据，可能会发生以下场景:\n         ```text\n         T1): 线程 A 要更新 X = 2 (原值 X = 1)\n     \n         T2): 线程 A 删除缓存\n     \n         T3): 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）\n     \n         T4): 线程 A 将新值写入数据库 (X = 2)\n     \n         T5): 线程 B 将旧值写入缓存 (X = 1)\n     \n         T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 发生不一致。\n         ```\n         可见，先删除缓存，再更新数据库，当发生<font color=\"Maroon\">「读+写」</font> 并发时，存在数据不一致的情况。\n     \n         ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font>\n\n         依旧是 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据。\n        ```text\n         T1): 缓存中 X 不存在（数据库 X = 1）\n\n         T2): 线程 A 读取数据库，得到旧值 (X = 1)\n\n         T3): 线程 B 更新数据库（X = 2）\n\n         T4): 线程 B 删除缓存\n\n         T5): 线程 A 将旧值写入缓存 (X = 1)\n\n         T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 也发生不一致。\n         ```\n         \n         其实这个方案就是算是<font color=\"Maroon\">「旁路缓存」</font>策略的实现方案；\n       \n         仔细思考以下，这种情况理论来说是可能发生的，但实际上发生的概率是<font color=\"Maroon\">「极低」</font>的。\n   \n         因为它必须满足 3 个条件:\n         ```text\n         1-: 缓存刚好失效\n       \n         2-: 读请求 + 写请求并发\n       \n         3-: 更新数据库 + 删除缓存的时间(T3+T4) > 读数据库 + 写缓存时间 (T2 + T5) \n         ```\n         <font color=\"SeaGreen\"><b>因为写数据库通常有加锁操作，所以写数据库通常要比读数据库的时间要长，所以，条件3发生的概率极低。\n         这个策略也是我用在<font color=\"Maroon\">「成长值账户」</font>中的缓存策略；</b></font>\n       \n         <p>\n         ________________________________________________________________________________________________________________________\n         <font color=\"Maroon\">前面说过异常情况，无论是更新缓存还是删除缓存，只要第二步发生失败，就会导致数据库和缓存不一致。</font> \n       \n         那么这里我们再回过头来讨论下<font color=\"Maroon\">「旁路缓存策略」</font> - <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font> 策略异常情况下，我们如何保证第二步执行成功？\n         \n         </p>\n   \n     - **<font color=\"Maroon\">重试</font>** \n       \n       ```text\n            如果更新数据库成功，删除缓存失败，这里我们就可以无脑的在业务代码中，一直尝试删除缓存；\n            但是这种方案往往存在以下问题：\n            1-: 失败后立即重试，大概率还会「失败」（网络抖动，或者服务异常）;\n            2-: 「重试次数」我们要设置多少才是合理值？\n            3-: 重试会一直「占用」线程资源，无法服务其它请求。\n          ```\n       基于以上结论，我们发现这种<font color=\"Maroon\">「同步重试」</font>方式往往不能解决根本问题。\n       \n     - **<font color=\"Maroon\">异步重试</font>** \n\n       ```text\n            异步重试步骤：\n            1-: 更新数据库后，发消息到消息队列。\n            2-: 消费者消费队列消息。\n            3-: 删除对应的缓存信息。\n       ```\n       这个方案除了需要维护一个重的「消息队列」服务外，看似好像是无懈可击的方案，但是该方案也有一个致命的漏洞，\n       那就是，数据库主从延迟，基于前面我们讨论的并发情况，写数据库往往是操作主库，查库往往是操作从库，所以，\n       会存在，主库处理玩，然后缓存清理后，从库还是旧数据的情况，那么用户从从库中读取旧数据，更新到缓存中时，还是\n       会出现数据不一致的情况。\n       \n       基于以上总总方案，所以我们引入最终的解决方案:\n     - **<font color=\"Maroon\">订阅数据库变更日志，再操作缓存</font>** \n       \n       引入binlog 监控组件 canal 监控binlog变更日志。\n       \n       <font color=\"green\" ><b>优点:</b></font>\n       \n       - 业务只操作数据，无需考虑缓存以及其它相关业务是失败情况，只要写库成功，就会有binlog，\n         余下的工作旧交由下游业务处理，使得业务更加轻量化和简洁化。\n       - canal 不作为master的slave，而是作为一个slave的slave，规避主从延迟造成的数据不一致。\n       - 利用binlog 本身的有序性，完全避免并发中的数据不一致问题。\n\n## 2. 数据变更业务埋点\n  - ### 券变更通知用户业务\n    1. > **传统做法**\n       > - 在每一个涉及券变动的业务中设置业务埋点\n       > - 动态的更新缓存\n\n      <font color=\"red\" ><b>缺点:</b></font>\n       1. 极大的增加业务代码的复杂度。\n       2. 极大的增加业务出错概率。\n       3. 缓存不一致问题。\n     \n      <font color=\"Green\" ><b>解决方案: canal + kafka</b></font> \n       1. 出错率低\n       2. kafka 持久化，失败重试。\n       3. 和业务主流程解耦。\n\n         \n         \n         \n         \n       \n         \n         \n","source":"_posts/缓存数据库数据一致性保证演进过程.md","raw":"---\ntitle: 缓存数据库数据一致性保证演进过程\ndate: 2021-12-23 19:17:10\ncategories:\n    - middleware\ntags: [middleware]\n---\n\n# DTC 解决的业务痛点\n\n---\n\n## 1. 缓存数据库一致性问题\n- ### 传统解决方案\n  1. > **全量数据刷新缓存** \n     > - 数据库的数据,全量刷入缓存（不设置失效时间）。\n     > - 写请求只更新数据库，不更新缓存。\n     > - 启动一个定时任务，定时把数据库的数据，更新到缓存中。\n     \n     <font color=\"green\" ><b>优点:</b></font> \n     - 读请求可以直接命中缓存，不需查库，所以性能高。\n      \n     <font color=\"red\" ><b>缺点:</b></font>  \n      1. 缓存利用率低: 不经常使用的数据还一直留在缓存中，全量数据，耗费缓存空间;\n      2. 数据不一致: 定时刷新缓存，缓存中数据的更新节点完全依赖于定时任务频率和执行效率。\n    \n  2. > **优化缓存利用率低和一致性** \n     > - 写请求只写数据库\n     > - 读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存。\n     > - 同时，写入缓存的数据，都设置失效时间。\n\n     <font color=\"green\" ><b>优点:</b></font>\n      - 缓存中设置了过期时间，这样，缓存中保存的都是热点数据，解决了缓存利用率问题.\n    \n      <font color=\"red\" ><b>缺点:</b></font>\n      - **异常引发数据不一致问题（这里分两种情况讨论）:** \n        \n        ① <font color=\"Coral\" face=\"华文彩云\"><b>「先更新缓存，后更新数据库」</b></font> \n        \n        如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库是<font color=\"Maroon\">「旧值」</font>。\n   \n        虽然此时读请求可以命中缓存，拿到正确的值，但是一旦<font color=\"Maroon\">「缓存失效」</font>。 \\\n        就会从数据库中读取<font color=\"Maroon\">「旧值」</font>， 这时更新进缓存的也是这个旧值。\n        \n        这时，用户就会发现之前修改过的数据，突然又<font color=\"Maroon\">「变回去」</font>了。\n        \n        ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font> \n        \n        数据库更新成功，写缓存失败，那么数据库是最新值，缓存中是<font color=\"Maroon\">「旧值」</font>。\n        \n        这时用户从缓存中读到的全是旧数据，直到<font color=\"Maroon\">「缓存失效」</font>后，读数据库才能读到最新的值。\n   \n        这时用户发现，自己修改的值，迟迟不能生效。\n        \n      - **并发引发数据不一致问题:** \n        \n        ① <font color=\"Coral\" face=\"华文彩云\"><b> 「先更新缓存，后更新数据库」</b></font>\n          \n          接下来我们看，即使数据库和缓存都更新成功，会不会就没什么问题了？\n          \n          假设现在又线程 A 和线程 B 两个线程，需要更新<font color=\"Maroon\">「同一条」</font>数据，时序如下:\n          ```text\n          T1): 线程 A 更新数据库 (X = 1) \n          T2): 线程 B 更新数据库 (X = 2) \n          T3): 线程 B 更新缓存 (X = 2) \n          T4): 线程 A 更新缓存 (X = 1) \n          ```\n          最后结果：缓存中（X=1） 数据库（X=2），从而造成数据不一致。\n   \n        ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font>\n        \n           同 ① ，这里不在详述。\n      - **缓存利用率低** \n        \n        因为该方案是每次数据库发生变更，都会去写缓存，但是缓存中的数据很多都不会被访问到，留在内存中耗费资源。\n  3. > **旁路缓存策略方案**  \n     > - 读请求先读缓存，缓存不命中，再读库\n     > - 写请求做两个动作：写数据库+删除数据缓存\n\n     <font color=\"red\" ><b>缺点:</b></font>\n     - **异常引发数据不一致问题（这里分两种情况讨论）:** \n     \n         这里的场景和 ii.中的异常场景相同，两步中只要有其中一步发生失败，就会引发数据不一致。\n     \n     - **并发引发数据不一致问题:**\n\n         ① <font color=\"Coral\" face=\"华文彩云\"><b>「先删除缓存，后更新数据库」</b></font> \n     \n         如果有 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据，可能会发生以下场景:\n         ```text\n         T1): 线程 A 要更新 X = 2 (原值 X = 1)\n     \n         T2): 线程 A 删除缓存\n     \n         T3): 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）\n     \n         T4): 线程 A 将新值写入数据库 (X = 2)\n     \n         T5): 线程 B 将旧值写入缓存 (X = 1)\n     \n         T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 发生不一致。\n         ```\n         可见，先删除缓存，再更新数据库，当发生<font color=\"Maroon\">「读+写」</font> 并发时，存在数据不一致的情况。\n     \n         ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font>\n\n         依旧是 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据。\n        ```text\n         T1): 缓存中 X 不存在（数据库 X = 1）\n\n         T2): 线程 A 读取数据库，得到旧值 (X = 1)\n\n         T3): 线程 B 更新数据库（X = 2）\n\n         T4): 线程 B 删除缓存\n\n         T5): 线程 A 将旧值写入缓存 (X = 1)\n\n         T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 也发生不一致。\n         ```\n         \n         其实这个方案就是算是<font color=\"Maroon\">「旁路缓存」</font>策略的实现方案；\n       \n         仔细思考以下，这种情况理论来说是可能发生的，但实际上发生的概率是<font color=\"Maroon\">「极低」</font>的。\n   \n         因为它必须满足 3 个条件:\n         ```text\n         1-: 缓存刚好失效\n       \n         2-: 读请求 + 写请求并发\n       \n         3-: 更新数据库 + 删除缓存的时间(T3+T4) > 读数据库 + 写缓存时间 (T2 + T5) \n         ```\n         <font color=\"SeaGreen\"><b>因为写数据库通常有加锁操作，所以写数据库通常要比读数据库的时间要长，所以，条件3发生的概率极低。\n         这个策略也是我用在<font color=\"Maroon\">「成长值账户」</font>中的缓存策略；</b></font>\n       \n         <p>\n         ________________________________________________________________________________________________________________________\n         <font color=\"Maroon\">前面说过异常情况，无论是更新缓存还是删除缓存，只要第二步发生失败，就会导致数据库和缓存不一致。</font> \n       \n         那么这里我们再回过头来讨论下<font color=\"Maroon\">「旁路缓存策略」</font> - <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font> 策略异常情况下，我们如何保证第二步执行成功？\n         \n         </p>\n   \n     - **<font color=\"Maroon\">重试</font>** \n       \n       ```text\n            如果更新数据库成功，删除缓存失败，这里我们就可以无脑的在业务代码中，一直尝试删除缓存；\n            但是这种方案往往存在以下问题：\n            1-: 失败后立即重试，大概率还会「失败」（网络抖动，或者服务异常）;\n            2-: 「重试次数」我们要设置多少才是合理值？\n            3-: 重试会一直「占用」线程资源，无法服务其它请求。\n          ```\n       基于以上结论，我们发现这种<font color=\"Maroon\">「同步重试」</font>方式往往不能解决根本问题。\n       \n     - **<font color=\"Maroon\">异步重试</font>** \n\n       ```text\n            异步重试步骤：\n            1-: 更新数据库后，发消息到消息队列。\n            2-: 消费者消费队列消息。\n            3-: 删除对应的缓存信息。\n       ```\n       这个方案除了需要维护一个重的「消息队列」服务外，看似好像是无懈可击的方案，但是该方案也有一个致命的漏洞，\n       那就是，数据库主从延迟，基于前面我们讨论的并发情况，写数据库往往是操作主库，查库往往是操作从库，所以，\n       会存在，主库处理玩，然后缓存清理后，从库还是旧数据的情况，那么用户从从库中读取旧数据，更新到缓存中时，还是\n       会出现数据不一致的情况。\n       \n       基于以上总总方案，所以我们引入最终的解决方案:\n     - **<font color=\"Maroon\">订阅数据库变更日志，再操作缓存</font>** \n       \n       引入binlog 监控组件 canal 监控binlog变更日志。\n       \n       <font color=\"green\" ><b>优点:</b></font>\n       \n       - 业务只操作数据，无需考虑缓存以及其它相关业务是失败情况，只要写库成功，就会有binlog，\n         余下的工作旧交由下游业务处理，使得业务更加轻量化和简洁化。\n       - canal 不作为master的slave，而是作为一个slave的slave，规避主从延迟造成的数据不一致。\n       - 利用binlog 本身的有序性，完全避免并发中的数据不一致问题。\n\n## 2. 数据变更业务埋点\n  - ### 券变更通知用户业务\n    1. > **传统做法**\n       > - 在每一个涉及券变动的业务中设置业务埋点\n       > - 动态的更新缓存\n\n      <font color=\"red\" ><b>缺点:</b></font>\n       1. 极大的增加业务代码的复杂度。\n       2. 极大的增加业务出错概率。\n       3. 缓存不一致问题。\n     \n      <font color=\"Green\" ><b>解决方案: canal + kafka</b></font> \n       1. 出错率低\n       2. kafka 持久化，失败重试。\n       3. 和业务主流程解耦。\n\n         \n         \n         \n         \n       \n         \n         \n","slug":"缓存数据库数据一致性保证演进过程","published":1,"updated":"2022-02-27T11:30:00.838Z","_id":"cl064wjvl0000lcrb4qf56lth","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"DTC-解决的业务痛点\"><a href=\"#DTC-解决的业务痛点\" class=\"headerlink\" title=\"DTC 解决的业务痛点\"></a>DTC 解决的业务痛点</h1><hr>\n<h2 id=\"1-缓存数据库一致性问题\"><a href=\"#1-缓存数据库一致性问题\" class=\"headerlink\" title=\"1. 缓存数据库一致性问题\"></a>1. 缓存数据库一致性问题</h2><ul>\n<li><h3 id=\"传统解决方案\"><a href=\"#传统解决方案\" class=\"headerlink\" title=\"传统解决方案\"></a>传统解决方案</h3><ol>\n<li><blockquote>\n<p><strong>全量数据刷新缓存</strong> </p>\n<ul>\n<li>数据库的数据,全量刷入缓存（不设置失效时间）。</li>\n<li>写请求只更新数据库，不更新缓存。</li>\n<li>启动一个定时任务，定时把数据库的数据，更新到缓存中。</li>\n</ul>\n</blockquote>\n<p><font color=\"green\" ><b>优点:</b></font> </p>\n<ul>\n<li>读请求可以直接命中缓存，不需查库，所以性能高。</li>\n</ul>\n<p><font color=\"red\" ><b>缺点:</b></font>  </p>\n<ol>\n<li>缓存利用率低: 不经常使用的数据还一直留在缓存中，全量数据，耗费缓存空间;</li>\n<li>数据不一致: 定时刷新缓存，缓存中数据的更新节点完全依赖于定时任务频率和执行效率。</li>\n</ol>\n</li>\n<li><blockquote>\n<p><strong>优化缓存利用率低和一致性</strong> </p>\n<ul>\n<li>写请求只写数据库</li>\n<li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存。</li>\n<li>同时，写入缓存的数据，都设置失效时间。</li>\n</ul>\n</blockquote>\n<p><font color=\"green\" ><b>优点:</b></font></p>\n<ul>\n<li>缓存中设置了过期时间，这样，缓存中保存的都是热点数据，解决了缓存利用率问题.</li>\n</ul>\n<p> <font color=\"red\" ><b>缺点:</b></font></p>\n<ul>\n<li><p><strong>异常引发数据不一致问题（这里分两种情况讨论）:</strong> </p>\n<p>① <font color=\"Coral\" face=\"华文彩云\"><b>「先更新缓存，后更新数据库」</b></font> </p>\n<p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库是<font color=\"Maroon\">「旧值」</font>。</p>\n<p>虽然此时读请求可以命中缓存，拿到正确的值，但是一旦<font color=\"Maroon\">「缓存失效」</font>。 <br>就会从数据库中读取<font color=\"Maroon\">「旧值」</font>， 这时更新进缓存的也是这个旧值。</p>\n<p>这时，用户就会发现之前修改过的数据，突然又<font color=\"Maroon\">「变回去」</font>了。</p>\n<p>② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font> </p>\n<p>数据库更新成功，写缓存失败，那么数据库是最新值，缓存中是<font color=\"Maroon\">「旧值」</font>。</p>\n<p>这时用户从缓存中读到的全是旧数据，直到<font color=\"Maroon\">「缓存失效」</font>后，读数据库才能读到最新的值。</p>\n<p>这时用户发现，自己修改的值，迟迟不能生效。</p>\n</li>\n<li><p><strong>并发引发数据不一致问题:</strong> </p>\n<p>① <font color=\"Coral\" face=\"华文彩云\"><b> 「先更新缓存，后更新数据库」</b></font></p>\n<p>  接下来我们看，即使数据库和缓存都更新成功，会不会就没什么问题了？</p>\n<p>  假设现在又线程 A 和线程 B 两个线程，需要更新<font color=\"Maroon\">「同一条」</font>数据，时序如下:</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T1): 线程 A 更新数据库 (X = 1) </span><br><span class=\"line\">T2): 线程 B 更新数据库 (X = 2) </span><br><span class=\"line\">T3): 线程 B 更新缓存 (X = 2) </span><br><span class=\"line\">T4): 线程 A 更新缓存 (X = 1) </span><br></pre></td></tr></table></figure>\n<p>  最后结果：缓存中（X=1） 数据库（X=2），从而造成数据不一致。</p>\n<p>② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font></p>\n<p>   同 ① ，这里不在详述。</p>\n</li>\n<li><p><strong>缓存利用率低</strong> </p>\n<p>因为该方案是每次数据库发生变更，都会去写缓存，但是缓存中的数据很多都不会被访问到，留在内存中耗费资源。</p>\n</li>\n</ul>\n</li>\n<li><blockquote>\n<p><strong>旁路缓存策略方案</strong>  </p>\n<ul>\n<li>读请求先读缓存，缓存不命中，再读库</li>\n<li>写请求做两个动作：写数据库+删除数据缓存</li>\n</ul>\n</blockquote>\n<p><font color=\"red\" ><b>缺点:</b></font></p>\n<ul>\n<li><p><strong>异常引发数据不一致问题（这里分两种情况讨论）:</strong> </p>\n<p>  这里的场景和 ii.中的异常场景相同，两步中只要有其中一步发生失败，就会引发数据不一致。</p>\n</li>\n<li><p><strong>并发引发数据不一致问题:</strong></p>\n<p>  ① <font color=\"Coral\" face=\"华文彩云\"><b>「先删除缓存，后更新数据库」</b></font> </p>\n<p>  如果有 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据，可能会发生以下场景:</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T1): 线程 A 要更新 X = 2 (原值 X = 1)</span><br><span class=\"line\">     </span><br><span class=\"line\">T2): 线程 A 删除缓存</span><br><span class=\"line\">     </span><br><span class=\"line\">T3): 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</span><br><span class=\"line\">     </span><br><span class=\"line\">T4): 线程 A 将新值写入数据库 (X = 2)</span><br><span class=\"line\">     </span><br><span class=\"line\">T5): 线程 B 将旧值写入缓存 (X = 1)</span><br><span class=\"line\">     </span><br><span class=\"line\">T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 发生不一致。</span><br></pre></td></tr></table></figure>\n<p>  可见，先删除缓存，再更新数据库，当发生<font color=\"Maroon\">「读+写」</font> 并发时，存在数据不一致的情况。</p>\n<p>  ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font></p>\n<p>  依旧是 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据。</p>\n <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T1): 缓存中 X 不存在（数据库 X = 1）</span><br><span class=\"line\"></span><br><span class=\"line\">T2): 线程 A 读取数据库，得到旧值 (X = 1)</span><br><span class=\"line\"></span><br><span class=\"line\">T3): 线程 B 更新数据库（X = 2）</span><br><span class=\"line\"></span><br><span class=\"line\">T4): 线程 B 删除缓存</span><br><span class=\"line\"></span><br><span class=\"line\">T5): 线程 A 将旧值写入缓存 (X = 1)</span><br><span class=\"line\"></span><br><span class=\"line\">T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 也发生不一致。</span><br></pre></td></tr></table></figure>\n<p>  其实这个方案就是算是<font color=\"Maroon\">「旁路缓存」</font>策略的实现方案；</p>\n<p>  仔细思考以下，这种情况理论来说是可能发生的，但实际上发生的概率是<font color=\"Maroon\">「极低」</font>的。</p>\n<p>  因为它必须满足 3 个条件:</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1-: 缓存刚好失效</span><br><span class=\"line\">       </span><br><span class=\"line\">2-: 读请求 + 写请求并发</span><br><span class=\"line\">       </span><br><span class=\"line\">3-: 更新数据库 + 删除缓存的时间(T3+T4) &gt; 读数据库 + 写缓存时间 (T2 + T5) </span><br></pre></td></tr></table></figure>\n<p>  <font color=\"SeaGreen\"><b>因为写数据库通常有加锁操作，所以写数据库通常要比读数据库的时间要长，所以，条件3发生的概率极低。<br>  这个策略也是我用在<font color=\"Maroon\">「成长值账户」</font>中的缓存策略；</b></font></p>\n  <p>\n  ________________________________________________________________________________________________________________________\n  <font color=\"Maroon\">前面说过异常情况，无论是更新缓存还是删除缓存，只要第二步发生失败，就会导致数据库和缓存不一致。</font> \n\n<p>  那么这里我们再回过头来讨论下<font color=\"Maroon\">「旁路缓存策略」</font> - <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font> 策略异常情况下，我们如何保证第二步执行成功？</p>\n  </p></li>\n<li><p><strong><font color=\"Maroon\">重试</font></strong> </p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果更新数据库成功，删除缓存失败，这里我们就可以无脑的在业务代码中，一直尝试删除缓存；</span><br><span class=\"line\">但是这种方案往往存在以下问题：</span><br><span class=\"line\">1-: 失败后立即重试，大概率还会「失败」（网络抖动，或者服务异常）;</span><br><span class=\"line\">2-: 「重试次数」我们要设置多少才是合理值？</span><br><span class=\"line\">3-: 重试会一直「占用」线程资源，无法服务其它请求。</span><br></pre></td></tr></table></figure>\n<p>基于以上结论，我们发现这种<font color=\"Maroon\">「同步重试」</font>方式往往不能解决根本问题。</p>\n</li>\n<li><p><strong><font color=\"Maroon\">异步重试</font></strong> </p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">异步重试步骤：</span><br><span class=\"line\">1-: 更新数据库后，发消息到消息队列。</span><br><span class=\"line\">2-: 消费者消费队列消息。</span><br><span class=\"line\">3-: 删除对应的缓存信息。</span><br></pre></td></tr></table></figure>\n<p>这个方案除了需要维护一个重的「消息队列」服务外，看似好像是无懈可击的方案，但是该方案也有一个致命的漏洞，<br>那就是，数据库主从延迟，基于前面我们讨论的并发情况，写数据库往往是操作主库，查库往往是操作从库，所以，<br>会存在，主库处理玩，然后缓存清理后，从库还是旧数据的情况，那么用户从从库中读取旧数据，更新到缓存中时，还是<br>会出现数据不一致的情况。</p>\n<p>基于以上总总方案，所以我们引入最终的解决方案:</p>\n</li>\n<li><p><strong><font color=\"Maroon\">订阅数据库变更日志，再操作缓存</font></strong> </p>\n<p>引入binlog 监控组件 canal 监控binlog变更日志。</p>\n<p><font color=\"green\" ><b>优点:</b></font></p>\n<ul>\n<li>业务只操作数据，无需考虑缓存以及其它相关业务是失败情况，只要写库成功，就会有binlog，<br>余下的工作旧交由下游业务处理，使得业务更加轻量化和简洁化。</li>\n<li>canal 不作为master的slave，而是作为一个slave的slave，规避主从延迟造成的数据不一致。</li>\n<li>利用binlog 本身的有序性，完全避免并发中的数据不一致问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-数据变更业务埋点\"><a href=\"#2-数据变更业务埋点\" class=\"headerlink\" title=\"2. 数据变更业务埋点\"></a>2. 数据变更业务埋点</h2><ul>\n<li><h3 id=\"券变更通知用户业务\"><a href=\"#券变更通知用户业务\" class=\"headerlink\" title=\"券变更通知用户业务\"></a>券变更通知用户业务</h3><ol>\n<li><blockquote>\n<p><strong>传统做法</strong></p>\n<ul>\n<li>在每一个涉及券变动的业务中设置业务埋点</li>\n<li>动态的更新缓存</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>  <font color=\"red\" ><b>缺点:</b></font></p>\n<ol>\n<li>极大的增加业务代码的复杂度。</li>\n<li>极大的增加业务出错概率。</li>\n<li>缓存不一致问题。</li>\n</ol>\n<p>  <font color=\"Green\" ><b>解决方案: canal + kafka</b></font> </p>\n<ol>\n<li>出错率低</li>\n<li>kafka 持久化，失败重试。</li>\n<li>和业务主流程解耦。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DTC-解决的业务痛点\"><a href=\"#DTC-解决的业务痛点\" class=\"headerlink\" title=\"DTC 解决的业务痛点\"></a>DTC 解决的业务痛点</h1><hr>\n<h2 id=\"1-缓存数据库一致性问题\"><a href=\"#1-缓存数据库一致性问题\" class=\"headerlink\" title=\"1. 缓存数据库一致性问题\"></a>1. 缓存数据库一致性问题</h2><ul>\n<li><h3 id=\"传统解决方案\"><a href=\"#传统解决方案\" class=\"headerlink\" title=\"传统解决方案\"></a>传统解决方案</h3><ol>\n<li><blockquote>\n<p><strong>全量数据刷新缓存</strong> </p>\n<ul>\n<li>数据库的数据,全量刷入缓存（不设置失效时间）。</li>\n<li>写请求只更新数据库，不更新缓存。</li>\n<li>启动一个定时任务，定时把数据库的数据，更新到缓存中。</li>\n</ul>\n</blockquote>\n<p><font color=\"green\" ><b>优点:</b></font> </p>\n<ul>\n<li>读请求可以直接命中缓存，不需查库，所以性能高。</li>\n</ul>\n<p><font color=\"red\" ><b>缺点:</b></font>  </p>\n<ol>\n<li>缓存利用率低: 不经常使用的数据还一直留在缓存中，全量数据，耗费缓存空间;</li>\n<li>数据不一致: 定时刷新缓存，缓存中数据的更新节点完全依赖于定时任务频率和执行效率。</li>\n</ol>\n</li>\n<li><blockquote>\n<p><strong>优化缓存利用率低和一致性</strong> </p>\n<ul>\n<li>写请求只写数据库</li>\n<li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存。</li>\n<li>同时，写入缓存的数据，都设置失效时间。</li>\n</ul>\n</blockquote>\n<p><font color=\"green\" ><b>优点:</b></font></p>\n<ul>\n<li>缓存中设置了过期时间，这样，缓存中保存的都是热点数据，解决了缓存利用率问题.</li>\n</ul>\n<p> <font color=\"red\" ><b>缺点:</b></font></p>\n<ul>\n<li><p><strong>异常引发数据不一致问题（这里分两种情况讨论）:</strong> </p>\n<p>① <font color=\"Coral\" face=\"华文彩云\"><b>「先更新缓存，后更新数据库」</b></font> </p>\n<p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库是<font color=\"Maroon\">「旧值」</font>。</p>\n<p>虽然此时读请求可以命中缓存，拿到正确的值，但是一旦<font color=\"Maroon\">「缓存失效」</font>。 <br>就会从数据库中读取<font color=\"Maroon\">「旧值」</font>， 这时更新进缓存的也是这个旧值。</p>\n<p>这时，用户就会发现之前修改过的数据，突然又<font color=\"Maroon\">「变回去」</font>了。</p>\n<p>② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font> </p>\n<p>数据库更新成功，写缓存失败，那么数据库是最新值，缓存中是<font color=\"Maroon\">「旧值」</font>。</p>\n<p>这时用户从缓存中读到的全是旧数据，直到<font color=\"Maroon\">「缓存失效」</font>后，读数据库才能读到最新的值。</p>\n<p>这时用户发现，自己修改的值，迟迟不能生效。</p>\n</li>\n<li><p><strong>并发引发数据不一致问题:</strong> </p>\n<p>① <font color=\"Coral\" face=\"华文彩云\"><b> 「先更新缓存，后更新数据库」</b></font></p>\n<p>  接下来我们看，即使数据库和缓存都更新成功，会不会就没什么问题了？</p>\n<p>  假设现在又线程 A 和线程 B 两个线程，需要更新<font color=\"Maroon\">「同一条」</font>数据，时序如下:</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T1): 线程 A 更新数据库 (X = 1) </span><br><span class=\"line\">T2): 线程 B 更新数据库 (X = 2) </span><br><span class=\"line\">T3): 线程 B 更新缓存 (X = 2) </span><br><span class=\"line\">T4): 线程 A 更新缓存 (X = 1) </span><br></pre></td></tr></table></figure>\n<p>  最后结果：缓存中（X=1） 数据库（X=2），从而造成数据不一致。</p>\n<p>② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后更新缓存」</b></font></p>\n<p>   同 ① ，这里不在详述。</p>\n</li>\n<li><p><strong>缓存利用率低</strong> </p>\n<p>因为该方案是每次数据库发生变更，都会去写缓存，但是缓存中的数据很多都不会被访问到，留在内存中耗费资源。</p>\n</li>\n</ul>\n</li>\n<li><blockquote>\n<p><strong>旁路缓存策略方案</strong>  </p>\n<ul>\n<li>读请求先读缓存，缓存不命中，再读库</li>\n<li>写请求做两个动作：写数据库+删除数据缓存</li>\n</ul>\n</blockquote>\n<p><font color=\"red\" ><b>缺点:</b></font></p>\n<ul>\n<li><p><strong>异常引发数据不一致问题（这里分两种情况讨论）:</strong> </p>\n<p>  这里的场景和 ii.中的异常场景相同，两步中只要有其中一步发生失败，就会引发数据不一致。</p>\n</li>\n<li><p><strong>并发引发数据不一致问题:</strong></p>\n<p>  ① <font color=\"Coral\" face=\"华文彩云\"><b>「先删除缓存，后更新数据库」</b></font> </p>\n<p>  如果有 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据，可能会发生以下场景:</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T1): 线程 A 要更新 X = 2 (原值 X = 1)</span><br><span class=\"line\">     </span><br><span class=\"line\">T2): 线程 A 删除缓存</span><br><span class=\"line\">     </span><br><span class=\"line\">T3): 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</span><br><span class=\"line\">     </span><br><span class=\"line\">T4): 线程 A 将新值写入数据库 (X = 2)</span><br><span class=\"line\">     </span><br><span class=\"line\">T5): 线程 B 将旧值写入缓存 (X = 1)</span><br><span class=\"line\">     </span><br><span class=\"line\">T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 发生不一致。</span><br></pre></td></tr></table></figure>\n<p>  可见，先删除缓存，再更新数据库，当发生<font color=\"Maroon\">「读+写」</font> 并发时，存在数据不一致的情况。</p>\n<p>  ② <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font></p>\n<p>  依旧是 2 个线程要并发<font color=\"Maroon\">「读写」</font> 数据。</p>\n <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T1): 缓存中 X 不存在（数据库 X = 1）</span><br><span class=\"line\"></span><br><span class=\"line\">T2): 线程 A 读取数据库，得到旧值 (X = 1)</span><br><span class=\"line\"></span><br><span class=\"line\">T3): 线程 B 更新数据库（X = 2）</span><br><span class=\"line\"></span><br><span class=\"line\">T4): 线程 B 删除缓存</span><br><span class=\"line\"></span><br><span class=\"line\">T5): 线程 A 将旧值写入缓存 (X = 1)</span><br><span class=\"line\"></span><br><span class=\"line\">T6): X 的值在缓存中（X = 1），在数据库中 (X = 2), 也发生不一致。</span><br></pre></td></tr></table></figure>\n<p>  其实这个方案就是算是<font color=\"Maroon\">「旁路缓存」</font>策略的实现方案；</p>\n<p>  仔细思考以下，这种情况理论来说是可能发生的，但实际上发生的概率是<font color=\"Maroon\">「极低」</font>的。</p>\n<p>  因为它必须满足 3 个条件:</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1-: 缓存刚好失效</span><br><span class=\"line\">       </span><br><span class=\"line\">2-: 读请求 + 写请求并发</span><br><span class=\"line\">       </span><br><span class=\"line\">3-: 更新数据库 + 删除缓存的时间(T3+T4) &gt; 读数据库 + 写缓存时间 (T2 + T5) </span><br></pre></td></tr></table></figure>\n<p>  <font color=\"SeaGreen\"><b>因为写数据库通常有加锁操作，所以写数据库通常要比读数据库的时间要长，所以，条件3发生的概率极低。<br>  这个策略也是我用在<font color=\"Maroon\">「成长值账户」</font>中的缓存策略；</b></font></p>\n  <p>\n  ________________________________________________________________________________________________________________________\n  <font color=\"Maroon\">前面说过异常情况，无论是更新缓存还是删除缓存，只要第二步发生失败，就会导致数据库和缓存不一致。</font> \n\n<p>  那么这里我们再回过头来讨论下<font color=\"Maroon\">「旁路缓存策略」</font> - <font color=\"Coral\" face=\"华文彩云\"><b>「先更新数据库，后删除缓存」</b></font> 策略异常情况下，我们如何保证第二步执行成功？</p>\n  </p></li>\n<li><p><strong><font color=\"Maroon\">重试</font></strong> </p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果更新数据库成功，删除缓存失败，这里我们就可以无脑的在业务代码中，一直尝试删除缓存；</span><br><span class=\"line\">但是这种方案往往存在以下问题：</span><br><span class=\"line\">1-: 失败后立即重试，大概率还会「失败」（网络抖动，或者服务异常）;</span><br><span class=\"line\">2-: 「重试次数」我们要设置多少才是合理值？</span><br><span class=\"line\">3-: 重试会一直「占用」线程资源，无法服务其它请求。</span><br></pre></td></tr></table></figure>\n<p>基于以上结论，我们发现这种<font color=\"Maroon\">「同步重试」</font>方式往往不能解决根本问题。</p>\n</li>\n<li><p><strong><font color=\"Maroon\">异步重试</font></strong> </p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">异步重试步骤：</span><br><span class=\"line\">1-: 更新数据库后，发消息到消息队列。</span><br><span class=\"line\">2-: 消费者消费队列消息。</span><br><span class=\"line\">3-: 删除对应的缓存信息。</span><br></pre></td></tr></table></figure>\n<p>这个方案除了需要维护一个重的「消息队列」服务外，看似好像是无懈可击的方案，但是该方案也有一个致命的漏洞，<br>那就是，数据库主从延迟，基于前面我们讨论的并发情况，写数据库往往是操作主库，查库往往是操作从库，所以，<br>会存在，主库处理玩，然后缓存清理后，从库还是旧数据的情况，那么用户从从库中读取旧数据，更新到缓存中时，还是<br>会出现数据不一致的情况。</p>\n<p>基于以上总总方案，所以我们引入最终的解决方案:</p>\n</li>\n<li><p><strong><font color=\"Maroon\">订阅数据库变更日志，再操作缓存</font></strong> </p>\n<p>引入binlog 监控组件 canal 监控binlog变更日志。</p>\n<p><font color=\"green\" ><b>优点:</b></font></p>\n<ul>\n<li>业务只操作数据，无需考虑缓存以及其它相关业务是失败情况，只要写库成功，就会有binlog，<br>余下的工作旧交由下游业务处理，使得业务更加轻量化和简洁化。</li>\n<li>canal 不作为master的slave，而是作为一个slave的slave，规避主从延迟造成的数据不一致。</li>\n<li>利用binlog 本身的有序性，完全避免并发中的数据不一致问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-数据变更业务埋点\"><a href=\"#2-数据变更业务埋点\" class=\"headerlink\" title=\"2. 数据变更业务埋点\"></a>2. 数据变更业务埋点</h2><ul>\n<li><h3 id=\"券变更通知用户业务\"><a href=\"#券变更通知用户业务\" class=\"headerlink\" title=\"券变更通知用户业务\"></a>券变更通知用户业务</h3><ol>\n<li><blockquote>\n<p><strong>传统做法</strong></p>\n<ul>\n<li>在每一个涉及券变动的业务中设置业务埋点</li>\n<li>动态的更新缓存</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>  <font color=\"red\" ><b>缺点:</b></font></p>\n<ol>\n<li>极大的增加业务代码的复杂度。</li>\n<li>极大的增加业务出错概率。</li>\n<li>缓存不一致问题。</li>\n</ol>\n<p>  <font color=\"Green\" ><b>解决方案: canal + kafka</b></font> </p>\n<ol>\n<li>出错率低</li>\n<li>kafka 持久化，失败重试。</li>\n<li>和业务主流程解耦。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"使用静态内部类实现单例","date":"2018-11-23T03:08:58.000Z","_content":"\n## 单例模式之利用静态类实现单例\n\n> 利用静态类在jvm内存模型中存储在静态块且只有一个实例的属性，可以轻松实现单例，保证了线程的安全性；\n\n\n\n**具体代码如下**\n\n```java\npackage com.ant.innerclass;\n \n/**\n * @author Ant gxstax@163.com\n * @ClassName: HolderSingleton\n * @Description: 静态内部类实现单例\n * @datetime 2018/11/23 14:11\n * @Version 1.0\n */\npublic class HolderSingleton {\n \n    private HolderSingleton() {\n    }\n \n    public static final class Holder {\n        private static final HolderSingleton instance = new HolderSingleton();\n    }\n \n    public static HolderSingleton getInstance () {\n        return Holder.instance;\n    }\n \n    public static void main(String[] args) {\n        System.out.println(HolderSingleton.getInstance());\n    }\n}\n```\n\n","source":"_posts/使用静态内部类实现单例.md","raw":"---\ntitle: 使用静态内部类实现单例\ndate: 2018-11-23 11:08:58\ncategories:\n    - java\ntags: \n    - java\n---\n\n## 单例模式之利用静态类实现单例\n\n> 利用静态类在jvm内存模型中存储在静态块且只有一个实例的属性，可以轻松实现单例，保证了线程的安全性；\n\n\n\n**具体代码如下**\n\n```java\npackage com.ant.innerclass;\n \n/**\n * @author Ant gxstax@163.com\n * @ClassName: HolderSingleton\n * @Description: 静态内部类实现单例\n * @datetime 2018/11/23 14:11\n * @Version 1.0\n */\npublic class HolderSingleton {\n \n    private HolderSingleton() {\n    }\n \n    public static final class Holder {\n        private static final HolderSingleton instance = new HolderSingleton();\n    }\n \n    public static HolderSingleton getInstance () {\n        return Holder.instance;\n    }\n \n    public static void main(String[] args) {\n        System.out.println(HolderSingleton.getInstance());\n    }\n}\n```\n\n","slug":"使用静态内部类实现单例","published":1,"updated":"2022-02-27T11:30:00.838Z","_id":"cl064wjvo0001lcrb7gs7f21i","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"单例模式之利用静态类实现单例\"><a href=\"#单例模式之利用静态类实现单例\" class=\"headerlink\" title=\"单例模式之利用静态类实现单例\"></a>单例模式之利用静态类实现单例</h2><blockquote>\n<p>利用静态类在jvm内存模型中存储在静态块且只有一个实例的属性，可以轻松实现单例，保证了线程的安全性；</p>\n</blockquote>\n<p><strong>具体代码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.ant.innerclass;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Ant gxstax@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span>: HolderSingleton</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 静态内部类实现单例</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@datetime</span> 2018/11/23 14:11</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HolderSingleton</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">HolderSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Holder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">HolderSingleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HolderSingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderSingleton <span class=\"title function_\">getInstance</span> <span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Holder.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(HolderSingleton.getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单例模式之利用静态类实现单例\"><a href=\"#单例模式之利用静态类实现单例\" class=\"headerlink\" title=\"单例模式之利用静态类实现单例\"></a>单例模式之利用静态类实现单例</h2><blockquote>\n<p>利用静态类在jvm内存模型中存储在静态块且只有一个实例的属性，可以轻松实现单例，保证了线程的安全性；</p>\n</blockquote>\n<p><strong>具体代码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.ant.innerclass;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Ant gxstax@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span>: HolderSingleton</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 静态内部类实现单例</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@datetime</span> 2018/11/23 14:11</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HolderSingleton</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">HolderSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Holder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">HolderSingleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HolderSingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderSingleton <span class=\"title function_\">getInstance</span> <span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Holder.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(HolderSingleton.getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"网络设备状态标识","date":"2019-09-17T06:46:39.000Z","_content":"\n\n\n> 记录一下网络设备的各个标志都是什么意思；\n> 我这里以我的一台虚拟机机为例（虚拟软件：virtualbox，系统：centos7）\n> 首先我们运行命令：ip addr 查看网络设备信息：\n\n![image-20220223150205002](/Users/mayi/Library/Application Support/typora-user-images/image-20220223150205002.png)\n\n1. <BROADCAST,MULTICAST,UP,LOWER_UP> :net_device flags，网络设备的状态标识\n\n   ```tex\n   BROADCAST：表示这个网卡有广播地址，可以发送广播包；\n   MULTICAST：表示这个网卡可以发送多播包；\n   UP：表示网卡处于启动状态；\n   LOWER_UP：表示L1是启动的，也就是插着网线；\n   ```\n\n2. mtu 1500\n\n   ```tex\n   MTU: 是二层 MAC 层的概念。\n        MAC 层有 MAC 的头，mtu 1500就表示-以太网规定MAC和正文加起来不能超过1500字节。\n   ```\n\n3. qdisc pfifo_fast：\n\n   ```tex\n   qdisc: 是queueing discipline （排队规则），内核如果需要通过某个网络接口发送数据包，他们都需要按这个接口配置的 qdisc 把数据包加入队列；\n   ```\n\n4. scope global : \n\n   ```tex\n   在ip地址后面有一个scope global，global说明这张网卡是可以对外的，可以接受来自任何地方的包。\n   ```\n\n5. scope host :\n\n   ```tex\n   像lo这里是个scope host，说明这张网卡仅可以提供本机相互通信。\n   lo 全称是loopback，又称环回接口，往往会被分配到127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。\n   ```\n\n   \n\n\n","source":"_posts/网络设备状态标识.md","raw":"---\ntitle: 网络设备状态标识\ndate: 2019-09-17 14:46:39\ncategories:\n    - network\ntags: [network]\n---\n\n\n\n> 记录一下网络设备的各个标志都是什么意思；\n> 我这里以我的一台虚拟机机为例（虚拟软件：virtualbox，系统：centos7）\n> 首先我们运行命令：ip addr 查看网络设备信息：\n\n![image-20220223150205002](/Users/mayi/Library/Application Support/typora-user-images/image-20220223150205002.png)\n\n1. <BROADCAST,MULTICAST,UP,LOWER_UP> :net_device flags，网络设备的状态标识\n\n   ```tex\n   BROADCAST：表示这个网卡有广播地址，可以发送广播包；\n   MULTICAST：表示这个网卡可以发送多播包；\n   UP：表示网卡处于启动状态；\n   LOWER_UP：表示L1是启动的，也就是插着网线；\n   ```\n\n2. mtu 1500\n\n   ```tex\n   MTU: 是二层 MAC 层的概念。\n        MAC 层有 MAC 的头，mtu 1500就表示-以太网规定MAC和正文加起来不能超过1500字节。\n   ```\n\n3. qdisc pfifo_fast：\n\n   ```tex\n   qdisc: 是queueing discipline （排队规则），内核如果需要通过某个网络接口发送数据包，他们都需要按这个接口配置的 qdisc 把数据包加入队列；\n   ```\n\n4. scope global : \n\n   ```tex\n   在ip地址后面有一个scope global，global说明这张网卡是可以对外的，可以接受来自任何地方的包。\n   ```\n\n5. scope host :\n\n   ```tex\n   像lo这里是个scope host，说明这张网卡仅可以提供本机相互通信。\n   lo 全称是loopback，又称环回接口，往往会被分配到127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。\n   ```\n\n   \n\n\n","slug":"网络设备状态标识","published":1,"updated":"2022-02-27T11:30:00.838Z","_id":"cl064wjvr0004lcrbf7ah45dj","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>记录一下网络设备的各个标志都是什么意思；<br>我这里以我的一台虚拟机机为例（虚拟软件：virtualbox，系统：centos7）<br>首先我们运行命令：ip addr 查看网络设备信息：</p>\n</blockquote>\n<p>![image-20220223150205002](/Users/mayi/Library/Application Support/typora-user-images/image-20220223150205002.png)</p>\n<ol>\n<li><p>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; :net_device flags，网络设备的状态标识</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BROADCAST：表示这个网卡有广播地址，可以发送广播包；</span><br><span class=\"line\">MULTICAST：表示这个网卡可以发送多播包；</span><br><span class=\"line\">UP：表示网卡处于启动状态；</span><br><span class=\"line\">LOWER<span class=\"built_in\">_</span>UP：表示L1是启动的，也就是插着网线；</span><br></pre></td></tr></table></figure></li>\n<li><p>mtu 1500</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MTU: 是二层 MAC 层的概念。</span><br><span class=\"line\">     MAC 层有 MAC 的头，mtu 1500就表示-以太网规定MAC和正文加起来不能超过1500字节。</span><br></pre></td></tr></table></figure></li>\n<li><p>qdisc pfifo_fast：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qdisc: 是queueing discipline （排队规则），内核如果需要通过某个网络接口发送数据包，他们都需要按这个接口配置的 qdisc 把数据包加入队列；</span><br></pre></td></tr></table></figure></li>\n<li><p>scope global : </p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在ip地址后面有一个scope global，global说明这张网卡是可以对外的，可以接受来自任何地方的包。</span><br></pre></td></tr></table></figure></li>\n<li><p>scope host :</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">像lo这里是个scope host，说明这张网卡仅可以提供本机相互通信。</span><br><span class=\"line\">lo 全称是loopback，又称环回接口，往往会被分配到127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录一下网络设备的各个标志都是什么意思；<br>我这里以我的一台虚拟机机为例（虚拟软件：virtualbox，系统：centos7）<br>首先我们运行命令：ip addr 查看网络设备信息：</p>\n</blockquote>\n<p>![image-20220223150205002](/Users/mayi/Library/Application Support/typora-user-images/image-20220223150205002.png)</p>\n<ol>\n<li><p>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; :net_device flags，网络设备的状态标识</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BROADCAST：表示这个网卡有广播地址，可以发送广播包；</span><br><span class=\"line\">MULTICAST：表示这个网卡可以发送多播包；</span><br><span class=\"line\">UP：表示网卡处于启动状态；</span><br><span class=\"line\">LOWER<span class=\"built_in\">_</span>UP：表示L1是启动的，也就是插着网线；</span><br></pre></td></tr></table></figure></li>\n<li><p>mtu 1500</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MTU: 是二层 MAC 层的概念。</span><br><span class=\"line\">     MAC 层有 MAC 的头，mtu 1500就表示-以太网规定MAC和正文加起来不能超过1500字节。</span><br></pre></td></tr></table></figure></li>\n<li><p>qdisc pfifo_fast：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qdisc: 是queueing discipline （排队规则），内核如果需要通过某个网络接口发送数据包，他们都需要按这个接口配置的 qdisc 把数据包加入队列；</span><br></pre></td></tr></table></figure></li>\n<li><p>scope global : </p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在ip地址后面有一个scope global，global说明这张网卡是可以对外的，可以接受来自任何地方的包。</span><br></pre></td></tr></table></figure></li>\n<li><p>scope host :</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">像lo这里是个scope host，说明这张网卡仅可以提供本机相互通信。</span><br><span class=\"line\">lo 全称是loopback，又称环回接口，往往会被分配到127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"k8s-Headless Service","date":"2022-02-25T03:09:54.000Z","_content":"\n#### 如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定\n\nKubernetes架构master节点有一个很重要的组件-Service，Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制。比如，一个 Deployment 有 3 个 Pod，那么我就可以定义一个 Service。然后，用户只要能访问到这个 Service，它就能访问到某个具体的 Pod。\n\n那么，这个 Service 又是如何被访问的呢？\n\n**第一种方式，是以 Service 的 VIP（Virtual IP，即：虚拟 IP）方式。**\n\n比如：当我访问 10.0.23.1 这个 Service 的 IP 地址时，10.0.23.1 其实就是一个 VIP，它会把请求转发到该 Service 所代理的某一个 Pod 上。\n\n**第二种方式，就是以 Service 的 DNS 方式。**\n\n比如：这时候，只要我访问“my-svc.my-namespace.svc.cluster.local”这条 DNS 记录，就可以访问到名叫 my-svc 的 Service 所代理的某一个 Pod。\n\n而在第二种 Service DNS 的方式下，具体还可以分为两种处理方法：\n\n第一种处理方法，是 Normal Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了。\n\n而第二种处理方法，正是 Headless Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，直接就是 my-svc 代理的某一个 Pod 的 IP 地址。可以看到，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。\n\n那么，这样的设计又有什么作用呢？\n\n想要回答这个问题，我们需要从 Headless Service 的定义方式看起。\n\n下面是一个标准的 Headless Service 对应的 YAML 文件：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  labels:\n    app: nginx\nspec:\n  ports:\n  - port: 80\n    name: web\n  clusterIP: None\n  selector:\n    app: nginx\n```\n\n可以看到，所谓的 Headless Service，其实仍是一个标准 Service 的 YAML 文件。只不过，它的 clusterIP 字段的值是：None，即：这个 Service，没有一个 VIP 作为“头”。这也就是 Headless 的含义。所以，这个 Service 被创建后并不会被分配一个 VIP，而是会以 DNS 记录的方式暴露出它所代理的 Pod。\n\n而它所代理的 Pod，依然是 Label Selector 机制选择出来的，即：所有携带了 app=nginx 标签的 Pod，都会被这个 Service 代理起来。\n\n然后关键来了。当你按照这样的方式创建了一个 Headless Service 之后，它所代理的所有 Pod 的 IP 地址，都会被绑定一个这样格式的 DNS 记录，如下所示：\n\n```tex\n<pod-name>.<svc-name>.<namespace>.svc.cluster.local\n```\n\n这个 DNS 记录，正是 Kubernetes 项目为 Pod 分配的唯一的“可解析身份”（Resolvable Identity）。\n\n有了这个“可解析身份”，只要你知道了一个 Pod 的名字，以及它对应的 Service 的名字，你就可以非常确定地通过这条 DNS 记录访问到 Pod 的 IP 地址。\n\n那么，StatefulSet 又是如何使用这个 DNS 记录来维持 Pod 的拓扑状态的呢？\n\n为了回答这个问题，现在我们就来编写一个 StatefulSet 的 YAML 文件，如下所示：\n\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  serviceName: \"nginx\"\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.9.1\n        ports:\n        - containerPort: 80\n          name: web\n```\n\n这个 YAML 文件，和我们在前面文章中用到的 nginx-deployment 的唯一区别，就是多了一个 serviceName=nginx 字段。\n\n这个字段的作用，就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”。\n\n所以，当你通过 kubectl create 创建了上面这个 Service 和 StatefulSet 之后，就会看到如下两个对象：\n\n```bash\n$ kubectl create -f svc.yaml\n$ kubectl get service nginx\nNAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\nnginx   ClusterIP   None         <none>        80/TCP    9s\n\n$ kubectl create -f statefulset.yaml\n$ kubectl get statefulset web\nNAME   READY   AGE\nweb    2/2     32s\n\nREADY 字段里面的字段表示的是 当前运行副本个数/期望运行个数\n```\n\n这时候，如果你手比较快的话，还可以通过 kubectl 的 -w 参数，即：Watch 功能，实时查看 StatefulSet 创建两个有状态实例的过程：\n\n> 备注：如果手不够快的话，Pod 很快就创建完了。不过，你依然可以通过这个 StatefulSet 的 Events 看到这些信息。\n\n```bash\n$ kubectl get pods -w -l app=nginx\nNAME    READY   STATUS    RESTARTS   AGE\nweb-0   1/1     Running   0          3m21s\nweb-1   1/1     Running   0          3m8s\n```\n\n通过上面这个 Pod 的创建过程，我们不难看到，StatefulSet 给它所管理的所有 Pod 的名字，进行了编号，编号规则是  [statefulset name]-[ordinal index]。\n\n而且这些编号都是从 0 开始累加，与 StatefulSet 的每个 Pod 实例一一对应，绝不重复。\n\n更重要的是，这些 Pod 的创建，也是严格按照编号顺序进行的。比如，在 web-0 进入到 Running 状态、并且细分状态（Conditions）成为 Ready 之前，web-1 会一直处于 Pending 状态。\n\n> 备注：Ready 状态再一次提醒了我们，为 Pod 设置 livenessProbe 和 readinessProbe 的重要性。\n\n当这两个 Pod 都进入了 Running 状态之后，你就可以查看到它们各自唯一的“网络身份”了。\n\n我们使用 kubectl exec 命令进入到容器中查看它们的 hostname：\n\n```bash\n$ kubectl exec web-0 -- sh -c 'hostname'\nweb-0\n$ kubectl exec web-1 -- sh -c 'hostname'\nweb-1\n```\n\n可以看到，这两个 Pod 的 hostname 与 Pod 名字是一致的，都被分配了对应的编号。接下来，我们再试着以 DNS 的方式，访问一下这个 Headless Service：\n\n```bash\n$ kubectl run -i --tty --image busybox:1.28.4 dns-test --restart=Never --rm /bin/sh \n```\n\n通过这条命令，我们启动了一个一次性的 Pod，因为 --rm 意味着 Pod 退出后就会被删除掉。然后，在这个 Pod 的容器里面，我们尝试用 nslookup 命令，解析一下 Pod 对应的 Headless Service：\n\n```bash\n$ kubectl run -i --tty --image busybox:1.28.4 dns-test --restart=Never --rm /bin/sh\nIf you don't see a command prompt, try pressing enter.\n/ # nslookup web-0.nginx\nServer:    10.96.0.10\nAddress 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local\n\nName:      web-0.nginx\nAddress 1: 10.44.0.5 web-0.nginx.default.svc.cluster.local\n/ # nslookup web-1.nginx\nServer:    10.96.0.10\nAddress 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local\n\nName:      web-1.nginx\nAddress 1: 10.32.0.7 web-1.nginx.default.svc.cluster.local\n\n```\n\n我们可以看到，在这个 StatefulSet 中，这两个新 Pod 的“网络标识”（比如：web-0.nginx 和 web-1.nginx），再次解析到了正确的 IP 地址（比如：web-0 Pod 的 IP 地址 10.44.0.5）。\n\n通过这种方法，Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来。此外，Kubernetes 还为每一个 Pod 提供了一个固定并且唯一的访问入口，即：这个 Pod 对应的 DNS 记录。\n\n这些状态，在 StatefulSet 的整个生命周期里都会保持不变，绝不会因为对应 Pod 的删除或者重新创建而失效。\n\n不过，相信你也已经注意到了，尽管 web-0.nginx 这条记录本身不会变，但它解析到的 Pod 的 IP 地址，并不是固定的。这就意味着，对于“有状态应用”实例的访问，你必须使用 DNS 记录或者 hostname 的方式，而绝不应该直接访问这些 Pod 的 IP 地址。\n","source":"_posts/k8s-Headless-Service.md","raw":"---\ntitle: k8s-Headless Service\ndate: 2022-02-25 11:09:54\ncategories:\n    - [云原生, k8s]\ntags: \n    - k8s\n---\n\n#### 如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定\n\nKubernetes架构master节点有一个很重要的组件-Service，Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制。比如，一个 Deployment 有 3 个 Pod，那么我就可以定义一个 Service。然后，用户只要能访问到这个 Service，它就能访问到某个具体的 Pod。\n\n那么，这个 Service 又是如何被访问的呢？\n\n**第一种方式，是以 Service 的 VIP（Virtual IP，即：虚拟 IP）方式。**\n\n比如：当我访问 10.0.23.1 这个 Service 的 IP 地址时，10.0.23.1 其实就是一个 VIP，它会把请求转发到该 Service 所代理的某一个 Pod 上。\n\n**第二种方式，就是以 Service 的 DNS 方式。**\n\n比如：这时候，只要我访问“my-svc.my-namespace.svc.cluster.local”这条 DNS 记录，就可以访问到名叫 my-svc 的 Service 所代理的某一个 Pod。\n\n而在第二种 Service DNS 的方式下，具体还可以分为两种处理方法：\n\n第一种处理方法，是 Normal Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了。\n\n而第二种处理方法，正是 Headless Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，直接就是 my-svc 代理的某一个 Pod 的 IP 地址。可以看到，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。\n\n那么，这样的设计又有什么作用呢？\n\n想要回答这个问题，我们需要从 Headless Service 的定义方式看起。\n\n下面是一个标准的 Headless Service 对应的 YAML 文件：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  labels:\n    app: nginx\nspec:\n  ports:\n  - port: 80\n    name: web\n  clusterIP: None\n  selector:\n    app: nginx\n```\n\n可以看到，所谓的 Headless Service，其实仍是一个标准 Service 的 YAML 文件。只不过，它的 clusterIP 字段的值是：None，即：这个 Service，没有一个 VIP 作为“头”。这也就是 Headless 的含义。所以，这个 Service 被创建后并不会被分配一个 VIP，而是会以 DNS 记录的方式暴露出它所代理的 Pod。\n\n而它所代理的 Pod，依然是 Label Selector 机制选择出来的，即：所有携带了 app=nginx 标签的 Pod，都会被这个 Service 代理起来。\n\n然后关键来了。当你按照这样的方式创建了一个 Headless Service 之后，它所代理的所有 Pod 的 IP 地址，都会被绑定一个这样格式的 DNS 记录，如下所示：\n\n```tex\n<pod-name>.<svc-name>.<namespace>.svc.cluster.local\n```\n\n这个 DNS 记录，正是 Kubernetes 项目为 Pod 分配的唯一的“可解析身份”（Resolvable Identity）。\n\n有了这个“可解析身份”，只要你知道了一个 Pod 的名字，以及它对应的 Service 的名字，你就可以非常确定地通过这条 DNS 记录访问到 Pod 的 IP 地址。\n\n那么，StatefulSet 又是如何使用这个 DNS 记录来维持 Pod 的拓扑状态的呢？\n\n为了回答这个问题，现在我们就来编写一个 StatefulSet 的 YAML 文件，如下所示：\n\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  serviceName: \"nginx\"\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.9.1\n        ports:\n        - containerPort: 80\n          name: web\n```\n\n这个 YAML 文件，和我们在前面文章中用到的 nginx-deployment 的唯一区别，就是多了一个 serviceName=nginx 字段。\n\n这个字段的作用，就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”。\n\n所以，当你通过 kubectl create 创建了上面这个 Service 和 StatefulSet 之后，就会看到如下两个对象：\n\n```bash\n$ kubectl create -f svc.yaml\n$ kubectl get service nginx\nNAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\nnginx   ClusterIP   None         <none>        80/TCP    9s\n\n$ kubectl create -f statefulset.yaml\n$ kubectl get statefulset web\nNAME   READY   AGE\nweb    2/2     32s\n\nREADY 字段里面的字段表示的是 当前运行副本个数/期望运行个数\n```\n\n这时候，如果你手比较快的话，还可以通过 kubectl 的 -w 参数，即：Watch 功能，实时查看 StatefulSet 创建两个有状态实例的过程：\n\n> 备注：如果手不够快的话，Pod 很快就创建完了。不过，你依然可以通过这个 StatefulSet 的 Events 看到这些信息。\n\n```bash\n$ kubectl get pods -w -l app=nginx\nNAME    READY   STATUS    RESTARTS   AGE\nweb-0   1/1     Running   0          3m21s\nweb-1   1/1     Running   0          3m8s\n```\n\n通过上面这个 Pod 的创建过程，我们不难看到，StatefulSet 给它所管理的所有 Pod 的名字，进行了编号，编号规则是  [statefulset name]-[ordinal index]。\n\n而且这些编号都是从 0 开始累加，与 StatefulSet 的每个 Pod 实例一一对应，绝不重复。\n\n更重要的是，这些 Pod 的创建，也是严格按照编号顺序进行的。比如，在 web-0 进入到 Running 状态、并且细分状态（Conditions）成为 Ready 之前，web-1 会一直处于 Pending 状态。\n\n> 备注：Ready 状态再一次提醒了我们，为 Pod 设置 livenessProbe 和 readinessProbe 的重要性。\n\n当这两个 Pod 都进入了 Running 状态之后，你就可以查看到它们各自唯一的“网络身份”了。\n\n我们使用 kubectl exec 命令进入到容器中查看它们的 hostname：\n\n```bash\n$ kubectl exec web-0 -- sh -c 'hostname'\nweb-0\n$ kubectl exec web-1 -- sh -c 'hostname'\nweb-1\n```\n\n可以看到，这两个 Pod 的 hostname 与 Pod 名字是一致的，都被分配了对应的编号。接下来，我们再试着以 DNS 的方式，访问一下这个 Headless Service：\n\n```bash\n$ kubectl run -i --tty --image busybox:1.28.4 dns-test --restart=Never --rm /bin/sh \n```\n\n通过这条命令，我们启动了一个一次性的 Pod，因为 --rm 意味着 Pod 退出后就会被删除掉。然后，在这个 Pod 的容器里面，我们尝试用 nslookup 命令，解析一下 Pod 对应的 Headless Service：\n\n```bash\n$ kubectl run -i --tty --image busybox:1.28.4 dns-test --restart=Never --rm /bin/sh\nIf you don't see a command prompt, try pressing enter.\n/ # nslookup web-0.nginx\nServer:    10.96.0.10\nAddress 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local\n\nName:      web-0.nginx\nAddress 1: 10.44.0.5 web-0.nginx.default.svc.cluster.local\n/ # nslookup web-1.nginx\nServer:    10.96.0.10\nAddress 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local\n\nName:      web-1.nginx\nAddress 1: 10.32.0.7 web-1.nginx.default.svc.cluster.local\n\n```\n\n我们可以看到，在这个 StatefulSet 中，这两个新 Pod 的“网络标识”（比如：web-0.nginx 和 web-1.nginx），再次解析到了正确的 IP 地址（比如：web-0 Pod 的 IP 地址 10.44.0.5）。\n\n通过这种方法，Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来。此外，Kubernetes 还为每一个 Pod 提供了一个固定并且唯一的访问入口，即：这个 Pod 对应的 DNS 记录。\n\n这些状态，在 StatefulSet 的整个生命周期里都会保持不变，绝不会因为对应 Pod 的删除或者重新创建而失效。\n\n不过，相信你也已经注意到了，尽管 web-0.nginx 这条记录本身不会变，但它解析到的 Pod 的 IP 地址，并不是固定的。这就意味着，对于“有状态应用”实例的访问，你必须使用 DNS 记录或者 hostname 的方式，而绝不应该直接访问这些 Pod 的 IP 地址。\n","slug":"k8s-Headless-Service","published":1,"updated":"2022-02-28T03:25:33.139Z","_id":"cl064wjvs0005lcrbgr852olr","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"如何保证应用实例的拓扑状态，在-Pod-删除和再创建的过程中保持稳定\"><a href=\"#如何保证应用实例的拓扑状态，在-Pod-删除和再创建的过程中保持稳定\" class=\"headerlink\" title=\"如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定\"></a>如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定</h4><p>Kubernetes架构master节点有一个很重要的组件-Service，Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制。比如，一个 Deployment 有 3 个 Pod，那么我就可以定义一个 Service。然后，用户只要能访问到这个 Service，它就能访问到某个具体的 Pod。</p>\n<p>那么，这个 Service 又是如何被访问的呢？</p>\n<p><strong>第一种方式，是以 Service 的 VIP（Virtual IP，即：虚拟 IP）方式。</strong></p>\n<p>比如：当我访问 10.0.23.1 这个 Service 的 IP 地址时，10.0.23.1 其实就是一个 VIP，它会把请求转发到该 Service 所代理的某一个 Pod 上。</p>\n<p><strong>第二种方式，就是以 Service 的 DNS 方式。</strong></p>\n<p>比如：这时候，只要我访问“my-svc.my-namespace.svc.cluster.local”这条 DNS 记录，就可以访问到名叫 my-svc 的 Service 所代理的某一个 Pod。</p>\n<p>而在第二种 Service DNS 的方式下，具体还可以分为两种处理方法：</p>\n<p>第一种处理方法，是 Normal Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了。</p>\n<p>而第二种处理方法，正是 Headless Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，直接就是 my-svc 代理的某一个 Pod 的 IP 地址。可以看到，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。</p>\n<p>那么，这样的设计又有什么作用呢？</p>\n<p>想要回答这个问题，我们需要从 Headless Service 的定义方式看起。</p>\n<p>下面是一个标准的 Headless Service 对应的 YAML 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\">  <span class=\"attr\">clusterIP:</span> <span class=\"string\">None</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，所谓的 Headless Service，其实仍是一个标准 Service 的 YAML 文件。只不过，它的 clusterIP 字段的值是：None，即：这个 Service，没有一个 VIP 作为“头”。这也就是 Headless 的含义。所以，这个 Service 被创建后并不会被分配一个 VIP，而是会以 DNS 记录的方式暴露出它所代理的 Pod。</p>\n<p>而它所代理的 Pod，依然是 Label Selector 机制选择出来的，即：所有携带了 app=nginx 标签的 Pod，都会被这个 Service 代理起来。</p>\n<p>然后关键来了。当你按照这样的方式创建了一个 Headless Service 之后，它所代理的所有 Pod 的 IP 地址，都会被绑定一个这样格式的 DNS 记录，如下所示：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure>\n\n<p>这个 DNS 记录，正是 Kubernetes 项目为 Pod 分配的唯一的“可解析身份”（Resolvable Identity）。</p>\n<p>有了这个“可解析身份”，只要你知道了一个 Pod 的名字，以及它对应的 Service 的名字，你就可以非常确定地通过这条 DNS 记录访问到 Pod 的 IP 地址。</p>\n<p>那么，StatefulSet 又是如何使用这个 DNS 记录来维持 Pod 的拓扑状态的呢？</p>\n<p>为了回答这个问题，现在我们就来编写一个 StatefulSet 的 YAML 文件，如下所示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.9.1</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br></pre></td></tr></table></figure>\n\n<p>这个 YAML 文件，和我们在前面文章中用到的 nginx-deployment 的唯一区别，就是多了一个 serviceName=nginx 字段。</p>\n<p>这个字段的作用，就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”。</p>\n<p>所以，当你通过 kubectl create 创建了上面这个 Service 和 StatefulSet 之后，就会看到如下两个对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl create -f svc.yaml</span><br><span class=\"line\">$ kubectl get service nginx</span><br><span class=\"line\">NAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class=\"line\">nginx   ClusterIP   None         &lt;none&gt;        80/TCP    9s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl create -f statefulset.yaml</span><br><span class=\"line\">$ kubectl get statefulset web</span><br><span class=\"line\">NAME   READY   AGE</span><br><span class=\"line\">web    2/2     32s</span><br><span class=\"line\"></span><br><span class=\"line\">READY 字段里面的字段表示的是 当前运行副本个数/期望运行个数</span><br></pre></td></tr></table></figure>\n\n<p>这时候，如果你手比较快的话，还可以通过 kubectl 的 -w 参数，即：Watch 功能，实时查看 StatefulSet 创建两个有状态实例的过程：</p>\n<blockquote>\n<p>备注：如果手不够快的话，Pod 很快就创建完了。不过，你依然可以通过这个 StatefulSet 的 Events 看到这些信息。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -w -l app=nginx</span><br><span class=\"line\">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">web-0   1/1     Running   0          3m21s</span><br><span class=\"line\">web-1   1/1     Running   0          3m8s</span><br></pre></td></tr></table></figure>\n\n<p>通过上面这个 Pod 的创建过程，我们不难看到，StatefulSet 给它所管理的所有 Pod 的名字，进行了编号，编号规则是  [statefulset name]-[ordinal index]。</p>\n<p>而且这些编号都是从 0 开始累加，与 StatefulSet 的每个 Pod 实例一一对应，绝不重复。</p>\n<p>更重要的是，这些 Pod 的创建，也是严格按照编号顺序进行的。比如，在 web-0 进入到 Running 状态、并且细分状态（Conditions）成为 Ready 之前，web-1 会一直处于 Pending 状态。</p>\n<blockquote>\n<p>备注：Ready 状态再一次提醒了我们，为 Pod 设置 livenessProbe 和 readinessProbe 的重要性。</p>\n</blockquote>\n<p>当这两个 Pod 都进入了 Running 状态之后，你就可以查看到它们各自唯一的“网络身份”了。</p>\n<p>我们使用 kubectl exec 命令进入到容器中查看它们的 hostname：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> web-0 -- sh -c <span class=\"string\">&#x27;hostname&#x27;</span></span><br><span class=\"line\">web-0</span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> web-1 -- sh -c <span class=\"string\">&#x27;hostname&#x27;</span></span><br><span class=\"line\">web-1</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这两个 Pod 的 hostname 与 Pod 名字是一致的，都被分配了对应的编号。接下来，我们再试着以 DNS 的方式，访问一下这个 Headless Service：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl run -i --<span class=\"built_in\">tty</span> --image busybox:1.28.4 dns-test --restart=Never --<span class=\"built_in\">rm</span> /bin/sh </span><br></pre></td></tr></table></figure>\n\n<p>通过这条命令，我们启动了一个一次性的 Pod，因为 –rm 意味着 Pod 退出后就会被删除掉。然后，在这个 Pod 的容器里面，我们尝试用 nslookup 命令，解析一下 Pod 对应的 Headless Service：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl run -i --<span class=\"built_in\">tty</span> --image busybox:1.28.4 dns-test --restart=Never --<span class=\"built_in\">rm</span> /bin/sh</span><br><span class=\"line\">If you don<span class=\"string\">&#x27;t see a command prompt, try pressing enter.</span></span><br><span class=\"line\"><span class=\"string\">/ # nslookup web-0.nginx</span></span><br><span class=\"line\"><span class=\"string\">Server:    10.96.0.10</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Name:      web-0.nginx</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.44.0.5 web-0.nginx.default.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\">/ # nslookup web-1.nginx</span></span><br><span class=\"line\"><span class=\"string\">Server:    10.96.0.10</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Name:      web-1.nginx</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.32.0.7 web-1.nginx.default.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，在这个 StatefulSet 中，这两个新 Pod 的“网络标识”（比如：web-0.nginx 和 web-1.nginx），再次解析到了正确的 IP 地址（比如：web-0 Pod 的 IP 地址 10.44.0.5）。</p>\n<p>通过这种方法，Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来。此外，Kubernetes 还为每一个 Pod 提供了一个固定并且唯一的访问入口，即：这个 Pod 对应的 DNS 记录。</p>\n<p>这些状态，在 StatefulSet 的整个生命周期里都会保持不变，绝不会因为对应 Pod 的删除或者重新创建而失效。</p>\n<p>不过，相信你也已经注意到了，尽管 web-0.nginx 这条记录本身不会变，但它解析到的 Pod 的 IP 地址，并不是固定的。这就意味着，对于“有状态应用”实例的访问，你必须使用 DNS 记录或者 hostname 的方式，而绝不应该直接访问这些 Pod 的 IP 地址。</p>\n","site":{"data":{"links":{"马以":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"马以的网站"},"Ant":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"Ant"}}}},"excerpt":"","more":"<h4 id=\"如何保证应用实例的拓扑状态，在-Pod-删除和再创建的过程中保持稳定\"><a href=\"#如何保证应用实例的拓扑状态，在-Pod-删除和再创建的过程中保持稳定\" class=\"headerlink\" title=\"如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定\"></a>如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定</h4><p>Kubernetes架构master节点有一个很重要的组件-Service，Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制。比如，一个 Deployment 有 3 个 Pod，那么我就可以定义一个 Service。然后，用户只要能访问到这个 Service，它就能访问到某个具体的 Pod。</p>\n<p>那么，这个 Service 又是如何被访问的呢？</p>\n<p><strong>第一种方式，是以 Service 的 VIP（Virtual IP，即：虚拟 IP）方式。</strong></p>\n<p>比如：当我访问 10.0.23.1 这个 Service 的 IP 地址时，10.0.23.1 其实就是一个 VIP，它会把请求转发到该 Service 所代理的某一个 Pod 上。</p>\n<p><strong>第二种方式，就是以 Service 的 DNS 方式。</strong></p>\n<p>比如：这时候，只要我访问“my-svc.my-namespace.svc.cluster.local”这条 DNS 记录，就可以访问到名叫 my-svc 的 Service 所代理的某一个 Pod。</p>\n<p>而在第二种 Service DNS 的方式下，具体还可以分为两种处理方法：</p>\n<p>第一种处理方法，是 Normal Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了。</p>\n<p>而第二种处理方法，正是 Headless Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，直接就是 my-svc 代理的某一个 Pod 的 IP 地址。可以看到，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。</p>\n<p>那么，这样的设计又有什么作用呢？</p>\n<p>想要回答这个问题，我们需要从 Headless Service 的定义方式看起。</p>\n<p>下面是一个标准的 Headless Service 对应的 YAML 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\">  <span class=\"attr\">clusterIP:</span> <span class=\"string\">None</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，所谓的 Headless Service，其实仍是一个标准 Service 的 YAML 文件。只不过，它的 clusterIP 字段的值是：None，即：这个 Service，没有一个 VIP 作为“头”。这也就是 Headless 的含义。所以，这个 Service 被创建后并不会被分配一个 VIP，而是会以 DNS 记录的方式暴露出它所代理的 Pod。</p>\n<p>而它所代理的 Pod，依然是 Label Selector 机制选择出来的，即：所有携带了 app=nginx 标签的 Pod，都会被这个 Service 代理起来。</p>\n<p>然后关键来了。当你按照这样的方式创建了一个 Headless Service 之后，它所代理的所有 Pod 的 IP 地址，都会被绑定一个这样格式的 DNS 记录，如下所示：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure>\n\n<p>这个 DNS 记录，正是 Kubernetes 项目为 Pod 分配的唯一的“可解析身份”（Resolvable Identity）。</p>\n<p>有了这个“可解析身份”，只要你知道了一个 Pod 的名字，以及它对应的 Service 的名字，你就可以非常确定地通过这条 DNS 记录访问到 Pod 的 IP 地址。</p>\n<p>那么，StatefulSet 又是如何使用这个 DNS 记录来维持 Pod 的拓扑状态的呢？</p>\n<p>为了回答这个问题，现在我们就来编写一个 StatefulSet 的 YAML 文件，如下所示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.9.1</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br></pre></td></tr></table></figure>\n\n<p>这个 YAML 文件，和我们在前面文章中用到的 nginx-deployment 的唯一区别，就是多了一个 serviceName=nginx 字段。</p>\n<p>这个字段的作用，就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”。</p>\n<p>所以，当你通过 kubectl create 创建了上面这个 Service 和 StatefulSet 之后，就会看到如下两个对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl create -f svc.yaml</span><br><span class=\"line\">$ kubectl get service nginx</span><br><span class=\"line\">NAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class=\"line\">nginx   ClusterIP   None         &lt;none&gt;        80/TCP    9s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl create -f statefulset.yaml</span><br><span class=\"line\">$ kubectl get statefulset web</span><br><span class=\"line\">NAME   READY   AGE</span><br><span class=\"line\">web    2/2     32s</span><br><span class=\"line\"></span><br><span class=\"line\">READY 字段里面的字段表示的是 当前运行副本个数/期望运行个数</span><br></pre></td></tr></table></figure>\n\n<p>这时候，如果你手比较快的话，还可以通过 kubectl 的 -w 参数，即：Watch 功能，实时查看 StatefulSet 创建两个有状态实例的过程：</p>\n<blockquote>\n<p>备注：如果手不够快的话，Pod 很快就创建完了。不过，你依然可以通过这个 StatefulSet 的 Events 看到这些信息。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -w -l app=nginx</span><br><span class=\"line\">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">web-0   1/1     Running   0          3m21s</span><br><span class=\"line\">web-1   1/1     Running   0          3m8s</span><br></pre></td></tr></table></figure>\n\n<p>通过上面这个 Pod 的创建过程，我们不难看到，StatefulSet 给它所管理的所有 Pod 的名字，进行了编号，编号规则是  [statefulset name]-[ordinal index]。</p>\n<p>而且这些编号都是从 0 开始累加，与 StatefulSet 的每个 Pod 实例一一对应，绝不重复。</p>\n<p>更重要的是，这些 Pod 的创建，也是严格按照编号顺序进行的。比如，在 web-0 进入到 Running 状态、并且细分状态（Conditions）成为 Ready 之前，web-1 会一直处于 Pending 状态。</p>\n<blockquote>\n<p>备注：Ready 状态再一次提醒了我们，为 Pod 设置 livenessProbe 和 readinessProbe 的重要性。</p>\n</blockquote>\n<p>当这两个 Pod 都进入了 Running 状态之后，你就可以查看到它们各自唯一的“网络身份”了。</p>\n<p>我们使用 kubectl exec 命令进入到容器中查看它们的 hostname：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> web-0 -- sh -c <span class=\"string\">&#x27;hostname&#x27;</span></span><br><span class=\"line\">web-0</span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> web-1 -- sh -c <span class=\"string\">&#x27;hostname&#x27;</span></span><br><span class=\"line\">web-1</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这两个 Pod 的 hostname 与 Pod 名字是一致的，都被分配了对应的编号。接下来，我们再试着以 DNS 的方式，访问一下这个 Headless Service：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl run -i --<span class=\"built_in\">tty</span> --image busybox:1.28.4 dns-test --restart=Never --<span class=\"built_in\">rm</span> /bin/sh </span><br></pre></td></tr></table></figure>\n\n<p>通过这条命令，我们启动了一个一次性的 Pod，因为 –rm 意味着 Pod 退出后就会被删除掉。然后，在这个 Pod 的容器里面，我们尝试用 nslookup 命令，解析一下 Pod 对应的 Headless Service：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl run -i --<span class=\"built_in\">tty</span> --image busybox:1.28.4 dns-test --restart=Never --<span class=\"built_in\">rm</span> /bin/sh</span><br><span class=\"line\">If you don<span class=\"string\">&#x27;t see a command prompt, try pressing enter.</span></span><br><span class=\"line\"><span class=\"string\">/ # nslookup web-0.nginx</span></span><br><span class=\"line\"><span class=\"string\">Server:    10.96.0.10</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Name:      web-0.nginx</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.44.0.5 web-0.nginx.default.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\">/ # nslookup web-1.nginx</span></span><br><span class=\"line\"><span class=\"string\">Server:    10.96.0.10</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Name:      web-1.nginx</span></span><br><span class=\"line\"><span class=\"string\">Address 1: 10.32.0.7 web-1.nginx.default.svc.cluster.local</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，在这个 StatefulSet 中，这两个新 Pod 的“网络标识”（比如：web-0.nginx 和 web-1.nginx），再次解析到了正确的 IP 地址（比如：web-0 Pod 的 IP 地址 10.44.0.5）。</p>\n<p>通过这种方法，Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来。此外，Kubernetes 还为每一个 Pod 提供了一个固定并且唯一的访问入口，即：这个 Pod 对应的 DNS 记录。</p>\n<p>这些状态，在 StatefulSet 的整个生命周期里都会保持不变，绝不会因为对应 Pod 的删除或者重新创建而失效。</p>\n<p>不过，相信你也已经注意到了，尽管 web-0.nginx 这条记录本身不会变，但它解析到的 Pod 的 IP 地址，并不是固定的。这就意味着，对于“有状态应用”实例的访问，你必须使用 DNS 记录或者 hostname 的方式，而绝不应该直接访问这些 Pod 的 IP 地址。</p>\n"},{"title":"java指令码 字节码 对别","date":"2019-04-03T03:45:52.000Z","_content":"\n###  java 【指令码】【子节码】 对比\n\n 指令从0x00-0xc9 没有0xba\n\n| **常量入栈指令**                 |                      |                                                              |                                                              |\n| -------------------------------- | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x01                             | aconst_null          |                                                              | null值入栈。                                                 |\n| 0x02                             | iconst_m1            |                                                              | -1(int)值入栈。                                              |\n| 0x03                             | iconst_0             |                                                              | 0(int)值入栈。                                               |\n| 0x04                             | iconst_1             |                                                              | 1(int)值入栈。                                               |\n| 0x05                             | iconst_2             |                                                              | 2(int)值入栈。                                               |\n| 0x06                             | iconst_3             |                                                              | 3(int)值入栈。                                               |\n| 0x07                             | iconst_4             |                                                              | 4(int)值入栈。                                               |\n| 0x08                             | iconst_5             |                                                              | 5(int)值入栈。                                               |\n| 0x09                             | lconst_0             |                                                              | 0(long)值入栈。                                              |\n| 0x0a                             | lconst_1             |                                                              | 1(long)值入栈。                                              |\n| 0x0b                             | fconst_0             |                                                              | 0(float)值入栈。                                             |\n| 0x0c                             | fconst_1             |                                                              | 1(float)值入栈。                                             |\n| 0x0d                             | fconst_2             |                                                              | 2(float)值入栈。                                             |\n| 0x0e                             | dconst_0             |                                                              | 0(double)值入栈。                                            |\n| 0x0f                             | dconst_1             |                                                              | 1(double)值入栈。                                            |\n| 0x10                             | bipush               | valuebyte                                                    | valuebyte值带符号扩展成int值入栈。                           |\n| 0x11                             | sipush               | valuebyte1 \t\t\tvaluebyte2                            | (valuebyte1 << 8) \\| valuebyte2 值带符号扩展成int值入栈。    |\n| 0x12                             | ldc                  | indexbyte1                                                   | 常量池中的常量值（int, float, string reference, object reference）入栈。 |\n| 0x13                             | ldc_w                | indexbyte1 \t\t\tindexbyte2                            | 常量池中常量（int, float, string reference, object reference）入栈。 |\n| 0x14                             | ldc2_w               | indexbyte1 \t\t\tindexbyte2                            | 常量池中常量（long, double）入栈。                           |\n|                                  |                      |                                                              |                                                              |\n| **局部变量值转载到栈中指令**     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x19                             | (wide)aload          | indexbyte                                                    | 从局部变量indexbyte中装载引用类型值入栈。                    |\n| 0x2a                             | aload_0              |                                                              | 从局部变量0中装载引用类型值入栈。                            |\n| 0x2b                             | aload_1              |                                                              | 从局部变量1中装载引用类型值入栈。                            |\n| 0x2c                             | aload_2              |                                                              | 从局部变量2中装载引用类型值入栈。                            |\n| 0x2d                             | aload_3              |                                                              | 从局部变量3中装载引用类型值入栈。                            |\n| 0x15                             | (wide)iload          | indexbyte                                                    | 从局部变量indexbyte中装载int类型值入栈。                     |\n| 0x1a                             | iload_0              |                                                              | 从局部变量0中装载int类型值入栈。                             |\n| 0x1b                             | iload_1              |                                                              | 从局部变量1中装载int类型值入栈。                             |\n| 0x1c                             | iload_2              |                                                              | 从局部变量2中装载int类型值入栈。                             |\n| 0x1d                             | iload_3              |                                                              | 从局部变量3中装载int类型值入栈。                             |\n| 0x16                             | (wide)lload          | indexbyte                                                    | 从局部变量indexbyte中装载long类型值入栈。                    |\n| 0x1e                             | lload_0              |                                                              | 从局部变量0中装载int类型值入栈。                             |\n| 0x1f                             | lload_1              |                                                              | 从局部变量1中装载int类型值入栈。                             |\n| 0x20                             | lload_2              |                                                              | 从局部变量2中装载int类型值入栈。                             |\n| 0x21                             | lload_3              |                                                              | 从局部变量3中装载int类型值入栈。                             |\n| 0x17                             | (wide)fload          | indexbyte                                                    | 从局部变量indexbyte中装载float类型值入栈。                   |\n| 0x22                             | fload_0              |                                                              | 从局部变量0中装载float类型值入栈。                           |\n| 0x23                             | fload_1              |                                                              | 从局部变量1中装载float类型值入栈。                           |\n| 0x24                             | fload_2              |                                                              | 从局部变量2中装载float类型值入栈。                           |\n| 0x25                             | fload_3              |                                                              | 从局部变量3中装载float类型值入栈。                           |\n| 0x18                             | (wide)dload          | indexbyte                                                    | 从局部变量indexbyte中装载double类型值入栈。                  |\n| 0x26                             | dload_0              |                                                              | 从局部变量0中装载double类型值入栈。                          |\n| 0x27                             | dload_1              |                                                              | 从局部变量1中装载double类型值入栈。                          |\n| 0x28                             | dload_2              |                                                              | 从局部变量2中装载double类型值入栈。                          |\n| 0x29                             | dload_3              |                                                              | 从局部变量3中装载double类型值入栈。                          |\n| 0x32                             | aaload               |                                                              | 从引用类型数组中装载指定项的值。                             |\n| 0x2e                             | iaload               |                                                              | 从int类型数组中装载指定项的值。                              |\n| 0x2f                             | laload               |                                                              | 从long类型数组中装载指定项的值。                             |\n| 0x30                             | faload               |                                                              | 从float类型数组中装载指定项的值。                            |\n| 0x31                             | daload               |                                                              | 从double类型数组中装载指定项的值。                           |\n| 0x33                             | baload               |                                                              | 从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |\n| 0x34                             | caload               |                                                              | 从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |\n| 0x35                             | saload               |                                                              | 从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |\n|                                  |                      |                                                              |                                                              |\n| **将栈顶值保存到局部变量中指令** |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x3a                             | (wide)astore         | indexbyte                                                    | 将栈顶引用类型值保存到局部变量indexbyte中。                  |\n| 0x4b                             | astroe_0             |                                                              | 将栈顶引用类型值保存到局部变量0中。                          |\n| 0x4c                             | astore_1             |                                                              | 将栈顶引用类型值保存到局部变量1中。                          |\n| 0x4d                             | astore_2             |                                                              | 将栈顶引用类型值保存到局部变量2中。                          |\n| 0x4e                             | astore_3             |                                                              | 将栈顶引用类型值保存到局部变量3中。                          |\n| 0x36                             | (wide)istore         | indexbyte                                                    | 将栈顶int类型值保存到局部变量indexbyte中。                   |\n| 0x3b                             | istore_0             |                                                              | 将栈顶int类型值保存到局部变量0中。                           |\n| 0x3c                             | istore_1             |                                                              | 将栈顶int类型值保存到局部变量1中。                           |\n| 0x3d                             | istore_2             |                                                              | 将栈顶int类型值保存到局部变量2中。                           |\n| 0x3e                             | istore_3             |                                                              | 将栈顶int类型值保存到局部变量3中。                           |\n| 0x37                             | (wide)lstore         | indexbyte                                                    | 将栈顶long类型值保存到局部变量indexbyte中。                  |\n| 0x3f                             | lstore_0             |                                                              | 将栈顶long类型值保存到局部变量0中。                          |\n| 0x40                             | lstore_1             |                                                              | 将栈顶long类型值保存到局部变量1中。                          |\n| 0x41                             | lstore_2             |                                                              | 将栈顶long类型值保存到局部变量2中。                          |\n| 0x42                             | lstroe_3             |                                                              | 将栈顶long类型值保存到局部变量3中。                          |\n| 0x38                             | (wide)fstore         | indexbyte                                                    | 将栈顶float类型值保存到局部变量indexbyte中。                 |\n| 0x43                             | fstore_0             |                                                              | 将栈顶float类型值保存到局部变量0中。                         |\n| 0x44                             | fstore_1             |                                                              | 将栈顶float类型值保存到局部变量1中。                         |\n| 0x45                             | fstore_2             |                                                              | 将栈顶float类型值保存到局部变量2中。                         |\n| 0x46                             | fstore_3             |                                                              | 将栈顶float类型值保存到局部变量3中。                         |\n| 0x39                             | (wide)dstore         | indexbyte                                                    | 将栈顶double类型值保存到局部变量indexbyte中。                |\n| 0x47                             | dstore_0             |                                                              | 将栈顶double类型值保存到局部变量0中。                        |\n| 0x48                             | dstore_1             |                                                              | 将栈顶double类型值保存到局部变量1中。                        |\n| 0x49                             | dstore_2             |                                                              | 将栈顶double类型值保存到局部变量2中。                        |\n| 0x4a                             | dstore_3             |                                                              | 将栈顶double类型值保存到局部变量3中。                        |\n| 0x53                             | aastore              |                                                              | 将栈顶引用类型值保存到指定引用类型数组的指定项。             |\n| 0x4f                             | iastore              |                                                              | 将栈顶int类型值保存到指定int类型数组的指定项。               |\n| 0x50                             | lastore              |                                                              | 将栈顶long类型值保存到指定long类型数组的指定项。             |\n| 0x51                             | fastore              |                                                              | 将栈顶float类型值保存到指定float类型数组的指定项。           |\n| 0x52                             | dastore              |                                                              | 将栈顶double类型值保存到指定double类型数组的指定项。         |\n| 0x54                             | bastroe              |                                                              | 将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。 |\n| 0x55                             | castore              |                                                              | 将栈顶char类型值保存到指定char类型数组的指定项。             |\n| 0x56                             | sastore              |                                                              | 将栈顶short类型值保存到指定short类型数组的指定项。           |\n|                                  |                      |                                                              |                                                              |\n| **wide指令**                     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xc4                             | wide                 |                                                              | 使用附加字节扩展局部变量索引（iinc指令特殊）。               |\n|                                  |                      |                                                              |                                                              |\n| **通用（无类型）栈操作指令**     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x00                             | nop                  |                                                              | 空操作。                                                     |\n| 0x57                             | pop                  |                                                              | 从栈顶弹出一个字长的数据。                                   |\n| 0x58                             | pop2                 |                                                              | 从栈顶弹出两个字长的数据。                                   |\n| 0x59                             | dup                  |                                                              | 复制栈顶一个字长的数据，将复制后的数据压栈。                 |\n| 0x5a                             | dup_x1               |                                                              | 复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。 |\n| 0x5b                             | dup_x2               |                                                              | 复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。 |\n| 0x5c                             | dup2                 |                                                              | 复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。       |\n| 0x5d                             | dup2_x1              |                                                              | 复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。 |\n| 0x5e                             | dup2_x2              |                                                              | 复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。 |\n| 0x5f                             | swap                 |                                                              | 交换栈顶两个字长的数据的位置。[Java](http://lib.csdn.net/base/javaee)指令中没有提供以两个字长为单位的交换指令。 |\n|                                  |                      |                                                              |                                                              |\n| **类型转换指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x86                             | i2f                  |                                                              | 将栈顶int类型值转换为float类型值。                           |\n| 0x85                             | i2l                  |                                                              | 将栈顶int类型值转换为long类型值。                            |\n| 0x87                             | i2d                  |                                                              | 将栈顶int类型值转换为double类型值。                          |\n| 0x8b                             | f2i                  |                                                              | 将栈顶float类型值转换为int类型值。                           |\n| 0x8c                             | f2l                  |                                                              | 将栈顶float类型值转换为long类型值。                          |\n| 0x8d                             | f2d                  |                                                              | 将栈顶float类型值转换为double类型值。                        |\n| 0x88                             | l2i                  |                                                              | 将栈顶long类型值转换为int类型值。                            |\n| 0x89                             | l2f                  |                                                              | 将栈顶long类型值转换为float类型值。                          |\n| 0x8a                             | l2d                  |                                                              | 将栈顶long类型值转换double类型值。                           |\n| 0x8e                             | d2i                  |                                                              | 将栈顶double类型值转换为int类型值。                          |\n| 0x90                             | d2f                  |                                                              | 将栈顶double类型值转换为float类型值。                        |\n| 0x8f                             | d2l                  |                                                              | 将栈顶double类型值转换为long类型值。                         |\n| 0x91                             | i2b                  |                                                              | 将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。 |\n| 0x92                             | i2c                  |                                                              | 将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。 |\n| 0x93                             | i2s                  |                                                              | 将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。 |\n|                                  |                      |                                                              |                                                              |\n| **整数运算**                     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x60                             | iadd                 |                                                              | 将栈顶两int类型数相加，结果入栈。                            |\n| 0x64                             | isub                 |                                                              | 将栈顶两int类型数相减，结果入栈。                            |\n| 0x68                             | imul                 |                                                              | 将栈顶两int类型数相乘，结果入栈。                            |\n| 0x6c                             | idiv                 |                                                              | 将栈顶两int类型数相除，结果入栈。                            |\n| 0x70                             | irem                 |                                                              | 将栈顶两int类型数取模，结果入栈。                            |\n| 0x74                             | ineg                 |                                                              | 将栈顶int类型值取负，结果入栈。                              |\n| 0x61                             | ladd                 |                                                              | 将栈顶两long类型数相加，结果入栈。                           |\n| 0x65                             | lsub                 |                                                              | 将栈顶两long类型数相减，结果入栈。                           |\n| 0x69                             | lmul                 |                                                              | 将栈顶两long类型数相乘，结果入栈。                           |\n| 0x6d                             | ldiv                 |                                                              | 将栈顶两long类型数相除，结果入栈。                           |\n| 0x71                             | lrem                 |                                                              | 将栈顶两long类型数取模，结果入栈。                           |\n| 0x75                             | lneg                 |                                                              | 将栈顶long类型值取负，结果入栈。                             |\n| 0x84                             | (wide)iinc           | indexbyte \t\t\tconstbyte                              | 将整数值constbyte加到indexbyte指定的int类型的局部变量中。    |\n|                                  |                      |                                                              |                                                              |\n| **浮点运算**                     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x62                             | fadd                 |                                                              | 将栈顶两float类型数相加，结果入栈。                          |\n| 0x66                             | fsub                 |                                                              | 将栈顶两float类型数相减，结果入栈。                          |\n| 0x6a                             | fmul                 |                                                              | 将栈顶两float类型数相乘，结果入栈。                          |\n| 0x6e                             | fdiv                 |                                                              | 将栈顶两float类型数相除，结果入栈。                          |\n| 0x72                             | frem                 |                                                              | 将栈顶两float类型数取模，结果入栈。                          |\n| 0x76                             | fneg                 |                                                              | 将栈顶float类型值取反，结果入栈。                            |\n| 0x63                             | dadd                 |                                                              | 将栈顶两double类型数相加，结果入栈。                         |\n| 0x67                             | dsub                 |                                                              | 将栈顶两double类型数相减，结果入栈。                         |\n| 0x6b                             | dmul                 |                                                              | 将栈顶两double类型数相乘，结果入栈。                         |\n| 0x6f                             | ddiv                 |                                                              | 将栈顶两double类型数相除，结果入栈。                         |\n| 0x73                             | drem                 |                                                              | 将栈顶两double类型数取模，结果入栈。                         |\n| 0x77                             | dneg                 |                                                              | 将栈顶double类型值取负，结果入栈。                           |\n|                                  |                      |                                                              |                                                              |\n| **逻辑运算——移位运算**           |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x78                             | ishl                 |                                                              | 左移int类型值。                                              |\n| 0x79                             | lshl                 |                                                              | 左移long类型值。                                             |\n| 0x7a                             | ishr                 |                                                              | 算术右移int类型值。                                          |\n| 0x7b                             | lshr                 |                                                              | 算术右移long类型值。                                         |\n| 0x7c                             | iushr                |                                                              | 逻辑右移int类型值。                                          |\n| 0x7d                             | lushr                |                                                              | 逻辑右移long类型值。                                         |\n|                                  |                      |                                                              |                                                              |\n| **逻辑运算——按位布尔运算**       |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x73                             | iand                 |                                                              | 对int类型按位与运算。                                        |\n| 0x7f                             | land                 |                                                              | 对long类型的按位与运算。                                     |\n| 0x80                             | ior                  |                                                              | 对int类型的按位或运算。                                      |\n| 0x81                             | lor                  |                                                              | 对long类型的按位或运算。                                     |\n| 0x82                             | ixor                 |                                                              | 对int类型的按位异或运算。                                    |\n| 0x83                             | lxor                 |                                                              | 对long类型的按位异或运算。                                   |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——条件跳转指令**     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x99                             | ifeq                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值为0则跳转。                                   |\n| 0x9a                             | ifne                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值不为0则跳转。                                 |\n| 0x9b                             | iflt                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值小于0则跳转。                                 |\n| 0x9e                             | ifle                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值小于等于0则跳转。                             |\n| 0x9d                             | ifgt                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值大于0则跳转。                                 |\n| 0x9c                             | ifge                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值大于等于0则跳转。                             |\n| 0x9f                             | if_icmpeq            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值相等则跳转。                                |\n| 0xa0                             | if_icmpne            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值不相等则跳转。                              |\n| 0xa1                             | if_icmplt            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前小于后则跳转。                            |\n| 0xa4                             | if_icmple            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前小于等于后则跳转。                        |\n| 0xa3                             | if_icmpgt            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前大于后则跳转。                            |\n| 0xa2                             | if_icmpge            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前大于等于后则跳转。                        |\n| 0xc6                             | ifnull               | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶引用值为null则跳转。                                   |\n| 0xc7                             | ifnonnull            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶引用值不为null则跳转。                                 |\n| 0xa5                             | if_acmpeq            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两引用类型值相等则跳转。                               |\n| 0xa6                             | if_acmpne            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两引用类型值不相等则跳转。                             |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——比较指令**         |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x94                             | lcmp                 |                                                              | 比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。 |\n| 0x95                             | fcmpl                |                                                              | 比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n| 0x96                             | fcmpg                |                                                              | 比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n| 0x97                             | dcmpl                |                                                              | 比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n| 0x98                             | dcmpg                |                                                              | 比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——无条件跳转指令**   |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xa7                             | goto                 | branchbyte1 \t\t\tbranchbyte2                          | 无条件跳转到指定位置。                                       |\n| 0xc8                             | goto_w               | branchbyte1 \t\t\tbranchbyte2 \t\t\tbranchbyte3 \t\t\tbranchbyte4 | 无条件跳转到指定位置（宽索引）。                             |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——表跳转指令**       |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xaa                             | tableswitch          | <0-3bytepad> \t\t\tdefaultbyte1 \t\t\tdefaultbyte2 \t\t\tdefaultbyte3 \t\t\tdefaultbyte4 \t\t\tlowbyte1 \t\t\tlowbyte2 \t\t\tlowbyte3 \t\t\tlowbyte4 \t\t\thighbyte1 \t\t\thighbyte2 \t\t\thighbyte3 \t\t\thighbyte4 \t\t\tjump offsets... | 通过索引访问跳转表，并跳转。                                 |\n| 0xab                             | lookupswitch         | <0-3bytepad> \t\t\tdefaultbyte1 \t\t\tdefaultbyte2 \t\t\tdefaultbyte3 \t\t\tdefaultbyte4 \t\t\tnpairs1 \t\t\tnpairs2 \t\t\tnpairs3 \t\t\tnpairs4 \t\t\tmatch offsets | 通过键值访问跳转表，并跳转。                                 |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——异常和finally**    |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xbf                             | athrow               |                                                              | 抛出异常。                                                   |\n| 0xa8                             | jsr                  | branchbyte1 \t\t\tbranchbyte2                          | 跳转到子例程序。                                             |\n| 0xc9                             | jsr_w                | branchbyte1 \t\t\tbranchbyte2 \t\t\tbranchbyte3 \t\t\tbranchbyte4 | 跳转到子例程序（宽索引）。                                   |\n| 0xa9                             | (wide)ret            | indexbyte                                                    | 返回子例程序。                                               |\n|                                  |                      |                                                              |                                                              |\n| **对象操作指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xbb                             | new                  | indexbyte1 \t\t\tindexbyte2                            | 创建新的对象实例。                                           |\n| 0xc0                             | checkcast            | indexbyte1 \t\t\tindexbyte                             | 类型强转。                                                   |\n| 0xc1                             | instanceof           | indexbyte1 \t\t\tindexbyte2                            | 判断类型。                                                   |\n| 0xb4                             | getfield             | indexbyte1 \t\t\tindexbyte2                            | 获取对象字段的值。                                           |\n| 0xb5                             | putfield             | indexbyte1 \t\t\tindexbyte2                            | 给对象字段赋值。                                             |\n| 0xb2                             | getstatic            | indexbyte1 \t\t\tindexbyte2                            | 获取静态字段的值。                                           |\n| 0xb3                             | putstatic            | indexbyte1 \t\t\tindexbyte2                            | 给静态字段赋值。                                             |\n|                                  |                      |                                                              |                                                              |\n| **数组操作指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xbc                             | newarray             | atype                                                        | 创建type类型的数组。                                         |\n| 0xbd                             | anewarray            | indexbyte1 \t\t\tindexbyte2                            | 创建引用类型的数组。                                         |\n| 0xbe                             | arraylength          |                                                              | 获取一维数组的长度。                                         |\n| 0xc5                             | multianewarray       | indexbyte1 \t\t\tindexbyte2 \t\t\tdimension      | 创建dimension维度的数组。                                    |\n|                                  |                      |                                                              |                                                              |\n| **方法调用指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xb7                             | invokespecial        | indexbyte1 \t\t\tindexbyte2                            | 编译时方法绑定调用方法。                                     |\n| 0xb6                             | invokevirtual        | indexbyte1 \t\t\tindexbyte2                            | 运行时方法绑定调用方法。                                     |\n| 0xb8                             | invokestatic         | indexbyte1 \t\t\tindexbyte2                            | 调用静态方法。                                               |\n| 0xb9                             | invokeinterface      | indexbyte1 \t\t\tindexbyte2 \t\t\tcount \t\t\t0 | 调用接口方法。                                               |\n|                                  |                      |                                                              |                                                              |\n| **方法返回指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xac                             | ireturn              |                                                              | 返回int类型值。                                              |\n| 0xad                             | lreturn              |                                                              | 返回long类型值。                                             |\n| 0xae                             | freturn              |                                                              | 返回float类型值。                                            |\n| 0xaf                             | dreturn              |                                                              | 返回double类型值。                                           |\n| 0xb0                             | areturn              |                                                              | 返回引用类型值。                                             |\n| 0xb1                             | return               |                                                              | void函数返回。                                               |\n|                                  |                      |                                                              |                                                              |\n| **线程同步指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xc2                             | monitorenter         |                                                              | 进入并获得对象监视器。                                       |\n| 0xc3                             | monitorexit          |                                                              | 释放并退出对象监视器。                                       |\n","source":"_posts/java指令码-字节码-对别.md","raw":"---\ntitle: java指令码 字节码 对别\ndate: 2019-04-03 11:45:52\ncategories:\n    - jvm\ntags: [jvm]\n---\n\n###  java 【指令码】【子节码】 对比\n\n 指令从0x00-0xc9 没有0xba\n\n| **常量入栈指令**                 |                      |                                                              |                                                              |\n| -------------------------------- | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x01                             | aconst_null          |                                                              | null值入栈。                                                 |\n| 0x02                             | iconst_m1            |                                                              | -1(int)值入栈。                                              |\n| 0x03                             | iconst_0             |                                                              | 0(int)值入栈。                                               |\n| 0x04                             | iconst_1             |                                                              | 1(int)值入栈。                                               |\n| 0x05                             | iconst_2             |                                                              | 2(int)值入栈。                                               |\n| 0x06                             | iconst_3             |                                                              | 3(int)值入栈。                                               |\n| 0x07                             | iconst_4             |                                                              | 4(int)值入栈。                                               |\n| 0x08                             | iconst_5             |                                                              | 5(int)值入栈。                                               |\n| 0x09                             | lconst_0             |                                                              | 0(long)值入栈。                                              |\n| 0x0a                             | lconst_1             |                                                              | 1(long)值入栈。                                              |\n| 0x0b                             | fconst_0             |                                                              | 0(float)值入栈。                                             |\n| 0x0c                             | fconst_1             |                                                              | 1(float)值入栈。                                             |\n| 0x0d                             | fconst_2             |                                                              | 2(float)值入栈。                                             |\n| 0x0e                             | dconst_0             |                                                              | 0(double)值入栈。                                            |\n| 0x0f                             | dconst_1             |                                                              | 1(double)值入栈。                                            |\n| 0x10                             | bipush               | valuebyte                                                    | valuebyte值带符号扩展成int值入栈。                           |\n| 0x11                             | sipush               | valuebyte1 \t\t\tvaluebyte2                            | (valuebyte1 << 8) \\| valuebyte2 值带符号扩展成int值入栈。    |\n| 0x12                             | ldc                  | indexbyte1                                                   | 常量池中的常量值（int, float, string reference, object reference）入栈。 |\n| 0x13                             | ldc_w                | indexbyte1 \t\t\tindexbyte2                            | 常量池中常量（int, float, string reference, object reference）入栈。 |\n| 0x14                             | ldc2_w               | indexbyte1 \t\t\tindexbyte2                            | 常量池中常量（long, double）入栈。                           |\n|                                  |                      |                                                              |                                                              |\n| **局部变量值转载到栈中指令**     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x19                             | (wide)aload          | indexbyte                                                    | 从局部变量indexbyte中装载引用类型值入栈。                    |\n| 0x2a                             | aload_0              |                                                              | 从局部变量0中装载引用类型值入栈。                            |\n| 0x2b                             | aload_1              |                                                              | 从局部变量1中装载引用类型值入栈。                            |\n| 0x2c                             | aload_2              |                                                              | 从局部变量2中装载引用类型值入栈。                            |\n| 0x2d                             | aload_3              |                                                              | 从局部变量3中装载引用类型值入栈。                            |\n| 0x15                             | (wide)iload          | indexbyte                                                    | 从局部变量indexbyte中装载int类型值入栈。                     |\n| 0x1a                             | iload_0              |                                                              | 从局部变量0中装载int类型值入栈。                             |\n| 0x1b                             | iload_1              |                                                              | 从局部变量1中装载int类型值入栈。                             |\n| 0x1c                             | iload_2              |                                                              | 从局部变量2中装载int类型值入栈。                             |\n| 0x1d                             | iload_3              |                                                              | 从局部变量3中装载int类型值入栈。                             |\n| 0x16                             | (wide)lload          | indexbyte                                                    | 从局部变量indexbyte中装载long类型值入栈。                    |\n| 0x1e                             | lload_0              |                                                              | 从局部变量0中装载int类型值入栈。                             |\n| 0x1f                             | lload_1              |                                                              | 从局部变量1中装载int类型值入栈。                             |\n| 0x20                             | lload_2              |                                                              | 从局部变量2中装载int类型值入栈。                             |\n| 0x21                             | lload_3              |                                                              | 从局部变量3中装载int类型值入栈。                             |\n| 0x17                             | (wide)fload          | indexbyte                                                    | 从局部变量indexbyte中装载float类型值入栈。                   |\n| 0x22                             | fload_0              |                                                              | 从局部变量0中装载float类型值入栈。                           |\n| 0x23                             | fload_1              |                                                              | 从局部变量1中装载float类型值入栈。                           |\n| 0x24                             | fload_2              |                                                              | 从局部变量2中装载float类型值入栈。                           |\n| 0x25                             | fload_3              |                                                              | 从局部变量3中装载float类型值入栈。                           |\n| 0x18                             | (wide)dload          | indexbyte                                                    | 从局部变量indexbyte中装载double类型值入栈。                  |\n| 0x26                             | dload_0              |                                                              | 从局部变量0中装载double类型值入栈。                          |\n| 0x27                             | dload_1              |                                                              | 从局部变量1中装载double类型值入栈。                          |\n| 0x28                             | dload_2              |                                                              | 从局部变量2中装载double类型值入栈。                          |\n| 0x29                             | dload_3              |                                                              | 从局部变量3中装载double类型值入栈。                          |\n| 0x32                             | aaload               |                                                              | 从引用类型数组中装载指定项的值。                             |\n| 0x2e                             | iaload               |                                                              | 从int类型数组中装载指定项的值。                              |\n| 0x2f                             | laload               |                                                              | 从long类型数组中装载指定项的值。                             |\n| 0x30                             | faload               |                                                              | 从float类型数组中装载指定项的值。                            |\n| 0x31                             | daload               |                                                              | 从double类型数组中装载指定项的值。                           |\n| 0x33                             | baload               |                                                              | 从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |\n| 0x34                             | caload               |                                                              | 从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |\n| 0x35                             | saload               |                                                              | 从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |\n|                                  |                      |                                                              |                                                              |\n| **将栈顶值保存到局部变量中指令** |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x3a                             | (wide)astore         | indexbyte                                                    | 将栈顶引用类型值保存到局部变量indexbyte中。                  |\n| 0x4b                             | astroe_0             |                                                              | 将栈顶引用类型值保存到局部变量0中。                          |\n| 0x4c                             | astore_1             |                                                              | 将栈顶引用类型值保存到局部变量1中。                          |\n| 0x4d                             | astore_2             |                                                              | 将栈顶引用类型值保存到局部变量2中。                          |\n| 0x4e                             | astore_3             |                                                              | 将栈顶引用类型值保存到局部变量3中。                          |\n| 0x36                             | (wide)istore         | indexbyte                                                    | 将栈顶int类型值保存到局部变量indexbyte中。                   |\n| 0x3b                             | istore_0             |                                                              | 将栈顶int类型值保存到局部变量0中。                           |\n| 0x3c                             | istore_1             |                                                              | 将栈顶int类型值保存到局部变量1中。                           |\n| 0x3d                             | istore_2             |                                                              | 将栈顶int类型值保存到局部变量2中。                           |\n| 0x3e                             | istore_3             |                                                              | 将栈顶int类型值保存到局部变量3中。                           |\n| 0x37                             | (wide)lstore         | indexbyte                                                    | 将栈顶long类型值保存到局部变量indexbyte中。                  |\n| 0x3f                             | lstore_0             |                                                              | 将栈顶long类型值保存到局部变量0中。                          |\n| 0x40                             | lstore_1             |                                                              | 将栈顶long类型值保存到局部变量1中。                          |\n| 0x41                             | lstore_2             |                                                              | 将栈顶long类型值保存到局部变量2中。                          |\n| 0x42                             | lstroe_3             |                                                              | 将栈顶long类型值保存到局部变量3中。                          |\n| 0x38                             | (wide)fstore         | indexbyte                                                    | 将栈顶float类型值保存到局部变量indexbyte中。                 |\n| 0x43                             | fstore_0             |                                                              | 将栈顶float类型值保存到局部变量0中。                         |\n| 0x44                             | fstore_1             |                                                              | 将栈顶float类型值保存到局部变量1中。                         |\n| 0x45                             | fstore_2             |                                                              | 将栈顶float类型值保存到局部变量2中。                         |\n| 0x46                             | fstore_3             |                                                              | 将栈顶float类型值保存到局部变量3中。                         |\n| 0x39                             | (wide)dstore         | indexbyte                                                    | 将栈顶double类型值保存到局部变量indexbyte中。                |\n| 0x47                             | dstore_0             |                                                              | 将栈顶double类型值保存到局部变量0中。                        |\n| 0x48                             | dstore_1             |                                                              | 将栈顶double类型值保存到局部变量1中。                        |\n| 0x49                             | dstore_2             |                                                              | 将栈顶double类型值保存到局部变量2中。                        |\n| 0x4a                             | dstore_3             |                                                              | 将栈顶double类型值保存到局部变量3中。                        |\n| 0x53                             | aastore              |                                                              | 将栈顶引用类型值保存到指定引用类型数组的指定项。             |\n| 0x4f                             | iastore              |                                                              | 将栈顶int类型值保存到指定int类型数组的指定项。               |\n| 0x50                             | lastore              |                                                              | 将栈顶long类型值保存到指定long类型数组的指定项。             |\n| 0x51                             | fastore              |                                                              | 将栈顶float类型值保存到指定float类型数组的指定项。           |\n| 0x52                             | dastore              |                                                              | 将栈顶double类型值保存到指定double类型数组的指定项。         |\n| 0x54                             | bastroe              |                                                              | 将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。 |\n| 0x55                             | castore              |                                                              | 将栈顶char类型值保存到指定char类型数组的指定项。             |\n| 0x56                             | sastore              |                                                              | 将栈顶short类型值保存到指定short类型数组的指定项。           |\n|                                  |                      |                                                              |                                                              |\n| **wide指令**                     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xc4                             | wide                 |                                                              | 使用附加字节扩展局部变量索引（iinc指令特殊）。               |\n|                                  |                      |                                                              |                                                              |\n| **通用（无类型）栈操作指令**     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x00                             | nop                  |                                                              | 空操作。                                                     |\n| 0x57                             | pop                  |                                                              | 从栈顶弹出一个字长的数据。                                   |\n| 0x58                             | pop2                 |                                                              | 从栈顶弹出两个字长的数据。                                   |\n| 0x59                             | dup                  |                                                              | 复制栈顶一个字长的数据，将复制后的数据压栈。                 |\n| 0x5a                             | dup_x1               |                                                              | 复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。 |\n| 0x5b                             | dup_x2               |                                                              | 复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。 |\n| 0x5c                             | dup2                 |                                                              | 复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。       |\n| 0x5d                             | dup2_x1              |                                                              | 复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。 |\n| 0x5e                             | dup2_x2              |                                                              | 复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。 |\n| 0x5f                             | swap                 |                                                              | 交换栈顶两个字长的数据的位置。[Java](http://lib.csdn.net/base/javaee)指令中没有提供以两个字长为单位的交换指令。 |\n|                                  |                      |                                                              |                                                              |\n| **类型转换指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x86                             | i2f                  |                                                              | 将栈顶int类型值转换为float类型值。                           |\n| 0x85                             | i2l                  |                                                              | 将栈顶int类型值转换为long类型值。                            |\n| 0x87                             | i2d                  |                                                              | 将栈顶int类型值转换为double类型值。                          |\n| 0x8b                             | f2i                  |                                                              | 将栈顶float类型值转换为int类型值。                           |\n| 0x8c                             | f2l                  |                                                              | 将栈顶float类型值转换为long类型值。                          |\n| 0x8d                             | f2d                  |                                                              | 将栈顶float类型值转换为double类型值。                        |\n| 0x88                             | l2i                  |                                                              | 将栈顶long类型值转换为int类型值。                            |\n| 0x89                             | l2f                  |                                                              | 将栈顶long类型值转换为float类型值。                          |\n| 0x8a                             | l2d                  |                                                              | 将栈顶long类型值转换double类型值。                           |\n| 0x8e                             | d2i                  |                                                              | 将栈顶double类型值转换为int类型值。                          |\n| 0x90                             | d2f                  |                                                              | 将栈顶double类型值转换为float类型值。                        |\n| 0x8f                             | d2l                  |                                                              | 将栈顶double类型值转换为long类型值。                         |\n| 0x91                             | i2b                  |                                                              | 将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。 |\n| 0x92                             | i2c                  |                                                              | 将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。 |\n| 0x93                             | i2s                  |                                                              | 将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。 |\n|                                  |                      |                                                              |                                                              |\n| **整数运算**                     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x60                             | iadd                 |                                                              | 将栈顶两int类型数相加，结果入栈。                            |\n| 0x64                             | isub                 |                                                              | 将栈顶两int类型数相减，结果入栈。                            |\n| 0x68                             | imul                 |                                                              | 将栈顶两int类型数相乘，结果入栈。                            |\n| 0x6c                             | idiv                 |                                                              | 将栈顶两int类型数相除，结果入栈。                            |\n| 0x70                             | irem                 |                                                              | 将栈顶两int类型数取模，结果入栈。                            |\n| 0x74                             | ineg                 |                                                              | 将栈顶int类型值取负，结果入栈。                              |\n| 0x61                             | ladd                 |                                                              | 将栈顶两long类型数相加，结果入栈。                           |\n| 0x65                             | lsub                 |                                                              | 将栈顶两long类型数相减，结果入栈。                           |\n| 0x69                             | lmul                 |                                                              | 将栈顶两long类型数相乘，结果入栈。                           |\n| 0x6d                             | ldiv                 |                                                              | 将栈顶两long类型数相除，结果入栈。                           |\n| 0x71                             | lrem                 |                                                              | 将栈顶两long类型数取模，结果入栈。                           |\n| 0x75                             | lneg                 |                                                              | 将栈顶long类型值取负，结果入栈。                             |\n| 0x84                             | (wide)iinc           | indexbyte \t\t\tconstbyte                              | 将整数值constbyte加到indexbyte指定的int类型的局部变量中。    |\n|                                  |                      |                                                              |                                                              |\n| **浮点运算**                     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x62                             | fadd                 |                                                              | 将栈顶两float类型数相加，结果入栈。                          |\n| 0x66                             | fsub                 |                                                              | 将栈顶两float类型数相减，结果入栈。                          |\n| 0x6a                             | fmul                 |                                                              | 将栈顶两float类型数相乘，结果入栈。                          |\n| 0x6e                             | fdiv                 |                                                              | 将栈顶两float类型数相除，结果入栈。                          |\n| 0x72                             | frem                 |                                                              | 将栈顶两float类型数取模，结果入栈。                          |\n| 0x76                             | fneg                 |                                                              | 将栈顶float类型值取反，结果入栈。                            |\n| 0x63                             | dadd                 |                                                              | 将栈顶两double类型数相加，结果入栈。                         |\n| 0x67                             | dsub                 |                                                              | 将栈顶两double类型数相减，结果入栈。                         |\n| 0x6b                             | dmul                 |                                                              | 将栈顶两double类型数相乘，结果入栈。                         |\n| 0x6f                             | ddiv                 |                                                              | 将栈顶两double类型数相除，结果入栈。                         |\n| 0x73                             | drem                 |                                                              | 将栈顶两double类型数取模，结果入栈。                         |\n| 0x77                             | dneg                 |                                                              | 将栈顶double类型值取负，结果入栈。                           |\n|                                  |                      |                                                              |                                                              |\n| **逻辑运算——移位运算**           |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x78                             | ishl                 |                                                              | 左移int类型值。                                              |\n| 0x79                             | lshl                 |                                                              | 左移long类型值。                                             |\n| 0x7a                             | ishr                 |                                                              | 算术右移int类型值。                                          |\n| 0x7b                             | lshr                 |                                                              | 算术右移long类型值。                                         |\n| 0x7c                             | iushr                |                                                              | 逻辑右移int类型值。                                          |\n| 0x7d                             | lushr                |                                                              | 逻辑右移long类型值。                                         |\n|                                  |                      |                                                              |                                                              |\n| **逻辑运算——按位布尔运算**       |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x73                             | iand                 |                                                              | 对int类型按位与运算。                                        |\n| 0x7f                             | land                 |                                                              | 对long类型的按位与运算。                                     |\n| 0x80                             | ior                  |                                                              | 对int类型的按位或运算。                                      |\n| 0x81                             | lor                  |                                                              | 对long类型的按位或运算。                                     |\n| 0x82                             | ixor                 |                                                              | 对int类型的按位异或运算。                                    |\n| 0x83                             | lxor                 |                                                              | 对long类型的按位异或运算。                                   |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——条件跳转指令**     |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x99                             | ifeq                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值为0则跳转。                                   |\n| 0x9a                             | ifne                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值不为0则跳转。                                 |\n| 0x9b                             | iflt                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值小于0则跳转。                                 |\n| 0x9e                             | ifle                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值小于等于0则跳转。                             |\n| 0x9d                             | ifgt                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值大于0则跳转。                                 |\n| 0x9c                             | ifge                 | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶int类型值大于等于0则跳转。                             |\n| 0x9f                             | if_icmpeq            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值相等则跳转。                                |\n| 0xa0                             | if_icmpne            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值不相等则跳转。                              |\n| 0xa1                             | if_icmplt            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前小于后则跳转。                            |\n| 0xa4                             | if_icmple            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前小于等于后则跳转。                        |\n| 0xa3                             | if_icmpgt            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前大于后则跳转。                            |\n| 0xa2                             | if_icmpge            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两int类型值前大于等于后则跳转。                        |\n| 0xc6                             | ifnull               | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶引用值为null则跳转。                                   |\n| 0xc7                             | ifnonnull            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶引用值不为null则跳转。                                 |\n| 0xa5                             | if_acmpeq            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两引用类型值相等则跳转。                               |\n| 0xa6                             | if_acmpne            | branchbyte1 \t\t\tbranchbyte2                          | 若栈顶两引用类型值不相等则跳转。                             |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——比较指令**         |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0x94                             | lcmp                 |                                                              | 比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。 |\n| 0x95                             | fcmpl                |                                                              | 比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n| 0x96                             | fcmpg                |                                                              | 比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n| 0x97                             | dcmpl                |                                                              | 比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n| 0x98                             | dcmpg                |                                                              | 比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。 |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——无条件跳转指令**   |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xa7                             | goto                 | branchbyte1 \t\t\tbranchbyte2                          | 无条件跳转到指定位置。                                       |\n| 0xc8                             | goto_w               | branchbyte1 \t\t\tbranchbyte2 \t\t\tbranchbyte3 \t\t\tbranchbyte4 | 无条件跳转到指定位置（宽索引）。                             |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——表跳转指令**       |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xaa                             | tableswitch          | <0-3bytepad> \t\t\tdefaultbyte1 \t\t\tdefaultbyte2 \t\t\tdefaultbyte3 \t\t\tdefaultbyte4 \t\t\tlowbyte1 \t\t\tlowbyte2 \t\t\tlowbyte3 \t\t\tlowbyte4 \t\t\thighbyte1 \t\t\thighbyte2 \t\t\thighbyte3 \t\t\thighbyte4 \t\t\tjump offsets... | 通过索引访问跳转表，并跳转。                                 |\n| 0xab                             | lookupswitch         | <0-3bytepad> \t\t\tdefaultbyte1 \t\t\tdefaultbyte2 \t\t\tdefaultbyte3 \t\t\tdefaultbyte4 \t\t\tnpairs1 \t\t\tnpairs2 \t\t\tnpairs3 \t\t\tnpairs4 \t\t\tmatch offsets | 通过键值访问跳转表，并跳转。                                 |\n|                                  |                      |                                                              |                                                              |\n| **控制流指令——异常和finally**    |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xbf                             | athrow               |                                                              | 抛出异常。                                                   |\n| 0xa8                             | jsr                  | branchbyte1 \t\t\tbranchbyte2                          | 跳转到子例程序。                                             |\n| 0xc9                             | jsr_w                | branchbyte1 \t\t\tbranchbyte2 \t\t\tbranchbyte3 \t\t\tbranchbyte4 | 跳转到子例程序（宽索引）。                                   |\n| 0xa9                             | (wide)ret            | indexbyte                                                    | 返回子例程序。                                               |\n|                                  |                      |                                                              |                                                              |\n| **对象操作指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xbb                             | new                  | indexbyte1 \t\t\tindexbyte2                            | 创建新的对象实例。                                           |\n| 0xc0                             | checkcast            | indexbyte1 \t\t\tindexbyte                             | 类型强转。                                                   |\n| 0xc1                             | instanceof           | indexbyte1 \t\t\tindexbyte2                            | 判断类型。                                                   |\n| 0xb4                             | getfield             | indexbyte1 \t\t\tindexbyte2                            | 获取对象字段的值。                                           |\n| 0xb5                             | putfield             | indexbyte1 \t\t\tindexbyte2                            | 给对象字段赋值。                                             |\n| 0xb2                             | getstatic            | indexbyte1 \t\t\tindexbyte2                            | 获取静态字段的值。                                           |\n| 0xb3                             | putstatic            | indexbyte1 \t\t\tindexbyte2                            | 给静态字段赋值。                                             |\n|                                  |                      |                                                              |                                                              |\n| **数组操作指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xbc                             | newarray             | atype                                                        | 创建type类型的数组。                                         |\n| 0xbd                             | anewarray            | indexbyte1 \t\t\tindexbyte2                            | 创建引用类型的数组。                                         |\n| 0xbe                             | arraylength          |                                                              | 获取一维数组的长度。                                         |\n| 0xc5                             | multianewarray       | indexbyte1 \t\t\tindexbyte2 \t\t\tdimension      | 创建dimension维度的数组。                                    |\n|                                  |                      |                                                              |                                                              |\n| **方法调用指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xb7                             | invokespecial        | indexbyte1 \t\t\tindexbyte2                            | 编译时方法绑定调用方法。                                     |\n| 0xb6                             | invokevirtual        | indexbyte1 \t\t\tindexbyte2                            | 运行时方法绑定调用方法。                                     |\n| 0xb8                             | invokestatic         | indexbyte1 \t\t\tindexbyte2                            | 调用静态方法。                                               |\n| 0xb9                             | invokeinterface      | indexbyte1 \t\t\tindexbyte2 \t\t\tcount \t\t\t0 | 调用接口方法。                                               |\n|                                  |                      |                                                              |                                                              |\n| **方法返回指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xac                             | ireturn              |                                                              | 返回int类型值。                                              |\n| 0xad                             | lreturn              |                                                              | 返回long类型值。                                             |\n| 0xae                             | freturn              |                                                              | 返回float类型值。                                            |\n| 0xaf                             | dreturn              |                                                              | 返回double类型值。                                           |\n| 0xb0                             | areturn              |                                                              | 返回引用类型值。                                             |\n| 0xb1                             | return               |                                                              | void函数返回。                                               |\n|                                  |                      |                                                              |                                                              |\n| **线程同步指令**                 |                      |                                                              |                                                              |\n| **指令码**                       | **操作码（助记符）** | **操作数**                                                   | **描述（栈指操作数栈）**                                     |\n| 0xc2                             | monitorenter         |                                                              | 进入并获得对象监视器。                                       |\n| 0xc3                             | monitorexit          |                                                              | 释放并退出对象监视器。                                       |\n","slug":"java指令码-字节码-对别","published":1,"updated":"2022-02-27T11:30:00.837Z","_id":"cl064wjw1000ilcrb97tk9o3f","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"java-【指令码】【子节码】-对比\"><a href=\"#java-【指令码】【子节码】-对比\" class=\"headerlink\" title=\"java 【指令码】【子节码】 对比\"></a>java 【指令码】【子节码】 对比</h3><p> 指令从0x00-0xc9 没有0xba</p>\n<table>\n<thead>\n<tr>\n<th><strong>常量入栈指令</strong></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x01</td>\n<td>aconst_null</td>\n<td></td>\n<td>null值入栈。</td>\n</tr>\n<tr>\n<td>0x02</td>\n<td>iconst_m1</td>\n<td></td>\n<td>-1(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x03</td>\n<td>iconst_0</td>\n<td></td>\n<td>0(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x04</td>\n<td>iconst_1</td>\n<td></td>\n<td>1(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x05</td>\n<td>iconst_2</td>\n<td></td>\n<td>2(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x06</td>\n<td>iconst_3</td>\n<td></td>\n<td>3(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x07</td>\n<td>iconst_4</td>\n<td></td>\n<td>4(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x08</td>\n<td>iconst_5</td>\n<td></td>\n<td>5(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x09</td>\n<td>lconst_0</td>\n<td></td>\n<td>0(long)值入栈。</td>\n</tr>\n<tr>\n<td>0x0a</td>\n<td>lconst_1</td>\n<td></td>\n<td>1(long)值入栈。</td>\n</tr>\n<tr>\n<td>0x0b</td>\n<td>fconst_0</td>\n<td></td>\n<td>0(float)值入栈。</td>\n</tr>\n<tr>\n<td>0x0c</td>\n<td>fconst_1</td>\n<td></td>\n<td>1(float)值入栈。</td>\n</tr>\n<tr>\n<td>0x0d</td>\n<td>fconst_2</td>\n<td></td>\n<td>2(float)值入栈。</td>\n</tr>\n<tr>\n<td>0x0e</td>\n<td>dconst_0</td>\n<td></td>\n<td>0(double)值入栈。</td>\n</tr>\n<tr>\n<td>0x0f</td>\n<td>dconst_1</td>\n<td></td>\n<td>1(double)值入栈。</td>\n</tr>\n<tr>\n<td>0x10</td>\n<td>bipush</td>\n<td>valuebyte</td>\n<td>valuebyte值带符号扩展成int值入栈。</td>\n</tr>\n<tr>\n<td>0x11</td>\n<td>sipush</td>\n<td>valuebyte1             valuebyte2</td>\n<td>(valuebyte1 &lt;&lt; 8) | valuebyte2 值带符号扩展成int值入栈。</td>\n</tr>\n<tr>\n<td>0x12</td>\n<td>ldc</td>\n<td>indexbyte1</td>\n<td>常量池中的常量值（int, float, string reference, object reference）入栈。</td>\n</tr>\n<tr>\n<td>0x13</td>\n<td>ldc_w</td>\n<td>indexbyte1             indexbyte2</td>\n<td>常量池中常量（int, float, string reference, object reference）入栈。</td>\n</tr>\n<tr>\n<td>0x14</td>\n<td>ldc2_w</td>\n<td>indexbyte1             indexbyte2</td>\n<td>常量池中常量（long, double）入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>局部变量值转载到栈中指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x19</td>\n<td>(wide)aload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2a</td>\n<td>aload_0</td>\n<td></td>\n<td>从局部变量0中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2b</td>\n<td>aload_1</td>\n<td></td>\n<td>从局部变量1中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2c</td>\n<td>aload_2</td>\n<td></td>\n<td>从局部变量2中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2d</td>\n<td>aload_3</td>\n<td></td>\n<td>从局部变量3中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x15</td>\n<td>(wide)iload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1a</td>\n<td>iload_0</td>\n<td></td>\n<td>从局部变量0中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1b</td>\n<td>iload_1</td>\n<td></td>\n<td>从局部变量1中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1c</td>\n<td>iload_2</td>\n<td></td>\n<td>从局部变量2中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1d</td>\n<td>iload_3</td>\n<td></td>\n<td>从局部变量3中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x16</td>\n<td>(wide)lload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载long类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1e</td>\n<td>lload_0</td>\n<td></td>\n<td>从局部变量0中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1f</td>\n<td>lload_1</td>\n<td></td>\n<td>从局部变量1中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x20</td>\n<td>lload_2</td>\n<td></td>\n<td>从局部变量2中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x21</td>\n<td>lload_3</td>\n<td></td>\n<td>从局部变量3中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x17</td>\n<td>(wide)fload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x22</td>\n<td>fload_0</td>\n<td></td>\n<td>从局部变量0中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x23</td>\n<td>fload_1</td>\n<td></td>\n<td>从局部变量1中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x24</td>\n<td>fload_2</td>\n<td></td>\n<td>从局部变量2中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x25</td>\n<td>fload_3</td>\n<td></td>\n<td>从局部变量3中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x18</td>\n<td>(wide)dload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x26</td>\n<td>dload_0</td>\n<td></td>\n<td>从局部变量0中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x27</td>\n<td>dload_1</td>\n<td></td>\n<td>从局部变量1中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x28</td>\n<td>dload_2</td>\n<td></td>\n<td>从局部变量2中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x29</td>\n<td>dload_3</td>\n<td></td>\n<td>从局部变量3中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x32</td>\n<td>aaload</td>\n<td></td>\n<td>从引用类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x2e</td>\n<td>iaload</td>\n<td></td>\n<td>从int类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x2f</td>\n<td>laload</td>\n<td></td>\n<td>从long类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x30</td>\n<td>faload</td>\n<td></td>\n<td>从float类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x31</td>\n<td>daload</td>\n<td></td>\n<td>从double类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x33</td>\n<td>baload</td>\n<td></td>\n<td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td>\n</tr>\n<tr>\n<td>0x34</td>\n<td>caload</td>\n<td></td>\n<td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td>\n</tr>\n<tr>\n<td>0x35</td>\n<td>saload</td>\n<td></td>\n<td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>将栈顶值保存到局部变量中指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x3a</td>\n<td>(wide)astore</td>\n<td>indexbyte</td>\n<td>将栈顶引用类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x4b</td>\n<td>astroe_0</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x4c</td>\n<td>astore_1</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x4d</td>\n<td>astore_2</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x4e</td>\n<td>astore_3</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x36</td>\n<td>(wide)istore</td>\n<td>indexbyte</td>\n<td>将栈顶int类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x3b</td>\n<td>istore_0</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x3c</td>\n<td>istore_1</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x3d</td>\n<td>istore_2</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x3e</td>\n<td>istore_3</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x37</td>\n<td>(wide)lstore</td>\n<td>indexbyte</td>\n<td>将栈顶long类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x3f</td>\n<td>lstore_0</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x40</td>\n<td>lstore_1</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x41</td>\n<td>lstore_2</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x42</td>\n<td>lstroe_3</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x38</td>\n<td>(wide)fstore</td>\n<td>indexbyte</td>\n<td>将栈顶float类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x43</td>\n<td>fstore_0</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x44</td>\n<td>fstore_1</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x45</td>\n<td>fstore_2</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x46</td>\n<td>fstore_3</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x39</td>\n<td>(wide)dstore</td>\n<td>indexbyte</td>\n<td>将栈顶double类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x47</td>\n<td>dstore_0</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x48</td>\n<td>dstore_1</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x49</td>\n<td>dstore_2</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x4a</td>\n<td>dstore_3</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x53</td>\n<td>aastore</td>\n<td></td>\n<td>将栈顶引用类型值保存到指定引用类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x4f</td>\n<td>iastore</td>\n<td></td>\n<td>将栈顶int类型值保存到指定int类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x50</td>\n<td>lastore</td>\n<td></td>\n<td>将栈顶long类型值保存到指定long类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x51</td>\n<td>fastore</td>\n<td></td>\n<td>将栈顶float类型值保存到指定float类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x52</td>\n<td>dastore</td>\n<td></td>\n<td>将栈顶double类型值保存到指定double类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x54</td>\n<td>bastroe</td>\n<td></td>\n<td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x55</td>\n<td>castore</td>\n<td></td>\n<td>将栈顶char类型值保存到指定char类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x56</td>\n<td>sastore</td>\n<td></td>\n<td>将栈顶short类型值保存到指定short类型数组的指定项。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>wide指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xc4</td>\n<td>wide</td>\n<td></td>\n<td>使用附加字节扩展局部变量索引（iinc指令特殊）。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>通用（无类型）栈操作指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x00</td>\n<td>nop</td>\n<td></td>\n<td>空操作。</td>\n</tr>\n<tr>\n<td>0x57</td>\n<td>pop</td>\n<td></td>\n<td>从栈顶弹出一个字长的数据。</td>\n</tr>\n<tr>\n<td>0x58</td>\n<td>pop2</td>\n<td></td>\n<td>从栈顶弹出两个字长的数据。</td>\n</tr>\n<tr>\n<td>0x59</td>\n<td>dup</td>\n<td></td>\n<td>复制栈顶一个字长的数据，将复制后的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5a</td>\n<td>dup_x1</td>\n<td></td>\n<td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td>\n</tr>\n<tr>\n<td>0x5b</td>\n<td>dup_x2</td>\n<td></td>\n<td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5c</td>\n<td>dup2</td>\n<td></td>\n<td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5d</td>\n<td>dup2_x1</td>\n<td></td>\n<td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5e</td>\n<td>dup2_x2</td>\n<td></td>\n<td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5f</td>\n<td>swap</td>\n<td></td>\n<td>交换栈顶两个字长的数据的位置。<a href=\"http://lib.csdn.net/base/javaee\">Java</a>指令中没有提供以两个字长为单位的交换指令。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>类型转换指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x86</td>\n<td>i2f</td>\n<td></td>\n<td>将栈顶int类型值转换为float类型值。</td>\n</tr>\n<tr>\n<td>0x85</td>\n<td>i2l</td>\n<td></td>\n<td>将栈顶int类型值转换为long类型值。</td>\n</tr>\n<tr>\n<td>0x87</td>\n<td>i2d</td>\n<td></td>\n<td>将栈顶int类型值转换为double类型值。</td>\n</tr>\n<tr>\n<td>0x8b</td>\n<td>f2i</td>\n<td></td>\n<td>将栈顶float类型值转换为int类型值。</td>\n</tr>\n<tr>\n<td>0x8c</td>\n<td>f2l</td>\n<td></td>\n<td>将栈顶float类型值转换为long类型值。</td>\n</tr>\n<tr>\n<td>0x8d</td>\n<td>f2d</td>\n<td></td>\n<td>将栈顶float类型值转换为double类型值。</td>\n</tr>\n<tr>\n<td>0x88</td>\n<td>l2i</td>\n<td></td>\n<td>将栈顶long类型值转换为int类型值。</td>\n</tr>\n<tr>\n<td>0x89</td>\n<td>l2f</td>\n<td></td>\n<td>将栈顶long类型值转换为float类型值。</td>\n</tr>\n<tr>\n<td>0x8a</td>\n<td>l2d</td>\n<td></td>\n<td>将栈顶long类型值转换double类型值。</td>\n</tr>\n<tr>\n<td>0x8e</td>\n<td>d2i</td>\n<td></td>\n<td>将栈顶double类型值转换为int类型值。</td>\n</tr>\n<tr>\n<td>0x90</td>\n<td>d2f</td>\n<td></td>\n<td>将栈顶double类型值转换为float类型值。</td>\n</tr>\n<tr>\n<td>0x8f</td>\n<td>d2l</td>\n<td></td>\n<td>将栈顶double类型值转换为long类型值。</td>\n</tr>\n<tr>\n<td>0x91</td>\n<td>i2b</td>\n<td></td>\n<td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x92</td>\n<td>i2c</td>\n<td></td>\n<td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x93</td>\n<td>i2s</td>\n<td></td>\n<td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>整数运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x60</td>\n<td>iadd</td>\n<td></td>\n<td>将栈顶两int类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x64</td>\n<td>isub</td>\n<td></td>\n<td>将栈顶两int类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x68</td>\n<td>imul</td>\n<td></td>\n<td>将栈顶两int类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6c</td>\n<td>idiv</td>\n<td></td>\n<td>将栈顶两int类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x70</td>\n<td>irem</td>\n<td></td>\n<td>将栈顶两int类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x74</td>\n<td>ineg</td>\n<td></td>\n<td>将栈顶int类型值取负，结果入栈。</td>\n</tr>\n<tr>\n<td>0x61</td>\n<td>ladd</td>\n<td></td>\n<td>将栈顶两long类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x65</td>\n<td>lsub</td>\n<td></td>\n<td>将栈顶两long类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x69</td>\n<td>lmul</td>\n<td></td>\n<td>将栈顶两long类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6d</td>\n<td>ldiv</td>\n<td></td>\n<td>将栈顶两long类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x71</td>\n<td>lrem</td>\n<td></td>\n<td>将栈顶两long类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x75</td>\n<td>lneg</td>\n<td></td>\n<td>将栈顶long类型值取负，结果入栈。</td>\n</tr>\n<tr>\n<td>0x84</td>\n<td>(wide)iinc</td>\n<td>indexbyte             constbyte</td>\n<td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>浮点运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x62</td>\n<td>fadd</td>\n<td></td>\n<td>将栈顶两float类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x66</td>\n<td>fsub</td>\n<td></td>\n<td>将栈顶两float类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6a</td>\n<td>fmul</td>\n<td></td>\n<td>将栈顶两float类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6e</td>\n<td>fdiv</td>\n<td></td>\n<td>将栈顶两float类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x72</td>\n<td>frem</td>\n<td></td>\n<td>将栈顶两float类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x76</td>\n<td>fneg</td>\n<td></td>\n<td>将栈顶float类型值取反，结果入栈。</td>\n</tr>\n<tr>\n<td>0x63</td>\n<td>dadd</td>\n<td></td>\n<td>将栈顶两double类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x67</td>\n<td>dsub</td>\n<td></td>\n<td>将栈顶两double类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6b</td>\n<td>dmul</td>\n<td></td>\n<td>将栈顶两double类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6f</td>\n<td>ddiv</td>\n<td></td>\n<td>将栈顶两double类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x73</td>\n<td>drem</td>\n<td></td>\n<td>将栈顶两double类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x77</td>\n<td>dneg</td>\n<td></td>\n<td>将栈顶double类型值取负，结果入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>逻辑运算——移位运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x78</td>\n<td>ishl</td>\n<td></td>\n<td>左移int类型值。</td>\n</tr>\n<tr>\n<td>0x79</td>\n<td>lshl</td>\n<td></td>\n<td>左移long类型值。</td>\n</tr>\n<tr>\n<td>0x7a</td>\n<td>ishr</td>\n<td></td>\n<td>算术右移int类型值。</td>\n</tr>\n<tr>\n<td>0x7b</td>\n<td>lshr</td>\n<td></td>\n<td>算术右移long类型值。</td>\n</tr>\n<tr>\n<td>0x7c</td>\n<td>iushr</td>\n<td></td>\n<td>逻辑右移int类型值。</td>\n</tr>\n<tr>\n<td>0x7d</td>\n<td>lushr</td>\n<td></td>\n<td>逻辑右移long类型值。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>逻辑运算——按位布尔运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x73</td>\n<td>iand</td>\n<td></td>\n<td>对int类型按位与运算。</td>\n</tr>\n<tr>\n<td>0x7f</td>\n<td>land</td>\n<td></td>\n<td>对long类型的按位与运算。</td>\n</tr>\n<tr>\n<td>0x80</td>\n<td>ior</td>\n<td></td>\n<td>对int类型的按位或运算。</td>\n</tr>\n<tr>\n<td>0x81</td>\n<td>lor</td>\n<td></td>\n<td>对long类型的按位或运算。</td>\n</tr>\n<tr>\n<td>0x82</td>\n<td>ixor</td>\n<td></td>\n<td>对int类型的按位异或运算。</td>\n</tr>\n<tr>\n<td>0x83</td>\n<td>lxor</td>\n<td></td>\n<td>对long类型的按位异或运算。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——条件跳转指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x99</td>\n<td>ifeq</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值为0则跳转。</td>\n</tr>\n<tr>\n<td>0x9a</td>\n<td>ifne</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值不为0则跳转。</td>\n</tr>\n<tr>\n<td>0x9b</td>\n<td>iflt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值小于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9e</td>\n<td>ifle</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值小于等于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9d</td>\n<td>ifgt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值大于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9c</td>\n<td>ifge</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值大于等于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9f</td>\n<td>if_icmpeq</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值相等则跳转。</td>\n</tr>\n<tr>\n<td>0xa0</td>\n<td>if_icmpne</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值不相等则跳转。</td>\n</tr>\n<tr>\n<td>0xa1</td>\n<td>if_icmplt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前小于后则跳转。</td>\n</tr>\n<tr>\n<td>0xa4</td>\n<td>if_icmple</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前小于等于后则跳转。</td>\n</tr>\n<tr>\n<td>0xa3</td>\n<td>if_icmpgt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前大于后则跳转。</td>\n</tr>\n<tr>\n<td>0xa2</td>\n<td>if_icmpge</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前大于等于后则跳转。</td>\n</tr>\n<tr>\n<td>0xc6</td>\n<td>ifnull</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶引用值为null则跳转。</td>\n</tr>\n<tr>\n<td>0xc7</td>\n<td>ifnonnull</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶引用值不为null则跳转。</td>\n</tr>\n<tr>\n<td>0xa5</td>\n<td>if_acmpeq</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两引用类型值相等则跳转。</td>\n</tr>\n<tr>\n<td>0xa6</td>\n<td>if_acmpne</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两引用类型值不相等则跳转。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——比较指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x94</td>\n<td>lcmp</td>\n<td></td>\n<td>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</td>\n</tr>\n<tr>\n<td>0x95</td>\n<td>fcmpl</td>\n<td></td>\n<td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td>0x96</td>\n<td>fcmpg</td>\n<td></td>\n<td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td>0x97</td>\n<td>dcmpl</td>\n<td></td>\n<td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td>0x98</td>\n<td>dcmpg</td>\n<td></td>\n<td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——无条件跳转指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xa7</td>\n<td>goto</td>\n<td>branchbyte1             branchbyte2</td>\n<td>无条件跳转到指定位置。</td>\n</tr>\n<tr>\n<td>0xc8</td>\n<td>goto_w</td>\n<td>branchbyte1             branchbyte2             branchbyte3             branchbyte4</td>\n<td>无条件跳转到指定位置（宽索引）。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——表跳转指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xaa</td>\n<td>tableswitch</td>\n<td>&lt;0-3bytepad&gt;             defaultbyte1             defaultbyte2             defaultbyte3             defaultbyte4             lowbyte1             lowbyte2             lowbyte3             lowbyte4             highbyte1             highbyte2             highbyte3             highbyte4             jump offsets…</td>\n<td>通过索引访问跳转表，并跳转。</td>\n</tr>\n<tr>\n<td>0xab</td>\n<td>lookupswitch</td>\n<td>&lt;0-3bytepad&gt;             defaultbyte1             defaultbyte2             defaultbyte3             defaultbyte4             npairs1             npairs2             npairs3             npairs4             match offsets</td>\n<td>通过键值访问跳转表，并跳转。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——异常和finally</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xbf</td>\n<td>athrow</td>\n<td></td>\n<td>抛出异常。</td>\n</tr>\n<tr>\n<td>0xa8</td>\n<td>jsr</td>\n<td>branchbyte1             branchbyte2</td>\n<td>跳转到子例程序。</td>\n</tr>\n<tr>\n<td>0xc9</td>\n<td>jsr_w</td>\n<td>branchbyte1             branchbyte2             branchbyte3             branchbyte4</td>\n<td>跳转到子例程序（宽索引）。</td>\n</tr>\n<tr>\n<td>0xa9</td>\n<td>(wide)ret</td>\n<td>indexbyte</td>\n<td>返回子例程序。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>对象操作指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xbb</td>\n<td>new</td>\n<td>indexbyte1             indexbyte2</td>\n<td>创建新的对象实例。</td>\n</tr>\n<tr>\n<td>0xc0</td>\n<td>checkcast</td>\n<td>indexbyte1             indexbyte</td>\n<td>类型强转。</td>\n</tr>\n<tr>\n<td>0xc1</td>\n<td>instanceof</td>\n<td>indexbyte1             indexbyte2</td>\n<td>判断类型。</td>\n</tr>\n<tr>\n<td>0xb4</td>\n<td>getfield</td>\n<td>indexbyte1             indexbyte2</td>\n<td>获取对象字段的值。</td>\n</tr>\n<tr>\n<td>0xb5</td>\n<td>putfield</td>\n<td>indexbyte1             indexbyte2</td>\n<td>给对象字段赋值。</td>\n</tr>\n<tr>\n<td>0xb2</td>\n<td>getstatic</td>\n<td>indexbyte1             indexbyte2</td>\n<td>获取静态字段的值。</td>\n</tr>\n<tr>\n<td>0xb3</td>\n<td>putstatic</td>\n<td>indexbyte1             indexbyte2</td>\n<td>给静态字段赋值。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>数组操作指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xbc</td>\n<td>newarray</td>\n<td>atype</td>\n<td>创建type类型的数组。</td>\n</tr>\n<tr>\n<td>0xbd</td>\n<td>anewarray</td>\n<td>indexbyte1             indexbyte2</td>\n<td>创建引用类型的数组。</td>\n</tr>\n<tr>\n<td>0xbe</td>\n<td>arraylength</td>\n<td></td>\n<td>获取一维数组的长度。</td>\n</tr>\n<tr>\n<td>0xc5</td>\n<td>multianewarray</td>\n<td>indexbyte1             indexbyte2             dimension</td>\n<td>创建dimension维度的数组。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>方法调用指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xb7</td>\n<td>invokespecial</td>\n<td>indexbyte1             indexbyte2</td>\n<td>编译时方法绑定调用方法。</td>\n</tr>\n<tr>\n<td>0xb6</td>\n<td>invokevirtual</td>\n<td>indexbyte1             indexbyte2</td>\n<td>运行时方法绑定调用方法。</td>\n</tr>\n<tr>\n<td>0xb8</td>\n<td>invokestatic</td>\n<td>indexbyte1             indexbyte2</td>\n<td>调用静态方法。</td>\n</tr>\n<tr>\n<td>0xb9</td>\n<td>invokeinterface</td>\n<td>indexbyte1             indexbyte2             count             0</td>\n<td>调用接口方法。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>方法返回指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xac</td>\n<td>ireturn</td>\n<td></td>\n<td>返回int类型值。</td>\n</tr>\n<tr>\n<td>0xad</td>\n<td>lreturn</td>\n<td></td>\n<td>返回long类型值。</td>\n</tr>\n<tr>\n<td>0xae</td>\n<td>freturn</td>\n<td></td>\n<td>返回float类型值。</td>\n</tr>\n<tr>\n<td>0xaf</td>\n<td>dreturn</td>\n<td></td>\n<td>返回double类型值。</td>\n</tr>\n<tr>\n<td>0xb0</td>\n<td>areturn</td>\n<td></td>\n<td>返回引用类型值。</td>\n</tr>\n<tr>\n<td>0xb1</td>\n<td>return</td>\n<td></td>\n<td>void函数返回。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>线程同步指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xc2</td>\n<td>monitorenter</td>\n<td></td>\n<td>进入并获得对象监视器。</td>\n</tr>\n<tr>\n<td>0xc3</td>\n<td>monitorexit</td>\n<td></td>\n<td>释放并退出对象监视器。</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"java-【指令码】【子节码】-对比\"><a href=\"#java-【指令码】【子节码】-对比\" class=\"headerlink\" title=\"java 【指令码】【子节码】 对比\"></a>java 【指令码】【子节码】 对比</h3><p> 指令从0x00-0xc9 没有0xba</p>\n<table>\n<thead>\n<tr>\n<th><strong>常量入栈指令</strong></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x01</td>\n<td>aconst_null</td>\n<td></td>\n<td>null值入栈。</td>\n</tr>\n<tr>\n<td>0x02</td>\n<td>iconst_m1</td>\n<td></td>\n<td>-1(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x03</td>\n<td>iconst_0</td>\n<td></td>\n<td>0(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x04</td>\n<td>iconst_1</td>\n<td></td>\n<td>1(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x05</td>\n<td>iconst_2</td>\n<td></td>\n<td>2(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x06</td>\n<td>iconst_3</td>\n<td></td>\n<td>3(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x07</td>\n<td>iconst_4</td>\n<td></td>\n<td>4(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x08</td>\n<td>iconst_5</td>\n<td></td>\n<td>5(int)值入栈。</td>\n</tr>\n<tr>\n<td>0x09</td>\n<td>lconst_0</td>\n<td></td>\n<td>0(long)值入栈。</td>\n</tr>\n<tr>\n<td>0x0a</td>\n<td>lconst_1</td>\n<td></td>\n<td>1(long)值入栈。</td>\n</tr>\n<tr>\n<td>0x0b</td>\n<td>fconst_0</td>\n<td></td>\n<td>0(float)值入栈。</td>\n</tr>\n<tr>\n<td>0x0c</td>\n<td>fconst_1</td>\n<td></td>\n<td>1(float)值入栈。</td>\n</tr>\n<tr>\n<td>0x0d</td>\n<td>fconst_2</td>\n<td></td>\n<td>2(float)值入栈。</td>\n</tr>\n<tr>\n<td>0x0e</td>\n<td>dconst_0</td>\n<td></td>\n<td>0(double)值入栈。</td>\n</tr>\n<tr>\n<td>0x0f</td>\n<td>dconst_1</td>\n<td></td>\n<td>1(double)值入栈。</td>\n</tr>\n<tr>\n<td>0x10</td>\n<td>bipush</td>\n<td>valuebyte</td>\n<td>valuebyte值带符号扩展成int值入栈。</td>\n</tr>\n<tr>\n<td>0x11</td>\n<td>sipush</td>\n<td>valuebyte1             valuebyte2</td>\n<td>(valuebyte1 &lt;&lt; 8) | valuebyte2 值带符号扩展成int值入栈。</td>\n</tr>\n<tr>\n<td>0x12</td>\n<td>ldc</td>\n<td>indexbyte1</td>\n<td>常量池中的常量值（int, float, string reference, object reference）入栈。</td>\n</tr>\n<tr>\n<td>0x13</td>\n<td>ldc_w</td>\n<td>indexbyte1             indexbyte2</td>\n<td>常量池中常量（int, float, string reference, object reference）入栈。</td>\n</tr>\n<tr>\n<td>0x14</td>\n<td>ldc2_w</td>\n<td>indexbyte1             indexbyte2</td>\n<td>常量池中常量（long, double）入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>局部变量值转载到栈中指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x19</td>\n<td>(wide)aload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2a</td>\n<td>aload_0</td>\n<td></td>\n<td>从局部变量0中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2b</td>\n<td>aload_1</td>\n<td></td>\n<td>从局部变量1中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2c</td>\n<td>aload_2</td>\n<td></td>\n<td>从局部变量2中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x2d</td>\n<td>aload_3</td>\n<td></td>\n<td>从局部变量3中装载引用类型值入栈。</td>\n</tr>\n<tr>\n<td>0x15</td>\n<td>(wide)iload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1a</td>\n<td>iload_0</td>\n<td></td>\n<td>从局部变量0中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1b</td>\n<td>iload_1</td>\n<td></td>\n<td>从局部变量1中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1c</td>\n<td>iload_2</td>\n<td></td>\n<td>从局部变量2中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1d</td>\n<td>iload_3</td>\n<td></td>\n<td>从局部变量3中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x16</td>\n<td>(wide)lload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载long类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1e</td>\n<td>lload_0</td>\n<td></td>\n<td>从局部变量0中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x1f</td>\n<td>lload_1</td>\n<td></td>\n<td>从局部变量1中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x20</td>\n<td>lload_2</td>\n<td></td>\n<td>从局部变量2中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x21</td>\n<td>lload_3</td>\n<td></td>\n<td>从局部变量3中装载int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x17</td>\n<td>(wide)fload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x22</td>\n<td>fload_0</td>\n<td></td>\n<td>从局部变量0中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x23</td>\n<td>fload_1</td>\n<td></td>\n<td>从局部变量1中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x24</td>\n<td>fload_2</td>\n<td></td>\n<td>从局部变量2中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x25</td>\n<td>fload_3</td>\n<td></td>\n<td>从局部变量3中装载float类型值入栈。</td>\n</tr>\n<tr>\n<td>0x18</td>\n<td>(wide)dload</td>\n<td>indexbyte</td>\n<td>从局部变量indexbyte中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x26</td>\n<td>dload_0</td>\n<td></td>\n<td>从局部变量0中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x27</td>\n<td>dload_1</td>\n<td></td>\n<td>从局部变量1中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x28</td>\n<td>dload_2</td>\n<td></td>\n<td>从局部变量2中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x29</td>\n<td>dload_3</td>\n<td></td>\n<td>从局部变量3中装载double类型值入栈。</td>\n</tr>\n<tr>\n<td>0x32</td>\n<td>aaload</td>\n<td></td>\n<td>从引用类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x2e</td>\n<td>iaload</td>\n<td></td>\n<td>从int类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x2f</td>\n<td>laload</td>\n<td></td>\n<td>从long类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x30</td>\n<td>faload</td>\n<td></td>\n<td>从float类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x31</td>\n<td>daload</td>\n<td></td>\n<td>从double类型数组中装载指定项的值。</td>\n</tr>\n<tr>\n<td>0x33</td>\n<td>baload</td>\n<td></td>\n<td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td>\n</tr>\n<tr>\n<td>0x34</td>\n<td>caload</td>\n<td></td>\n<td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td>\n</tr>\n<tr>\n<td>0x35</td>\n<td>saload</td>\n<td></td>\n<td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>将栈顶值保存到局部变量中指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x3a</td>\n<td>(wide)astore</td>\n<td>indexbyte</td>\n<td>将栈顶引用类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x4b</td>\n<td>astroe_0</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x4c</td>\n<td>astore_1</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x4d</td>\n<td>astore_2</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x4e</td>\n<td>astore_3</td>\n<td></td>\n<td>将栈顶引用类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x36</td>\n<td>(wide)istore</td>\n<td>indexbyte</td>\n<td>将栈顶int类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x3b</td>\n<td>istore_0</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x3c</td>\n<td>istore_1</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x3d</td>\n<td>istore_2</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x3e</td>\n<td>istore_3</td>\n<td></td>\n<td>将栈顶int类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x37</td>\n<td>(wide)lstore</td>\n<td>indexbyte</td>\n<td>将栈顶long类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x3f</td>\n<td>lstore_0</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x40</td>\n<td>lstore_1</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x41</td>\n<td>lstore_2</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x42</td>\n<td>lstroe_3</td>\n<td></td>\n<td>将栈顶long类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x38</td>\n<td>(wide)fstore</td>\n<td>indexbyte</td>\n<td>将栈顶float类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x43</td>\n<td>fstore_0</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x44</td>\n<td>fstore_1</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x45</td>\n<td>fstore_2</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x46</td>\n<td>fstore_3</td>\n<td></td>\n<td>将栈顶float类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x39</td>\n<td>(wide)dstore</td>\n<td>indexbyte</td>\n<td>将栈顶double类型值保存到局部变量indexbyte中。</td>\n</tr>\n<tr>\n<td>0x47</td>\n<td>dstore_0</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量0中。</td>\n</tr>\n<tr>\n<td>0x48</td>\n<td>dstore_1</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量1中。</td>\n</tr>\n<tr>\n<td>0x49</td>\n<td>dstore_2</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量2中。</td>\n</tr>\n<tr>\n<td>0x4a</td>\n<td>dstore_3</td>\n<td></td>\n<td>将栈顶double类型值保存到局部变量3中。</td>\n</tr>\n<tr>\n<td>0x53</td>\n<td>aastore</td>\n<td></td>\n<td>将栈顶引用类型值保存到指定引用类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x4f</td>\n<td>iastore</td>\n<td></td>\n<td>将栈顶int类型值保存到指定int类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x50</td>\n<td>lastore</td>\n<td></td>\n<td>将栈顶long类型值保存到指定long类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x51</td>\n<td>fastore</td>\n<td></td>\n<td>将栈顶float类型值保存到指定float类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x52</td>\n<td>dastore</td>\n<td></td>\n<td>将栈顶double类型值保存到指定double类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x54</td>\n<td>bastroe</td>\n<td></td>\n<td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x55</td>\n<td>castore</td>\n<td></td>\n<td>将栈顶char类型值保存到指定char类型数组的指定项。</td>\n</tr>\n<tr>\n<td>0x56</td>\n<td>sastore</td>\n<td></td>\n<td>将栈顶short类型值保存到指定short类型数组的指定项。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>wide指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xc4</td>\n<td>wide</td>\n<td></td>\n<td>使用附加字节扩展局部变量索引（iinc指令特殊）。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>通用（无类型）栈操作指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x00</td>\n<td>nop</td>\n<td></td>\n<td>空操作。</td>\n</tr>\n<tr>\n<td>0x57</td>\n<td>pop</td>\n<td></td>\n<td>从栈顶弹出一个字长的数据。</td>\n</tr>\n<tr>\n<td>0x58</td>\n<td>pop2</td>\n<td></td>\n<td>从栈顶弹出两个字长的数据。</td>\n</tr>\n<tr>\n<td>0x59</td>\n<td>dup</td>\n<td></td>\n<td>复制栈顶一个字长的数据，将复制后的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5a</td>\n<td>dup_x1</td>\n<td></td>\n<td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td>\n</tr>\n<tr>\n<td>0x5b</td>\n<td>dup_x2</td>\n<td></td>\n<td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5c</td>\n<td>dup2</td>\n<td></td>\n<td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5d</td>\n<td>dup2_x1</td>\n<td></td>\n<td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5e</td>\n<td>dup2_x2</td>\n<td></td>\n<td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td>\n</tr>\n<tr>\n<td>0x5f</td>\n<td>swap</td>\n<td></td>\n<td>交换栈顶两个字长的数据的位置。<a href=\"http://lib.csdn.net/base/javaee\">Java</a>指令中没有提供以两个字长为单位的交换指令。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>类型转换指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x86</td>\n<td>i2f</td>\n<td></td>\n<td>将栈顶int类型值转换为float类型值。</td>\n</tr>\n<tr>\n<td>0x85</td>\n<td>i2l</td>\n<td></td>\n<td>将栈顶int类型值转换为long类型值。</td>\n</tr>\n<tr>\n<td>0x87</td>\n<td>i2d</td>\n<td></td>\n<td>将栈顶int类型值转换为double类型值。</td>\n</tr>\n<tr>\n<td>0x8b</td>\n<td>f2i</td>\n<td></td>\n<td>将栈顶float类型值转换为int类型值。</td>\n</tr>\n<tr>\n<td>0x8c</td>\n<td>f2l</td>\n<td></td>\n<td>将栈顶float类型值转换为long类型值。</td>\n</tr>\n<tr>\n<td>0x8d</td>\n<td>f2d</td>\n<td></td>\n<td>将栈顶float类型值转换为double类型值。</td>\n</tr>\n<tr>\n<td>0x88</td>\n<td>l2i</td>\n<td></td>\n<td>将栈顶long类型值转换为int类型值。</td>\n</tr>\n<tr>\n<td>0x89</td>\n<td>l2f</td>\n<td></td>\n<td>将栈顶long类型值转换为float类型值。</td>\n</tr>\n<tr>\n<td>0x8a</td>\n<td>l2d</td>\n<td></td>\n<td>将栈顶long类型值转换double类型值。</td>\n</tr>\n<tr>\n<td>0x8e</td>\n<td>d2i</td>\n<td></td>\n<td>将栈顶double类型值转换为int类型值。</td>\n</tr>\n<tr>\n<td>0x90</td>\n<td>d2f</td>\n<td></td>\n<td>将栈顶double类型值转换为float类型值。</td>\n</tr>\n<tr>\n<td>0x8f</td>\n<td>d2l</td>\n<td></td>\n<td>将栈顶double类型值转换为long类型值。</td>\n</tr>\n<tr>\n<td>0x91</td>\n<td>i2b</td>\n<td></td>\n<td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x92</td>\n<td>i2c</td>\n<td></td>\n<td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td>\n</tr>\n<tr>\n<td>0x93</td>\n<td>i2s</td>\n<td></td>\n<td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>整数运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x60</td>\n<td>iadd</td>\n<td></td>\n<td>将栈顶两int类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x64</td>\n<td>isub</td>\n<td></td>\n<td>将栈顶两int类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x68</td>\n<td>imul</td>\n<td></td>\n<td>将栈顶两int类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6c</td>\n<td>idiv</td>\n<td></td>\n<td>将栈顶两int类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x70</td>\n<td>irem</td>\n<td></td>\n<td>将栈顶两int类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x74</td>\n<td>ineg</td>\n<td></td>\n<td>将栈顶int类型值取负，结果入栈。</td>\n</tr>\n<tr>\n<td>0x61</td>\n<td>ladd</td>\n<td></td>\n<td>将栈顶两long类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x65</td>\n<td>lsub</td>\n<td></td>\n<td>将栈顶两long类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x69</td>\n<td>lmul</td>\n<td></td>\n<td>将栈顶两long类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6d</td>\n<td>ldiv</td>\n<td></td>\n<td>将栈顶两long类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x71</td>\n<td>lrem</td>\n<td></td>\n<td>将栈顶两long类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x75</td>\n<td>lneg</td>\n<td></td>\n<td>将栈顶long类型值取负，结果入栈。</td>\n</tr>\n<tr>\n<td>0x84</td>\n<td>(wide)iinc</td>\n<td>indexbyte             constbyte</td>\n<td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>浮点运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x62</td>\n<td>fadd</td>\n<td></td>\n<td>将栈顶两float类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x66</td>\n<td>fsub</td>\n<td></td>\n<td>将栈顶两float类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6a</td>\n<td>fmul</td>\n<td></td>\n<td>将栈顶两float类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6e</td>\n<td>fdiv</td>\n<td></td>\n<td>将栈顶两float类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x72</td>\n<td>frem</td>\n<td></td>\n<td>将栈顶两float类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x76</td>\n<td>fneg</td>\n<td></td>\n<td>将栈顶float类型值取反，结果入栈。</td>\n</tr>\n<tr>\n<td>0x63</td>\n<td>dadd</td>\n<td></td>\n<td>将栈顶两double类型数相加，结果入栈。</td>\n</tr>\n<tr>\n<td>0x67</td>\n<td>dsub</td>\n<td></td>\n<td>将栈顶两double类型数相减，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6b</td>\n<td>dmul</td>\n<td></td>\n<td>将栈顶两double类型数相乘，结果入栈。</td>\n</tr>\n<tr>\n<td>0x6f</td>\n<td>ddiv</td>\n<td></td>\n<td>将栈顶两double类型数相除，结果入栈。</td>\n</tr>\n<tr>\n<td>0x73</td>\n<td>drem</td>\n<td></td>\n<td>将栈顶两double类型数取模，结果入栈。</td>\n</tr>\n<tr>\n<td>0x77</td>\n<td>dneg</td>\n<td></td>\n<td>将栈顶double类型值取负，结果入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>逻辑运算——移位运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x78</td>\n<td>ishl</td>\n<td></td>\n<td>左移int类型值。</td>\n</tr>\n<tr>\n<td>0x79</td>\n<td>lshl</td>\n<td></td>\n<td>左移long类型值。</td>\n</tr>\n<tr>\n<td>0x7a</td>\n<td>ishr</td>\n<td></td>\n<td>算术右移int类型值。</td>\n</tr>\n<tr>\n<td>0x7b</td>\n<td>lshr</td>\n<td></td>\n<td>算术右移long类型值。</td>\n</tr>\n<tr>\n<td>0x7c</td>\n<td>iushr</td>\n<td></td>\n<td>逻辑右移int类型值。</td>\n</tr>\n<tr>\n<td>0x7d</td>\n<td>lushr</td>\n<td></td>\n<td>逻辑右移long类型值。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>逻辑运算——按位布尔运算</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x73</td>\n<td>iand</td>\n<td></td>\n<td>对int类型按位与运算。</td>\n</tr>\n<tr>\n<td>0x7f</td>\n<td>land</td>\n<td></td>\n<td>对long类型的按位与运算。</td>\n</tr>\n<tr>\n<td>0x80</td>\n<td>ior</td>\n<td></td>\n<td>对int类型的按位或运算。</td>\n</tr>\n<tr>\n<td>0x81</td>\n<td>lor</td>\n<td></td>\n<td>对long类型的按位或运算。</td>\n</tr>\n<tr>\n<td>0x82</td>\n<td>ixor</td>\n<td></td>\n<td>对int类型的按位异或运算。</td>\n</tr>\n<tr>\n<td>0x83</td>\n<td>lxor</td>\n<td></td>\n<td>对long类型的按位异或运算。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——条件跳转指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x99</td>\n<td>ifeq</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值为0则跳转。</td>\n</tr>\n<tr>\n<td>0x9a</td>\n<td>ifne</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值不为0则跳转。</td>\n</tr>\n<tr>\n<td>0x9b</td>\n<td>iflt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值小于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9e</td>\n<td>ifle</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值小于等于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9d</td>\n<td>ifgt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值大于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9c</td>\n<td>ifge</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶int类型值大于等于0则跳转。</td>\n</tr>\n<tr>\n<td>0x9f</td>\n<td>if_icmpeq</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值相等则跳转。</td>\n</tr>\n<tr>\n<td>0xa0</td>\n<td>if_icmpne</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值不相等则跳转。</td>\n</tr>\n<tr>\n<td>0xa1</td>\n<td>if_icmplt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前小于后则跳转。</td>\n</tr>\n<tr>\n<td>0xa4</td>\n<td>if_icmple</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前小于等于后则跳转。</td>\n</tr>\n<tr>\n<td>0xa3</td>\n<td>if_icmpgt</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前大于后则跳转。</td>\n</tr>\n<tr>\n<td>0xa2</td>\n<td>if_icmpge</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两int类型值前大于等于后则跳转。</td>\n</tr>\n<tr>\n<td>0xc6</td>\n<td>ifnull</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶引用值为null则跳转。</td>\n</tr>\n<tr>\n<td>0xc7</td>\n<td>ifnonnull</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶引用值不为null则跳转。</td>\n</tr>\n<tr>\n<td>0xa5</td>\n<td>if_acmpeq</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两引用类型值相等则跳转。</td>\n</tr>\n<tr>\n<td>0xa6</td>\n<td>if_acmpne</td>\n<td>branchbyte1             branchbyte2</td>\n<td>若栈顶两引用类型值不相等则跳转。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——比较指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0x94</td>\n<td>lcmp</td>\n<td></td>\n<td>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</td>\n</tr>\n<tr>\n<td>0x95</td>\n<td>fcmpl</td>\n<td></td>\n<td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td>0x96</td>\n<td>fcmpg</td>\n<td></td>\n<td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td>0x97</td>\n<td>dcmpl</td>\n<td></td>\n<td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td>0x98</td>\n<td>dcmpg</td>\n<td></td>\n<td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——无条件跳转指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xa7</td>\n<td>goto</td>\n<td>branchbyte1             branchbyte2</td>\n<td>无条件跳转到指定位置。</td>\n</tr>\n<tr>\n<td>0xc8</td>\n<td>goto_w</td>\n<td>branchbyte1             branchbyte2             branchbyte3             branchbyte4</td>\n<td>无条件跳转到指定位置（宽索引）。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——表跳转指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xaa</td>\n<td>tableswitch</td>\n<td>&lt;0-3bytepad&gt;             defaultbyte1             defaultbyte2             defaultbyte3             defaultbyte4             lowbyte1             lowbyte2             lowbyte3             lowbyte4             highbyte1             highbyte2             highbyte3             highbyte4             jump offsets…</td>\n<td>通过索引访问跳转表，并跳转。</td>\n</tr>\n<tr>\n<td>0xab</td>\n<td>lookupswitch</td>\n<td>&lt;0-3bytepad&gt;             defaultbyte1             defaultbyte2             defaultbyte3             defaultbyte4             npairs1             npairs2             npairs3             npairs4             match offsets</td>\n<td>通过键值访问跳转表，并跳转。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>控制流指令——异常和finally</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xbf</td>\n<td>athrow</td>\n<td></td>\n<td>抛出异常。</td>\n</tr>\n<tr>\n<td>0xa8</td>\n<td>jsr</td>\n<td>branchbyte1             branchbyte2</td>\n<td>跳转到子例程序。</td>\n</tr>\n<tr>\n<td>0xc9</td>\n<td>jsr_w</td>\n<td>branchbyte1             branchbyte2             branchbyte3             branchbyte4</td>\n<td>跳转到子例程序（宽索引）。</td>\n</tr>\n<tr>\n<td>0xa9</td>\n<td>(wide)ret</td>\n<td>indexbyte</td>\n<td>返回子例程序。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>对象操作指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xbb</td>\n<td>new</td>\n<td>indexbyte1             indexbyte2</td>\n<td>创建新的对象实例。</td>\n</tr>\n<tr>\n<td>0xc0</td>\n<td>checkcast</td>\n<td>indexbyte1             indexbyte</td>\n<td>类型强转。</td>\n</tr>\n<tr>\n<td>0xc1</td>\n<td>instanceof</td>\n<td>indexbyte1             indexbyte2</td>\n<td>判断类型。</td>\n</tr>\n<tr>\n<td>0xb4</td>\n<td>getfield</td>\n<td>indexbyte1             indexbyte2</td>\n<td>获取对象字段的值。</td>\n</tr>\n<tr>\n<td>0xb5</td>\n<td>putfield</td>\n<td>indexbyte1             indexbyte2</td>\n<td>给对象字段赋值。</td>\n</tr>\n<tr>\n<td>0xb2</td>\n<td>getstatic</td>\n<td>indexbyte1             indexbyte2</td>\n<td>获取静态字段的值。</td>\n</tr>\n<tr>\n<td>0xb3</td>\n<td>putstatic</td>\n<td>indexbyte1             indexbyte2</td>\n<td>给静态字段赋值。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>数组操作指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xbc</td>\n<td>newarray</td>\n<td>atype</td>\n<td>创建type类型的数组。</td>\n</tr>\n<tr>\n<td>0xbd</td>\n<td>anewarray</td>\n<td>indexbyte1             indexbyte2</td>\n<td>创建引用类型的数组。</td>\n</tr>\n<tr>\n<td>0xbe</td>\n<td>arraylength</td>\n<td></td>\n<td>获取一维数组的长度。</td>\n</tr>\n<tr>\n<td>0xc5</td>\n<td>multianewarray</td>\n<td>indexbyte1             indexbyte2             dimension</td>\n<td>创建dimension维度的数组。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>方法调用指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xb7</td>\n<td>invokespecial</td>\n<td>indexbyte1             indexbyte2</td>\n<td>编译时方法绑定调用方法。</td>\n</tr>\n<tr>\n<td>0xb6</td>\n<td>invokevirtual</td>\n<td>indexbyte1             indexbyte2</td>\n<td>运行时方法绑定调用方法。</td>\n</tr>\n<tr>\n<td>0xb8</td>\n<td>invokestatic</td>\n<td>indexbyte1             indexbyte2</td>\n<td>调用静态方法。</td>\n</tr>\n<tr>\n<td>0xb9</td>\n<td>invokeinterface</td>\n<td>indexbyte1             indexbyte2             count             0</td>\n<td>调用接口方法。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>方法返回指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xac</td>\n<td>ireturn</td>\n<td></td>\n<td>返回int类型值。</td>\n</tr>\n<tr>\n<td>0xad</td>\n<td>lreturn</td>\n<td></td>\n<td>返回long类型值。</td>\n</tr>\n<tr>\n<td>0xae</td>\n<td>freturn</td>\n<td></td>\n<td>返回float类型值。</td>\n</tr>\n<tr>\n<td>0xaf</td>\n<td>dreturn</td>\n<td></td>\n<td>返回double类型值。</td>\n</tr>\n<tr>\n<td>0xb0</td>\n<td>areturn</td>\n<td></td>\n<td>返回引用类型值。</td>\n</tr>\n<tr>\n<td>0xb1</td>\n<td>return</td>\n<td></td>\n<td>void函数返回。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>线程同步指令</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指令码</strong></td>\n<td><strong>操作码（助记符）</strong></td>\n<td><strong>操作数</strong></td>\n<td><strong>描述（栈指操作数栈）</strong></td>\n</tr>\n<tr>\n<td>0xc2</td>\n<td>monitorenter</td>\n<td></td>\n<td>进入并获得对象监视器。</td>\n</tr>\n<tr>\n<td>0xc3</td>\n<td>monitorexit</td>\n<td></td>\n<td>释放并退出对象监视器。</td>\n</tr>\n</tbody></table>\n"},{"title":"kafka最佳配置实践","date":"2021-12-23T08:01:44.000Z","_content":"\n## 1. broker端\n - ### broker集群参数\n   1. > **log.dirs**: \\\n        这是非常重要的参数，指定了 Broker 需要使用的若干个文件目录路径。要知道这个参数是没有默认值的，这说明什么？这说明它必须由你亲自指定。\\\n        **log.dir**: \\\n        注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        这两个参数应该怎么设置呢？很简单，你只要设置log.dirs，即第一个参数就好了，不要设置log.dir。\\\n        而且更重要的是，在线上生产环境中一定要为log.dirs配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径，\\\n        比如/home/kafka1,/home/kafka2,/home/kafka3这样。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。</font>\n   2. > **zookeeper.connect** \\\n        如果我们是单集群，那么很简单，直接设置zookeeper.connect=zk1:2181,zk2:2181,zk3:2181即可。 \\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        这里我们主要考虑多套kafka集群公用一套zookeeper集群, 这时候我们要使用 zookeeper的 chroot，文件挂载方式实现 \\    \n        如果有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的zookeeper.connect参数可以这样指定：\\\n        zk1:2181,zk2:2181,zk3:2181/kafka1和zk1:2181,zk2:2181,zk3:2181/kafka2。\\\n        切记 chroot 只需要写一次，而且是加到最后的。\\\n        </font>\n        <font color=red>zk1:2181/kafka1,zk2:2181/kafka2,zk3:2181/kafka3</font> 这样的格式是不对的。\n   3. > **listeners: PLAINTEXT://host:9092** \\\n        监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        从构成上来说，它是若干个逗号分隔的三元组，每个三元组的格式为<协议名称，主机名，端口号>。\\\n        这里的协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；\\\n        也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092。\\\n        一旦你自己定义了协议名称，你必须还要指定listener.security.protocol.map参数告诉这个协议底层使用了哪种安全协议，\\\n        比如指定listener.security.protocol.map=CONTROLLER:PLAINTEXT表示CONTROLLER这个自定义协议底层使用明文不加密传输数据。\n        </font>\n   4. > **advertised.listeners** \\\n        和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。\n   5. > **auto.create.topics.enable=false** \\   \n        是否允许自动创建 Topic。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        建议最好设置成 false，即不允许自动创建 Topic。\\\n        Topic 应该由运维严格把控，决不能允许自行创建任何 Topic\n        </font>\n   6. > **unclean.leader.election.enable=false** \\\n        是否允许 Unclean Leader 选举。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        坚决不能让那些落后太多的副本竞选 Leader。</font>\n   7. > **auto.leader.rebalance.enable=false** \\\n        是否允许定期进行 Leader 选举。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        换一次 Leader 代价很高的，原本向 A 发送请求的所有客户端都要切换成向 B 发送请求，而且这种换 Leader 本质上没有任何性能收益。\\\n        所以建议你在生产环境中把这个参数设置成 false。</font>\n   8. > **log.retention.{hours|minutes|ms}** \\\n        控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        虽然 ms 设置有最高的优先级，但是通常情况下我们还是设置 hours 级别的多一些，比如log.retention.hours=168表示默认保存 7 天的数据，自动删除 7 天前的数据。\\\n        如果把 Kafka 当作存储来使用，那么这个值就要相应地调大。\n        </font>\n   9. > **log.retention.bytes** \\\n        指定 Broker 为消息保存的总磁盘容量大小。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以，至少在容量方面 Broker 绝对为你开绿灯，不会做任何阻拦。\\\n        这个参数真正发挥作用的场景其实是在云上构建多租户的 Kafka 集群：设想你要做一个云上的 Kafka 服务，每个租户只能使用 100GB 的磁盘空间，\\\n        为了避免有个“恶意”租户使用过多的磁盘空间，设置这个参数就显得至关重要了。\n        </font>   \n   10. > **message.max.bytes** \\\n         控制 Broker 能够接收的最大消息大小。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，\\\n          因此在线上环境中设置一个比较大的值还是比较保险的做法。\\\n          毕竟它只是一个标尺而已，仅仅衡量 Broker 能够处理的最大消息大小，即使设置大一点也不会耗费什么磁盘空间的。\n         </font>\n - ### 防消息丢失\n    1. > **unclean.leader.election.enable = false** \\\n         它控制的是哪些 Broker 有资格竞选分区的 Leader。 \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果一个 Broker 落后原先的 Leader 太多，\\\n         那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。\n         </font>\n    2. > **replication.factor >= 3** \\\n         副本数，最好将消息多保存几份，防止消息丢失的主要机制就是冗余。\n    3. > **min.insync.replicas > 1** \\\n         该参数控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。\\\n         千万不要使用默认值 1。 \n    4. > 确保 **replication.factor > min.insync.replicas**\\\n         如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。\\\n         推荐设置成 replication.factor = min.insync.replicas + 1。\n - ### 调优吞吐量\n    1. > **num.replica.fetchers=不要超过cpu核心数** \\\n         该参数值表示的是 Follower 副本用多少个线程来拉取消息，默认使用 1 个线程。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果你的 Broker 端 CPU 资源很充足，不妨适当调大该参数值，加快 Follower 副本的同步速度。\\\n         因为在实际生产环境中，配置了 acks=all 的 Producer 程序吞吐量被拖累的首要因素，就是副本同步性能。\\\n         增加这个值后，你通常可以看到 Producer 端程序的吞吐量增加。\\\n         </font>\n    2. > **调优JVM参数，避免频繁fullGC** \n       >  - 设置堆大小(6~8GB) \n             <font face=\"幼圆\" color=\"YellowGreen\"> \\\n             6~8GB是一个普适的值，可以安心使用，如果想精确调整，建议你可以查看 GC log，\\\n             特别是关注 Full GC 之后堆上存活对象的总大小，然后把堆大小设置为该值的 1.5～2 倍。\\\n             如果你发现 Full GC 没有被执行过，手动运行 jmap -histo:live < pid > 就能人为触发 Full GC。\\\n             </font> \n             &nbsp; \n       >  - GC收集器选择(G1) \n             <font face=\"幼圆\" color=\"YellowGreen\"> \\\n            竭力避免 Full GC : 如果你的 Kafka 环境中经常出现 Full GC，你可以配置 JVM 参数 -XX:+PrintAdaptiveSizePolicy，来探查一下到底是谁导致的 Full GC。\\\n            大对象 :  所谓的大对象，一般是指至少占用半个区域（Region）大小的对象。举个例子，如果你的区域尺寸是 2MB，那么超过 1MB 大小的对象就被视为是大对象。要解决这个问题，除了增加堆大小之外，你还可以适当地增加区域大小，设置方法是增加 JVM 启动参数 -XX:+G1HeapRegionSize=N。默认情况下，如果一个对象超过了 N/2，就会被视为大对象，从而直接被分配在大对象区。如果你的 Kafka 环境中的消息体都特别大，就很容易出现这种大对象分配的问题。\n             </font>\n - ### 调优延时\n    1. > **num.replica.fetchers** \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         增加 num.replica.fetchers 值以加快 Follower 副本的拉取速度，减少整个消息处理的延时。\n         </font>\n## 2. producer 端\n  - ### 防消息丢失\n     1. > 不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。\n     2. > **acks = all** \\\n          acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。\\\n          如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。\n     3. > **retries > 0** \\\n          设置 retries 为一个较大的值。这里的 retries 为自动重试次数。、\n          当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries > 0 的 Producer 能够自动重试消息发送，避免消息丢失。\n  - ### 调优吞吐量\n    1. > **batch.size=1048576** \\\n         该参数值代表生产者一批次发送多少字节大小的数据；\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果你想要增加吞吐量，那么尽量调大该参数值，该值默认16KB，\\\n         假设你的消息体大小是 1KB，默认一个消息批次也就大约 16 条消息，显然太小了。\\\n         我们还是希望 Producer 能一次性发送更多的消息。\n         </font>\n    2. > **linger.ms** \\\n         该值是和batch.size配对使用的参数，表示每批次缓存时间；\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         也就是说，如果你设置batch.size=5000，\n         如果从上一发送批次发送到现在时间，超过了linger.ms设置的时间，那么即使未达到batch.size设置的5000，这时候也会发送。\n         </font>\n    3. > **compression.type=lz4/zstd** \\\n         配置压缩算法，减少I/O传输量，从而提升吞吐量。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         当前，和 Kafka 适配最好的两个压缩算法是 LZ4 和 zstd，不妨一试。\n         </font>\n    4. > **acks=0/1** \\\n         该参数设置是和防消息丢失配置想违背，如果你追求高吞吐量，那么就要承担消息丢失的风险。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         设置为 0, 可以不必等待副本确认就可以直接返回处理下一批数据；\\\n         设置为 1, 也只需等待一个broker副本确认提交成功，就进行下一批数据处理。\n         </font>\n    5. > **retries=0** \\\n         这个参数也和防消息丢失的配置相违背，同样的追求高吞吐量，就必须承担消息丢失风险。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         禁用重试当然会提高吞吐量，但是消息发送正确性就得不到保障，这里还是要根据自己的业务做合适的参数调整。\n         </font>\n    6. > **buffer.memory** \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果你在多个线程中共享一个 Producer 实例，就可能会碰到缓冲区不够用的情形。\n         倘若频繁地遭遇 TimeoutException：Failed to allocate memory within the configured max blocking time 这样的异常，\n         那么你就必须显式地增加 buffer.memory 参数值，确保缓冲区总是有空间可以申请的。\n         </font>\n  - ### 调优延时\n    1. > **linger.ms=0** \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         低延时，就是我们希望要把消息尽快的送出去，所以，设置这个参数为 0，意味着只要有消息就发送，不用等待。\n         </font>\n    2. > **compression.type=none** \\\n         不要设置压缩算法。\n       <font face=\"幼圆\" color=\"YellowGreen\"> \\\n       毕竟压缩也是要耗费一定的时间的。\n       </font>\n    3. > **acks=1** \\\n         该值参数尽量设置的小一点。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         Follower 副本同步往往是降低 Producer 端吞吐量和增加延时的首要原因。\n         </font>\n## 3. consumer 端\n  - ### 防消息丢失\n     1. > **enable.auto.commit=false** \\\n          确保消息消费完成再提交。并采用手动提交位移的方式。\n          这对于单 Consumer 多线程处理的场景而言是至关重要的。\n  - ### 调优吞吐量\n     1. > **采用多 Consumer 进程或线程同时消费数据。** \\\n          适当采用多线程方案增加吞吐量。\n          <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          不过该方案在实施起来是有一定的复杂度的，操作不当还会造成数据丢失，\n          我在项目中也写了一个多线程消费者的案例，欢迎大家来讨论。\n          </font>\n     2. > **fetch.min.bytes** \\\n          该参数表示 Kafka Broker 端积攒多少字节，就可以返回给 Consumer端。\\\n          <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          默认是 1 字节，表示只要 Kafka Broker 端积攒了 1 字节的数据，就可以返回给 Consumer 端，\n          这实在是太小了。我们还是让 Broker 端一次性多返回点数据吧。\n          </font>\n - ### 调优延时    \n     1. > **fetch.min.bytes=1** \\\n          <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          在 Consumer 端，我们保持 fetch.min.bytes=1 即可，也就是说，\n          只要 Broker 端有能返回的数据，立即令其返回给 Consumer，缩短 Consumer 消费延时。\n          </font>\n","source":"_posts/kafka最佳配置实践.md","raw":"---\ntitle: kafka最佳配置实践\ndate: 2021-12-23 16:01:44\ncategories:\n    - middleware\ntags: [middleware]\n---\n\n## 1. broker端\n - ### broker集群参数\n   1. > **log.dirs**: \\\n        这是非常重要的参数，指定了 Broker 需要使用的若干个文件目录路径。要知道这个参数是没有默认值的，这说明什么？这说明它必须由你亲自指定。\\\n        **log.dir**: \\\n        注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        这两个参数应该怎么设置呢？很简单，你只要设置log.dirs，即第一个参数就好了，不要设置log.dir。\\\n        而且更重要的是，在线上生产环境中一定要为log.dirs配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径，\\\n        比如/home/kafka1,/home/kafka2,/home/kafka3这样。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。</font>\n   2. > **zookeeper.connect** \\\n        如果我们是单集群，那么很简单，直接设置zookeeper.connect=zk1:2181,zk2:2181,zk3:2181即可。 \\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        这里我们主要考虑多套kafka集群公用一套zookeeper集群, 这时候我们要使用 zookeeper的 chroot，文件挂载方式实现 \\    \n        如果有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的zookeeper.connect参数可以这样指定：\\\n        zk1:2181,zk2:2181,zk3:2181/kafka1和zk1:2181,zk2:2181,zk3:2181/kafka2。\\\n        切记 chroot 只需要写一次，而且是加到最后的。\\\n        </font>\n        <font color=red>zk1:2181/kafka1,zk2:2181/kafka2,zk3:2181/kafka3</font> 这样的格式是不对的。\n   3. > **listeners: PLAINTEXT://host:9092** \\\n        监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        从构成上来说，它是若干个逗号分隔的三元组，每个三元组的格式为<协议名称，主机名，端口号>。\\\n        这里的协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；\\\n        也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092。\\\n        一旦你自己定义了协议名称，你必须还要指定listener.security.protocol.map参数告诉这个协议底层使用了哪种安全协议，\\\n        比如指定listener.security.protocol.map=CONTROLLER:PLAINTEXT表示CONTROLLER这个自定义协议底层使用明文不加密传输数据。\n        </font>\n   4. > **advertised.listeners** \\\n        和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。\n   5. > **auto.create.topics.enable=false** \\   \n        是否允许自动创建 Topic。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        建议最好设置成 false，即不允许自动创建 Topic。\\\n        Topic 应该由运维严格把控，决不能允许自行创建任何 Topic\n        </font>\n   6. > **unclean.leader.election.enable=false** \\\n        是否允许 Unclean Leader 选举。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        坚决不能让那些落后太多的副本竞选 Leader。</font>\n   7. > **auto.leader.rebalance.enable=false** \\\n        是否允许定期进行 Leader 选举。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        换一次 Leader 代价很高的，原本向 A 发送请求的所有客户端都要切换成向 B 发送请求，而且这种换 Leader 本质上没有任何性能收益。\\\n        所以建议你在生产环境中把这个参数设置成 false。</font>\n   8. > **log.retention.{hours|minutes|ms}** \\\n        控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        虽然 ms 设置有最高的优先级，但是通常情况下我们还是设置 hours 级别的多一些，比如log.retention.hours=168表示默认保存 7 天的数据，自动删除 7 天前的数据。\\\n        如果把 Kafka 当作存储来使用，那么这个值就要相应地调大。\n        </font>\n   9. > **log.retention.bytes** \\\n        指定 Broker 为消息保存的总磁盘容量大小。\\\n        <font face=\"幼圆\" color=\"YellowGreen\"> \\\n        这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以，至少在容量方面 Broker 绝对为你开绿灯，不会做任何阻拦。\\\n        这个参数真正发挥作用的场景其实是在云上构建多租户的 Kafka 集群：设想你要做一个云上的 Kafka 服务，每个租户只能使用 100GB 的磁盘空间，\\\n        为了避免有个“恶意”租户使用过多的磁盘空间，设置这个参数就显得至关重要了。\n        </font>   \n   10. > **message.max.bytes** \\\n         控制 Broker 能够接收的最大消息大小。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，\\\n          因此在线上环境中设置一个比较大的值还是比较保险的做法。\\\n          毕竟它只是一个标尺而已，仅仅衡量 Broker 能够处理的最大消息大小，即使设置大一点也不会耗费什么磁盘空间的。\n         </font>\n - ### 防消息丢失\n    1. > **unclean.leader.election.enable = false** \\\n         它控制的是哪些 Broker 有资格竞选分区的 Leader。 \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果一个 Broker 落后原先的 Leader 太多，\\\n         那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。\n         </font>\n    2. > **replication.factor >= 3** \\\n         副本数，最好将消息多保存几份，防止消息丢失的主要机制就是冗余。\n    3. > **min.insync.replicas > 1** \\\n         该参数控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。\\\n         千万不要使用默认值 1。 \n    4. > 确保 **replication.factor > min.insync.replicas**\\\n         如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。\\\n         推荐设置成 replication.factor = min.insync.replicas + 1。\n - ### 调优吞吐量\n    1. > **num.replica.fetchers=不要超过cpu核心数** \\\n         该参数值表示的是 Follower 副本用多少个线程来拉取消息，默认使用 1 个线程。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果你的 Broker 端 CPU 资源很充足，不妨适当调大该参数值，加快 Follower 副本的同步速度。\\\n         因为在实际生产环境中，配置了 acks=all 的 Producer 程序吞吐量被拖累的首要因素，就是副本同步性能。\\\n         增加这个值后，你通常可以看到 Producer 端程序的吞吐量增加。\\\n         </font>\n    2. > **调优JVM参数，避免频繁fullGC** \n       >  - 设置堆大小(6~8GB) \n             <font face=\"幼圆\" color=\"YellowGreen\"> \\\n             6~8GB是一个普适的值，可以安心使用，如果想精确调整，建议你可以查看 GC log，\\\n             特别是关注 Full GC 之后堆上存活对象的总大小，然后把堆大小设置为该值的 1.5～2 倍。\\\n             如果你发现 Full GC 没有被执行过，手动运行 jmap -histo:live < pid > 就能人为触发 Full GC。\\\n             </font> \n             &nbsp; \n       >  - GC收集器选择(G1) \n             <font face=\"幼圆\" color=\"YellowGreen\"> \\\n            竭力避免 Full GC : 如果你的 Kafka 环境中经常出现 Full GC，你可以配置 JVM 参数 -XX:+PrintAdaptiveSizePolicy，来探查一下到底是谁导致的 Full GC。\\\n            大对象 :  所谓的大对象，一般是指至少占用半个区域（Region）大小的对象。举个例子，如果你的区域尺寸是 2MB，那么超过 1MB 大小的对象就被视为是大对象。要解决这个问题，除了增加堆大小之外，你还可以适当地增加区域大小，设置方法是增加 JVM 启动参数 -XX:+G1HeapRegionSize=N。默认情况下，如果一个对象超过了 N/2，就会被视为大对象，从而直接被分配在大对象区。如果你的 Kafka 环境中的消息体都特别大，就很容易出现这种大对象分配的问题。\n             </font>\n - ### 调优延时\n    1. > **num.replica.fetchers** \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         增加 num.replica.fetchers 值以加快 Follower 副本的拉取速度，减少整个消息处理的延时。\n         </font>\n## 2. producer 端\n  - ### 防消息丢失\n     1. > 不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。\n     2. > **acks = all** \\\n          acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。\\\n          如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。\n     3. > **retries > 0** \\\n          设置 retries 为一个较大的值。这里的 retries 为自动重试次数。、\n          当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries > 0 的 Producer 能够自动重试消息发送，避免消息丢失。\n  - ### 调优吞吐量\n    1. > **batch.size=1048576** \\\n         该参数值代表生产者一批次发送多少字节大小的数据；\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果你想要增加吞吐量，那么尽量调大该参数值，该值默认16KB，\\\n         假设你的消息体大小是 1KB，默认一个消息批次也就大约 16 条消息，显然太小了。\\\n         我们还是希望 Producer 能一次性发送更多的消息。\n         </font>\n    2. > **linger.ms** \\\n         该值是和batch.size配对使用的参数，表示每批次缓存时间；\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         也就是说，如果你设置batch.size=5000，\n         如果从上一发送批次发送到现在时间，超过了linger.ms设置的时间，那么即使未达到batch.size设置的5000，这时候也会发送。\n         </font>\n    3. > **compression.type=lz4/zstd** \\\n         配置压缩算法，减少I/O传输量，从而提升吞吐量。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         当前，和 Kafka 适配最好的两个压缩算法是 LZ4 和 zstd，不妨一试。\n         </font>\n    4. > **acks=0/1** \\\n         该参数设置是和防消息丢失配置想违背，如果你追求高吞吐量，那么就要承担消息丢失的风险。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         设置为 0, 可以不必等待副本确认就可以直接返回处理下一批数据；\\\n         设置为 1, 也只需等待一个broker副本确认提交成功，就进行下一批数据处理。\n         </font>\n    5. > **retries=0** \\\n         这个参数也和防消息丢失的配置相违背，同样的追求高吞吐量，就必须承担消息丢失风险。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         禁用重试当然会提高吞吐量，但是消息发送正确性就得不到保障，这里还是要根据自己的业务做合适的参数调整。\n         </font>\n    6. > **buffer.memory** \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         如果你在多个线程中共享一个 Producer 实例，就可能会碰到缓冲区不够用的情形。\n         倘若频繁地遭遇 TimeoutException：Failed to allocate memory within the configured max blocking time 这样的异常，\n         那么你就必须显式地增加 buffer.memory 参数值，确保缓冲区总是有空间可以申请的。\n         </font>\n  - ### 调优延时\n    1. > **linger.ms=0** \\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         低延时，就是我们希望要把消息尽快的送出去，所以，设置这个参数为 0，意味着只要有消息就发送，不用等待。\n         </font>\n    2. > **compression.type=none** \\\n         不要设置压缩算法。\n       <font face=\"幼圆\" color=\"YellowGreen\"> \\\n       毕竟压缩也是要耗费一定的时间的。\n       </font>\n    3. > **acks=1** \\\n         该值参数尽量设置的小一点。\\\n         <font face=\"幼圆\" color=\"YellowGreen\"> \\\n         Follower 副本同步往往是降低 Producer 端吞吐量和增加延时的首要原因。\n         </font>\n## 3. consumer 端\n  - ### 防消息丢失\n     1. > **enable.auto.commit=false** \\\n          确保消息消费完成再提交。并采用手动提交位移的方式。\n          这对于单 Consumer 多线程处理的场景而言是至关重要的。\n  - ### 调优吞吐量\n     1. > **采用多 Consumer 进程或线程同时消费数据。** \\\n          适当采用多线程方案增加吞吐量。\n          <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          不过该方案在实施起来是有一定的复杂度的，操作不当还会造成数据丢失，\n          我在项目中也写了一个多线程消费者的案例，欢迎大家来讨论。\n          </font>\n     2. > **fetch.min.bytes** \\\n          该参数表示 Kafka Broker 端积攒多少字节，就可以返回给 Consumer端。\\\n          <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          默认是 1 字节，表示只要 Kafka Broker 端积攒了 1 字节的数据，就可以返回给 Consumer 端，\n          这实在是太小了。我们还是让 Broker 端一次性多返回点数据吧。\n          </font>\n - ### 调优延时    \n     1. > **fetch.min.bytes=1** \\\n          <font face=\"幼圆\" color=\"YellowGreen\"> \\\n          在 Consumer 端，我们保持 fetch.min.bytes=1 即可，也就是说，\n          只要 Broker 端有能返回的数据，立即令其返回给 Consumer，缩短 Consumer 消费延时。\n          </font>\n","slug":"kafka最佳配置实践","published":1,"updated":"2022-02-27T11:30:00.837Z","_id":"cl064wjw2000jlcrb7shc8ffb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-broker端\"><a href=\"#1-broker端\" class=\"headerlink\" title=\"1. broker端\"></a>1. broker端</h2><ul>\n<li><h3 id=\"broker集群参数\"><a href=\"#broker集群参数\" class=\"headerlink\" title=\"broker集群参数\"></a>broker集群参数</h3><ol>\n<li><blockquote>\n<p><strong>log.dirs</strong>: <br>  这是非常重要的参数，指定了 Broker 需要使用的若干个文件目录路径。要知道这个参数是没有默认值的，这说明什么？这说明它必须由你亲自指定。<br>  <strong>log.dir</strong>: <br>  注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  这两个参数应该怎么设置呢？很简单，你只要设置log.dirs，即第一个参数就好了，不要设置log.dir。<br>  而且更重要的是，在线上生产环境中一定要为log.dirs配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径，<br>  比如/home/kafka1,/home/kafka2,/home/kafka3这样。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。</font></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>zookeeper.connect</strong> <br>  如果我们是单集群，那么很简单，直接设置zookeeper.connect=zk1:2181,zk2:2181,zk3:2181即可。 <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  这里我们主要考虑多套kafka集群公用一套zookeeper集群, 这时候我们要使用 zookeeper的 chroot，文件挂载方式实现 \\<br>  如果有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的zookeeper.connect参数可以这样指定：<br>  zk1:2181,zk2:2181,zk3:2181/kafka1和zk1:2181,zk2:2181,zk3:2181/kafka2。<br>  切记 chroot 只需要写一次，而且是加到最后的。\\</p>\n  </font>\n  <font color=red>zk1:2181/kafka1,zk2:2181/kafka2,zk3:2181/kafka3</font> 这样的格式是不对的。</blockquote>\n</li>\n<li><blockquote>\n<p><strong>listeners: PLAINTEXT://host:9092</strong> <br>  监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  从构成上来说，它是若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;。<br>  这里的协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；<br>  也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092。<br>  一旦你自己定义了协议名称，你必须还要指定listener.security.protocol.map参数告诉这个协议底层使用了哪种安全协议，<br>  比如指定listener.security.protocol.map=CONTROLLER:PLAINTEXT表示CONTROLLER这个自定义协议底层使用明文不加密传输数据。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>advertised.listeners</strong> <br>  和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>auto.create.topics.enable=false</strong> \\<br>  是否允许自动创建 Topic。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  建议最好设置成 false，即不允许自动创建 Topic。<br>  Topic 应该由运维严格把控，决不能允许自行创建任何 Topic</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>unclean.leader.election.enable=false</strong> <br>  是否允许 Unclean Leader 选举。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  坚决不能让那些落后太多的副本竞选 Leader。</font></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>auto.leader.rebalance.enable=false</strong> <br>  是否允许定期进行 Leader 选举。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  换一次 Leader 代价很高的，原本向 A 发送请求的所有客户端都要切换成向 B 发送请求，而且这种换 Leader 本质上没有任何性能收益。<br>  所以建议你在生产环境中把这个参数设置成 false。</font></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>log.retention.{hours|minutes|ms}</strong> <br>  控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  虽然 ms 设置有最高的优先级，但是通常情况下我们还是设置 hours 级别的多一些，比如log.retention.hours=168表示默认保存 7 天的数据，自动删除 7 天前的数据。<br>  如果把 Kafka 当作存储来使用，那么这个值就要相应地调大。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>log.retention.bytes</strong> <br>  指定 Broker 为消息保存的总磁盘容量大小。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以，至少在容量方面 Broker 绝对为你开绿灯，不会做任何阻拦。<br>  这个参数真正发挥作用的场景其实是在云上构建多租户的 Kafka 集群：设想你要做一个云上的 Kafka 服务，每个租户只能使用 100GB 的磁盘空间，<br>  为了避免有个“恶意”租户使用过多的磁盘空间，设置这个参数就显得至关重要了。</p>\n  </font>   </blockquote>\n</li>\n<li><blockquote>\n<p><strong>message.max.bytes</strong> <br>  控制 Broker 能够接收的最大消息大小。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>   默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，<br>   因此在线上环境中设置一个比较大的值还是比较保险的做法。<br>   毕竟它只是一个标尺而已，仅仅衡量 Broker 能够处理的最大消息大小，即使设置大一点也不会耗费什么磁盘空间的。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"防消息丢失\"><a href=\"#防消息丢失\" class=\"headerlink\" title=\"防消息丢失\"></a>防消息丢失</h3><ol>\n<li><blockquote>\n<p><strong>unclean.leader.election.enable = false</strong> <br>  它控制的是哪些 Broker 有资格竞选分区的 Leader。 <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果一个 Broker 落后原先的 Leader 太多，<br>  那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>replication.factor &gt;= 3</strong> <br>  副本数，最好将消息多保存几份，防止消息丢失的主要机制就是冗余。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>min.insync.replicas &gt; 1</strong> <br>  该参数控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。<br>  千万不要使用默认值 1。 </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>确保 <strong>replication.factor &gt; min.insync.replicas</strong><br>  如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。<br>  推荐设置成 replication.factor = min.insync.replicas + 1。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优吞吐量\"><a href=\"#调优吞吐量\" class=\"headerlink\" title=\"调优吞吐量\"></a>调优吞吐量</h3><ol>\n<li><blockquote>\n<p><strong>num.replica.fetchers=不要超过cpu核心数</strong> <br>  该参数值表示的是 Follower 副本用多少个线程来拉取消息，默认使用 1 个线程。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果你的 Broker 端 CPU 资源很充足，不妨适当调大该参数值，加快 Follower 副本的同步速度。<br>  因为在实际生产环境中，配置了 acks=all 的 Producer 程序吞吐量被拖累的首要因素，就是副本同步性能。<br>  增加这个值后，你通常可以看到 Producer 端程序的吞吐量增加。\\</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>调优JVM参数，避免频繁fullGC</strong> </p>\n<ul>\n<li>设置堆大小(6<del>8GB)<br>   <font face=\"幼圆\" color=\"YellowGreen\"> <br>   6</del>8GB是一个普适的值，可以安心使用，如果想精确调整，建议你可以查看 GC log，<br>   特别是关注 Full GC 之后堆上存活对象的总大小，然后把堆大小设置为该值的 1.5～2 倍。<br>   如果你发现 Full GC 没有被执行过，手动运行 jmap -histo:live &lt; pid &gt; 就能人为触发 Full GC。\\   </font> \n   &nbsp; </li>\n<li>GC收集器选择(G1)<br>   <font face=\"幼圆\" color=\"YellowGreen\"> <br>  竭力避免 Full GC : 如果你的 Kafka 环境中经常出现 Full GC，你可以配置 JVM 参数 -XX:+PrintAdaptiveSizePolicy，来探查一下到底是谁导致的 Full GC。<br>  大对象 :  所谓的大对象，一般是指至少占用半个区域（Region）大小的对象。举个例子，如果你的区域尺寸是 2MB，那么超过 1MB 大小的对象就被视为是大对象。要解决这个问题，除了增加堆大小之外，你还可以适当地增加区域大小，设置方法是增加 JVM 启动参数 -XX:+G1HeapRegionSize=N。默认情况下，如果一个对象超过了 N/2，就会被视为大对象，从而直接被分配在大对象区。如果你的 Kafka 环境中的消息体都特别大，就很容易出现这种大对象分配的问题。   </font></li>\n</ul>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优延时\"><a href=\"#调优延时\" class=\"headerlink\" title=\"调优延时\"></a>调优延时</h3><ol>\n<li><blockquote>\n<p><strong>num.replica.fetchers</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  增加 num.replica.fetchers 值以加快 Follower 副本的拉取速度，减少整个消息处理的延时。</p>\n  </font>\n</blockquote>\n<h2 id=\"2-producer-端\"><a href=\"#2-producer-端\" class=\"headerlink\" title=\"2. producer 端\"></a>2. producer 端</h2></li>\n</ol>\n</li>\n<li><h3 id=\"防消息丢失-1\"><a href=\"#防消息丢失-1\" class=\"headerlink\" title=\"防消息丢失\"></a>防消息丢失</h3><ol>\n<li><blockquote>\n<p>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>acks = all</strong> <br>  acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。<br>  如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>retries &gt; 0</strong> <br>  设置 retries 为一个较大的值。这里的 retries 为自动重试次数。、<br>  当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优吞吐量-1\"><a href=\"#调优吞吐量-1\" class=\"headerlink\" title=\"调优吞吐量\"></a>调优吞吐量</h3><ol>\n<li><blockquote>\n<p><strong>batch.size=1048576</strong> <br>  该参数值代表生产者一批次发送多少字节大小的数据；<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果你想要增加吞吐量，那么尽量调大该参数值，该值默认16KB，<br>  假设你的消息体大小是 1KB，默认一个消息批次也就大约 16 条消息，显然太小了。<br>  我们还是希望 Producer 能一次性发送更多的消息。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>linger.ms</strong> <br>  该值是和batch.size配对使用的参数，表示每批次缓存时间；<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  也就是说，如果你设置batch.size=5000，<br>  如果从上一发送批次发送到现在时间，超过了linger.ms设置的时间，那么即使未达到batch.size设置的5000，这时候也会发送。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>compression.type=lz4/zstd</strong> <br>  配置压缩算法，减少I/O传输量，从而提升吞吐量。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  当前，和 Kafka 适配最好的两个压缩算法是 LZ4 和 zstd，不妨一试。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>acks=0/1</strong> <br>  该参数设置是和防消息丢失配置想违背，如果你追求高吞吐量，那么就要承担消息丢失的风险。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  设置为 0, 可以不必等待副本确认就可以直接返回处理下一批数据；<br>  设置为 1, 也只需等待一个broker副本确认提交成功，就进行下一批数据处理。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>retries=0</strong> <br>  这个参数也和防消息丢失的配置相违背，同样的追求高吞吐量，就必须承担消息丢失风险。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  禁用重试当然会提高吞吐量，但是消息发送正确性就得不到保障，这里还是要根据自己的业务做合适的参数调整。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>buffer.memory</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果你在多个线程中共享一个 Producer 实例，就可能会碰到缓冲区不够用的情形。<br>  倘若频繁地遭遇 TimeoutException：Failed to allocate memory within the configured max blocking time 这样的异常，<br>  那么你就必须显式地增加 buffer.memory 参数值，确保缓冲区总是有空间可以申请的。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优延时-1\"><a href=\"#调优延时-1\" class=\"headerlink\" title=\"调优延时\"></a>调优延时</h3><ol>\n<li><blockquote>\n<p><strong>linger.ms=0</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  低延时，就是我们希望要把消息尽快的送出去，所以，设置这个参数为 0，意味着只要有消息就发送，不用等待。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>compression.type=none</strong> <br>  不要设置压缩算法。<br><font face=\"幼圆\" color=\"YellowGreen\"> <br>毕竟压缩也是要耗费一定的时间的。</p>\n</font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>acks=1</strong> <br>  该值参数尽量设置的小一点。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  Follower 副本同步往往是降低 Producer 端吞吐量和增加延时的首要原因。</p>\n  </font>\n</blockquote>\n<h2 id=\"3-consumer-端\"><a href=\"#3-consumer-端\" class=\"headerlink\" title=\"3. consumer 端\"></a>3. consumer 端</h2></li>\n</ol>\n</li>\n<li><h3 id=\"防消息丢失-2\"><a href=\"#防消息丢失-2\" class=\"headerlink\" title=\"防消息丢失\"></a>防消息丢失</h3><ol>\n<li><blockquote>\n<p><strong>enable.auto.commit=false</strong> <br>  确保消息消费完成再提交。并采用手动提交位移的方式。<br>  这对于单 Consumer 多线程处理的场景而言是至关重要的。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优吞吐量-2\"><a href=\"#调优吞吐量-2\" class=\"headerlink\" title=\"调优吞吐量\"></a>调优吞吐量</h3><ol>\n<li><blockquote>\n<p><strong>采用多 Consumer 进程或线程同时消费数据。</strong> <br>  适当采用多线程方案增加吞吐量。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  不过该方案在实施起来是有一定的复杂度的，操作不当还会造成数据丢失，<br>  我在项目中也写了一个多线程消费者的案例，欢迎大家来讨论。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>fetch.min.bytes</strong> <br>  该参数表示 Kafka Broker 端积攒多少字节，就可以返回给 Consumer端。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  默认是 1 字节，表示只要 Kafka Broker 端积攒了 1 字节的数据，就可以返回给 Consumer 端，<br>  这实在是太小了。我们还是让 Broker 端一次性多返回点数据吧。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优延时-2\"><a href=\"#调优延时-2\" class=\"headerlink\" title=\"调优延时\"></a>调优延时</h3><ol>\n<li><blockquote>\n<p><strong>fetch.min.bytes=1</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  在 Consumer 端，我们保持 fetch.min.bytes=1 即可，也就是说，<br>  只要 Broker 端有能返回的数据，立即令其返回给 Consumer，缩短 Consumer 消费延时。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-broker端\"><a href=\"#1-broker端\" class=\"headerlink\" title=\"1. broker端\"></a>1. broker端</h2><ul>\n<li><h3 id=\"broker集群参数\"><a href=\"#broker集群参数\" class=\"headerlink\" title=\"broker集群参数\"></a>broker集群参数</h3><ol>\n<li><blockquote>\n<p><strong>log.dirs</strong>: <br>  这是非常重要的参数，指定了 Broker 需要使用的若干个文件目录路径。要知道这个参数是没有默认值的，这说明什么？这说明它必须由你亲自指定。<br>  <strong>log.dir</strong>: <br>  注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  这两个参数应该怎么设置呢？很简单，你只要设置log.dirs，即第一个参数就好了，不要设置log.dir。<br>  而且更重要的是，在线上生产环境中一定要为log.dirs配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径，<br>  比如/home/kafka1,/home/kafka2,/home/kafka3这样。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。</font></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>zookeeper.connect</strong> <br>  如果我们是单集群，那么很简单，直接设置zookeeper.connect=zk1:2181,zk2:2181,zk3:2181即可。 <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  这里我们主要考虑多套kafka集群公用一套zookeeper集群, 这时候我们要使用 zookeeper的 chroot，文件挂载方式实现 \\<br>  如果有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的zookeeper.connect参数可以这样指定：<br>  zk1:2181,zk2:2181,zk3:2181/kafka1和zk1:2181,zk2:2181,zk3:2181/kafka2。<br>  切记 chroot 只需要写一次，而且是加到最后的。\\</p>\n  </font>\n  <font color=red>zk1:2181/kafka1,zk2:2181/kafka2,zk3:2181/kafka3</font> 这样的格式是不对的。</blockquote>\n</li>\n<li><blockquote>\n<p><strong>listeners: PLAINTEXT://host:9092</strong> <br>  监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  从构成上来说，它是若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;。<br>  这里的协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；<br>  也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092。<br>  一旦你自己定义了协议名称，你必须还要指定listener.security.protocol.map参数告诉这个协议底层使用了哪种安全协议，<br>  比如指定listener.security.protocol.map=CONTROLLER:PLAINTEXT表示CONTROLLER这个自定义协议底层使用明文不加密传输数据。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>advertised.listeners</strong> <br>  和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>auto.create.topics.enable=false</strong> \\<br>  是否允许自动创建 Topic。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  建议最好设置成 false，即不允许自动创建 Topic。<br>  Topic 应该由运维严格把控，决不能允许自行创建任何 Topic</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>unclean.leader.election.enable=false</strong> <br>  是否允许 Unclean Leader 选举。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  坚决不能让那些落后太多的副本竞选 Leader。</font></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>auto.leader.rebalance.enable=false</strong> <br>  是否允许定期进行 Leader 选举。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  换一次 Leader 代价很高的，原本向 A 发送请求的所有客户端都要切换成向 B 发送请求，而且这种换 Leader 本质上没有任何性能收益。<br>  所以建议你在生产环境中把这个参数设置成 false。</font></p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>log.retention.{hours|minutes|ms}</strong> <br>  控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  虽然 ms 设置有最高的优先级，但是通常情况下我们还是设置 hours 级别的多一些，比如log.retention.hours=168表示默认保存 7 天的数据，自动删除 7 天前的数据。<br>  如果把 Kafka 当作存储来使用，那么这个值就要相应地调大。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>log.retention.bytes</strong> <br>  指定 Broker 为消息保存的总磁盘容量大小。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以，至少在容量方面 Broker 绝对为你开绿灯，不会做任何阻拦。<br>  这个参数真正发挥作用的场景其实是在云上构建多租户的 Kafka 集群：设想你要做一个云上的 Kafka 服务，每个租户只能使用 100GB 的磁盘空间，<br>  为了避免有个“恶意”租户使用过多的磁盘空间，设置这个参数就显得至关重要了。</p>\n  </font>   </blockquote>\n</li>\n<li><blockquote>\n<p><strong>message.max.bytes</strong> <br>  控制 Broker 能够接收的最大消息大小。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>   默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，<br>   因此在线上环境中设置一个比较大的值还是比较保险的做法。<br>   毕竟它只是一个标尺而已，仅仅衡量 Broker 能够处理的最大消息大小，即使设置大一点也不会耗费什么磁盘空间的。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"防消息丢失\"><a href=\"#防消息丢失\" class=\"headerlink\" title=\"防消息丢失\"></a>防消息丢失</h3><ol>\n<li><blockquote>\n<p><strong>unclean.leader.election.enable = false</strong> <br>  它控制的是哪些 Broker 有资格竞选分区的 Leader。 <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果一个 Broker 落后原先的 Leader 太多，<br>  那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>replication.factor &gt;= 3</strong> <br>  副本数，最好将消息多保存几份，防止消息丢失的主要机制就是冗余。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>min.insync.replicas &gt; 1</strong> <br>  该参数控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。<br>  千万不要使用默认值 1。 </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>确保 <strong>replication.factor &gt; min.insync.replicas</strong><br>  如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。<br>  推荐设置成 replication.factor = min.insync.replicas + 1。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优吞吐量\"><a href=\"#调优吞吐量\" class=\"headerlink\" title=\"调优吞吐量\"></a>调优吞吐量</h3><ol>\n<li><blockquote>\n<p><strong>num.replica.fetchers=不要超过cpu核心数</strong> <br>  该参数值表示的是 Follower 副本用多少个线程来拉取消息，默认使用 1 个线程。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果你的 Broker 端 CPU 资源很充足，不妨适当调大该参数值，加快 Follower 副本的同步速度。<br>  因为在实际生产环境中，配置了 acks=all 的 Producer 程序吞吐量被拖累的首要因素，就是副本同步性能。<br>  增加这个值后，你通常可以看到 Producer 端程序的吞吐量增加。\\</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>调优JVM参数，避免频繁fullGC</strong> </p>\n<ul>\n<li>设置堆大小(6<del>8GB)<br>   <font face=\"幼圆\" color=\"YellowGreen\"> <br>   6</del>8GB是一个普适的值，可以安心使用，如果想精确调整，建议你可以查看 GC log，<br>   特别是关注 Full GC 之后堆上存活对象的总大小，然后把堆大小设置为该值的 1.5～2 倍。<br>   如果你发现 Full GC 没有被执行过，手动运行 jmap -histo:live &lt; pid &gt; 就能人为触发 Full GC。\\   </font> \n   &nbsp; </li>\n<li>GC收集器选择(G1)<br>   <font face=\"幼圆\" color=\"YellowGreen\"> <br>  竭力避免 Full GC : 如果你的 Kafka 环境中经常出现 Full GC，你可以配置 JVM 参数 -XX:+PrintAdaptiveSizePolicy，来探查一下到底是谁导致的 Full GC。<br>  大对象 :  所谓的大对象，一般是指至少占用半个区域（Region）大小的对象。举个例子，如果你的区域尺寸是 2MB，那么超过 1MB 大小的对象就被视为是大对象。要解决这个问题，除了增加堆大小之外，你还可以适当地增加区域大小，设置方法是增加 JVM 启动参数 -XX:+G1HeapRegionSize=N。默认情况下，如果一个对象超过了 N/2，就会被视为大对象，从而直接被分配在大对象区。如果你的 Kafka 环境中的消息体都特别大，就很容易出现这种大对象分配的问题。   </font></li>\n</ul>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优延时\"><a href=\"#调优延时\" class=\"headerlink\" title=\"调优延时\"></a>调优延时</h3><ol>\n<li><blockquote>\n<p><strong>num.replica.fetchers</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  增加 num.replica.fetchers 值以加快 Follower 副本的拉取速度，减少整个消息处理的延时。</p>\n  </font>\n</blockquote>\n<h2 id=\"2-producer-端\"><a href=\"#2-producer-端\" class=\"headerlink\" title=\"2. producer 端\"></a>2. producer 端</h2></li>\n</ol>\n</li>\n<li><h3 id=\"防消息丢失-1\"><a href=\"#防消息丢失-1\" class=\"headerlink\" title=\"防消息丢失\"></a>防消息丢失</h3><ol>\n<li><blockquote>\n<p>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>acks = all</strong> <br>  acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。<br>  如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><strong>retries &gt; 0</strong> <br>  设置 retries 为一个较大的值。这里的 retries 为自动重试次数。、<br>  当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优吞吐量-1\"><a href=\"#调优吞吐量-1\" class=\"headerlink\" title=\"调优吞吐量\"></a>调优吞吐量</h3><ol>\n<li><blockquote>\n<p><strong>batch.size=1048576</strong> <br>  该参数值代表生产者一批次发送多少字节大小的数据；<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果你想要增加吞吐量，那么尽量调大该参数值，该值默认16KB，<br>  假设你的消息体大小是 1KB，默认一个消息批次也就大约 16 条消息，显然太小了。<br>  我们还是希望 Producer 能一次性发送更多的消息。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>linger.ms</strong> <br>  该值是和batch.size配对使用的参数，表示每批次缓存时间；<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  也就是说，如果你设置batch.size=5000，<br>  如果从上一发送批次发送到现在时间，超过了linger.ms设置的时间，那么即使未达到batch.size设置的5000，这时候也会发送。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>compression.type=lz4/zstd</strong> <br>  配置压缩算法，减少I/O传输量，从而提升吞吐量。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  当前，和 Kafka 适配最好的两个压缩算法是 LZ4 和 zstd，不妨一试。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>acks=0/1</strong> <br>  该参数设置是和防消息丢失配置想违背，如果你追求高吞吐量，那么就要承担消息丢失的风险。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  设置为 0, 可以不必等待副本确认就可以直接返回处理下一批数据；<br>  设置为 1, 也只需等待一个broker副本确认提交成功，就进行下一批数据处理。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>retries=0</strong> <br>  这个参数也和防消息丢失的配置相违背，同样的追求高吞吐量，就必须承担消息丢失风险。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  禁用重试当然会提高吞吐量，但是消息发送正确性就得不到保障，这里还是要根据自己的业务做合适的参数调整。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>buffer.memory</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  如果你在多个线程中共享一个 Producer 实例，就可能会碰到缓冲区不够用的情形。<br>  倘若频繁地遭遇 TimeoutException：Failed to allocate memory within the configured max blocking time 这样的异常，<br>  那么你就必须显式地增加 buffer.memory 参数值，确保缓冲区总是有空间可以申请的。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优延时-1\"><a href=\"#调优延时-1\" class=\"headerlink\" title=\"调优延时\"></a>调优延时</h3><ol>\n<li><blockquote>\n<p><strong>linger.ms=0</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  低延时，就是我们希望要把消息尽快的送出去，所以，设置这个参数为 0，意味着只要有消息就发送，不用等待。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>compression.type=none</strong> <br>  不要设置压缩算法。<br><font face=\"幼圆\" color=\"YellowGreen\"> <br>毕竟压缩也是要耗费一定的时间的。</p>\n</font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>acks=1</strong> <br>  该值参数尽量设置的小一点。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  Follower 副本同步往往是降低 Producer 端吞吐量和增加延时的首要原因。</p>\n  </font>\n</blockquote>\n<h2 id=\"3-consumer-端\"><a href=\"#3-consumer-端\" class=\"headerlink\" title=\"3. consumer 端\"></a>3. consumer 端</h2></li>\n</ol>\n</li>\n<li><h3 id=\"防消息丢失-2\"><a href=\"#防消息丢失-2\" class=\"headerlink\" title=\"防消息丢失\"></a>防消息丢失</h3><ol>\n<li><blockquote>\n<p><strong>enable.auto.commit=false</strong> <br>  确保消息消费完成再提交。并采用手动提交位移的方式。<br>  这对于单 Consumer 多线程处理的场景而言是至关重要的。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优吞吐量-2\"><a href=\"#调优吞吐量-2\" class=\"headerlink\" title=\"调优吞吐量\"></a>调优吞吐量</h3><ol>\n<li><blockquote>\n<p><strong>采用多 Consumer 进程或线程同时消费数据。</strong> <br>  适当采用多线程方案增加吞吐量。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  不过该方案在实施起来是有一定的复杂度的，操作不当还会造成数据丢失，<br>  我在项目中也写了一个多线程消费者的案例，欢迎大家来讨论。</p>\n  </font></blockquote>\n</li>\n<li><blockquote>\n<p><strong>fetch.min.bytes</strong> <br>  该参数表示 Kafka Broker 端积攒多少字节，就可以返回给 Consumer端。<br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  默认是 1 字节，表示只要 Kafka Broker 端积攒了 1 字节的数据，就可以返回给 Consumer 端，<br>  这实在是太小了。我们还是让 Broker 端一次性多返回点数据吧。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n<li><h3 id=\"调优延时-2\"><a href=\"#调优延时-2\" class=\"headerlink\" title=\"调优延时\"></a>调优延时</h3><ol>\n<li><blockquote>\n<p><strong>fetch.min.bytes=1</strong> <br>  <font face=\"幼圆\" color=\"YellowGreen\"> <br>  在 Consumer 端，我们保持 fetch.min.bytes=1 即可，也就是说，<br>  只要 Broker 端有能返回的数据，立即令其返回给 Consumer，缩短 Consumer 消费延时。</p>\n  </font></blockquote>\n</li>\n</ol>\n</li>\n</ul>\n"},{"title":"StatefulSet之存储状态","date":"2022-02-25T05:56:50.000Z","_content":"\n在上一篇文章中，我和你分享了 StatefulSet 如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定。\n\n而在今天这篇文章中，我将继续为你解读 StatefulSet 对存储状态的管理机制。这个机制，主要使用的是一个叫作 Persistent Volume Claim 的功能。\n\n在前面介绍 Pod 的时候，我曾提到过，要在一个 Pod 里声明 Volume，只要在 Pod 里加上 spec.volumes 字段即可。然后，你就可以在这个字段里定义一个具体类型的 Volume 了，比如：hostPath。\n\n可是，你有没有想过这样一个场景：**如果你并不知道有哪些 Volume 类型可以用，要怎么办呢？**\n\n更具体地说，作为一个应用开发者，我可能对持久化存储项目（比如 Ceph、GlusterFS 等）一窍不通，也不知道公司的 Kubernetes 集群里到底是怎么搭建出来的，我也自然不会编写它们对应的 Volume 定义文件。\n\n所谓“术业有专攻”，这些关于 Volume 的管理和远程持久化存储的知识，不仅超越了开发者的知识储备，还会有暴露公司基础设施秘密的风险。\n\n比如，下面这个例子，就是一个声明了 Ceph RBD 类型 Volume 的 Pod：\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: rbd\nspec:\n  containers:\n    - image: kubernetes/pause\n      name: rbd-rw\n      volumeMounts:\n      - name: rbdpd\n        mountPath: /mnt/rbd\n  volumes:\n    - name: rbdpd\n      rbd:\n        monitors:\n        - '10.16.154.78:6789'\n        - '10.16.154.82:6789'\n        - '10.16.154.83:6789'\n        pool: kube\n        image: foo\n        fsType: ext4\n        readOnly: true\n        user: admin\n        keyring: /etc/ceph/keyring\n        imageformat: \"2\"\n        imagefeatures: \"layering\"\n```\n\n其一，如果不懂得 Ceph RBD 的使用方法，那么这个 Pod 里 Volumes 字段，你十有八九也完全看不懂。其二，这个 Ceph RBD 对应的存储服务器的地址、用户名、授权文件的位置，也都被轻易地暴露给了全公司的所有开发人员，这是一个典型的信息被“过度暴露”的例子。\n\n这也是为什么，在后来的演化中，**Kubernetes 项目引入了一组叫作 Persistent Volume Claim（PVC）和 Persistent Volume（PV）的 API 对象，大大降低了用户声明和使用持久化 Volume 的门槛。**\n\n举个例子，有了 PVC 之后，一个开发人员想要使用一个 Volume，只需要简单的两步即可。\n\n**第一步：定义一个 PVC，声明想要的 Volume 的属性：**\n\n```yaml\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: pv-claim\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n```\n\n可以看到，在这个 PVC 对象里，不需要任何关于 Volume 细节的字段，只有描述性的属性和定义。比如，storage: 1Gi，表示我想要的 Volume 大小至少是 1 GiB；accessModes: ReadWriteOnce，表示这个 Volume 的挂载方式是可读写，并且只能被挂载在一个节点上而非被多个节点共享。\n\n> 备注：关于哪种类型的 Volume 支持哪种类型的 AccessMode，你可以查看 Kubernetes 项目官方文档中的[详细列表](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes \"Volume AccessMode\")。\n\n**第二步：在应用的 Pod 中，声明使用这个 PVC：**\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pv-pod\nspec:\n  containers:\n    - name: pv-container\n      image: nginx\n      ports:\n        - containerPort: 80\n          name: \"http-server\"\n      volumeMounts:\n        - mountPath: \"/usr/share/nginx/html\"\n          name: pv-storage\n  volumes:\n    - name: pv-storage\n      persistentVolumeClaim:\n        claimName: pv-claim\n```\n\n可以看到，在这个 Pod 的 Volumes 定义中，我们只需要声明它的类型是 persistentVolumeClaim，然后指定 PVC 的名字，而完全不必关心 Volume 本身的定义。\n\n这时候，只要我们创建这个 PVC 对象，Kubernetes 就会自动为它绑定一个符合条件的 Volume。可是，这些符合条件的 Volume 又是从哪里来的呢？\n\n答案是，它们来自于由运维人员维护的 PV（Persistent Volume）对象。接下来，我们一起看一个常见的 PV 对象的 YAML 文件：\n\n```yaml\nkind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: pv-volume\n  labels:\n    type: local\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  rbd:\n    monitors:\n    # 使用 kubectl get pods -n rook-ceph 查看 rook-ceph-mon- 开头的 POD IP 即可得下面的列表\n    - '10.16.154.78:6789'\n    - '10.16.154.82:6789'\n    - '10.16.154.83:6789'\n    pool: kube\n    image: foo\n    fsType: ext4\n    readOnly: true\n    user: admin\n    keyring: /etc/ceph/keyring\n```\n\n可以看到，这个 PV 对象的 spec.rbd 字段，正是我们前面介绍过的 Ceph RBD Volume 的详细定义。而且，它还声明了这个 PV 的容量是 10 GiB。这样，Kubernetes 就会为我们刚刚创建的 PVC 对象绑定这个 PV。\n\n所以，Kubernetes 中 PVC 和 PV 的设计，实际上类似于“接口”和“实现”的思想。开发者只要知道并会使用“接口”，即：PVC；而运维人员则负责给“接口”绑定具体的实现，即：PV。\n\n这种解耦，就避免了因为向开发者暴露过多的存储系统细节而带来的隐患。此外，这种职责的分离，往往也意味着出现事故时可以更容易定位问题和明确责任，从而避免“扯皮”现象的出现。\n\n我们还是以上一篇文章中用到的 StatefulSet 为例:\n\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  serviceName: \"nginx\"\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.9.1\n        ports:\n        - containerPort: 80\n          name: web\n        volumeMounts:\n        - name: www\n          mountPath: /usr/share/nginx/html\n  volumeClaimTemplates:\n  - metadata:\n      name: www\n    spec:\n      accessModes:\n      - ReadWriteOnce\n      resources:\n        requests:\n          storage: 1Gi\n```\n\n这次，我们为这个 StatefulSet 额外添加了一个 volumeClaimTemplates 字段。从名字就可以看出来，它跟 Deployment 里 Pod 模板（PodTemplate）的作用类似。也就是说，凡是被这个 StatefulSet 管理的 Pod，都会声明一个对应的 PVC；而这个 PVC 的定义，就来自于 volumeClaimTemplates 这个模板字段。更重要的是，这个 PVC 的名字，会被分配一个与这个 Pod 完全一致的编号。\n\n这个自动创建的 PVC，与 PV 绑定成功后，就会进入 Bound 状态，这就意味着这个 Pod 可以挂载并使用这个 PV 了。\n\n如果你还是不太理解 PVC 的话，可以先记住这样一个结论：PVC 其实就是一种特殊的 Volume。只不过一个 PVC 具体是什么类型的 Volume，要在跟某个 PV 绑定之后才知道。关于 PV、PVC 更详细的知识，我会在容器存储部分做进一步解读。\n\n当然，PVC 与 PV 的绑定得以实现的前提是，运维人员已经在系统里创建好了符合条件的 PV（比如，我们在前面用到的 pv-volume）；或者，你的 Kubernetes 集群运行在公有云上，这样 Kubernetes 就会通过 Dynamic Provisioning 的方式，自动为你创建与 PVC 匹配的 PV。\n\n所以，我们在使用 kubectl create 创建了 StatefulSet 之后，就会看到 Kubernetes 集群里出现了两个 PVC：\n\n```bash\n$ kubectl create -f statefulset.yaml\n$ kubectl get pvc -l app=nginx\nNAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE\nwww-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s\nwww-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s\n```\n\n可以看到，这些 PVC，都以“< PVC名字 >-< StatefulSet 名字 >-< 编号 >”的方式命名，并且处于 Bound 状态。\n\n我们前面已经讲到过，这个 StatefulSet 创建出来的所有 Pod，都会声明使用编号的 PVC。比如，在名叫 web-0 的 Pod 的 volumes 字段，它会声明使用名叫 www-web-0 的 PVC，从而挂载到这个 PVC 所绑定的 PV。\n\n所以，我们就可以使用如下所示的指令，在 Pod 的 Volume 目录里写入一个文件，来验证一下上述 Volume 的分配情况：\n\n```bash\n$ for i in 0 1; do kubectl exec web-$i -- sh -c 'echo hello $(hostname) > /usr/share/nginx/html/index.html'; done\n```\n\n如上所示，通过 kubectl exec 指令，我们在每个 Pod 的 Volume 目录里，写入了一个 index.html 文件。这个文件的内容，正是 Pod 的 hostname。比如，我们在 web-0 的 index.html 里写入的内容就是\"hello web-0\"。\n\n此时，如果你在这个 Pod 容器里访问“http://localhost”，你实际访问到的就是 Pod 里 Nginx 服务器进程，而它会为你返回 /usr/share/nginx/html/index.html 里的内容。这个操作的执行方法如下所示：\n\n```bash\n$ for i in 0 1; do kubectl exec -it web-$i -- curl localhost; done\nhello web-0\nhello web-1\n```\n\n现在，关键来了。\n\n如果你使用 kubectl delete 命令删除这两个 Pod，这些 Volume 里的文件会不会丢失呢？\n\n```bash\n$ kubectl delete pod -l app=nginx\npod \"web-0\" deleted\npod \"web-1\" deleted\n```\n\n可以看到，正如我们前面介绍过的，在被删除之后，这两个 Pod 会被按照编号的顺序被重新创建出来。而这时候，如果你在新创建的容器里通过访问“http://localhost”的方式去访问 web-0 里的 Nginx 服务：\n\n```bash\n# 在被重新创建出来的Pod容器里访问http://localhost\n$ kubectl exec -it web-0 -- curl localhost\nhello web-0\n```\n\n就会发现，这个请求依然会返回：hello web-0。也就是说，原先与名叫 web-0 的 Pod 绑定的 PV，在这个 Pod 被重新创建之后，依然同新的名叫 web-0 的 Pod 绑定在了一起。对于 Pod web-1 来说，也是完全一样的情况。\n\n**这是怎么做到的呢？**\n\n其实，我和你分析一下 StatefulSet 控制器恢复这个 Pod 的过程，你就可以很容易理解了。\n\n首先，当你把一个 Pod，比如 web-0，删除之后，这个 Pod 对应的 PVC 和 PV，并不会被删除，而这个 Volume 里已经写入的数据，也依然会保存在远程存储服务里（比如，我们在这个例子里用到的 Ceph 服务器）。\n\n此时，StatefulSet 控制器发现，一个名叫 web-0 的 Pod 消失了。所以，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。\n\n需要注意的是，在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作：www-web-0。这个 PVC 的定义，还是来自于 PVC 模板（volumeClaimTemplates），这是 StatefulSet 创建 Pod 的标准流程。\n\n所以，在这个新的 web-0 Pod 被创建出来之后，Kubernetes 为它查找名叫 www-web-0 的 PVC 时，就会直接找到旧 Pod 遗留下来的同名的 PVC，进而找到跟这个 PVC 绑定在一起的 PV。\n\n这样，新的 Pod 就可以挂载到旧 Pod 对应的那个 Volume，并且获取到保存在 Volume 里的数据。\n\n**通过这种方式，Kubernetes 的 StatefulSet 就实现了对应用存储状态的管理。**\n\n<font color=orange>看到这里，你是不是已经大致理解了 StatefulSet 的工作原理呢？现在，我再为你详细梳理一下吧。</font>\n\n**首先，StatefulSet 的控制器直接管理的是 Pod。**这是因为，StatefulSet 里的不同 Pod 实例，不再像 ReplicaSet 中那样都是完全一样的，而是有了细微区别的。比如，每个 Pod 的 hostname、名字等都是不同的、携带了编号的。而 StatefulSet 区分这些实例的方式，就是通过在 Pod 的名字里加上事先约定好的编号。\n\n**其次，Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录。**只要 StatefulSet 能够保证这些 Pod 名字里的编号不变，那么 Service 里类似于 web-0.nginx.default.svc.cluster.local 这样的 DNS 记录也就不会变，而这条记录解析出来的 Pod 的 IP 地址，则会随着后端 Pod 的删除和再创建而自动更新。这当然是 Service 机制本身的能力，不需要 StatefulSet 操心。\n\n**最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC。**这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。\n\n在这种情况下，即使 Pod 被删除，它所对应的 PVC 和 PV 依然会保留下来。所以当这个 Pod 被重新创建出来之后，Kubernetes 会为它找到同样编号的 PVC，挂载这个 PVC 对应的 Volume，从而获取到以前保存在 Volume 里的数据。\n\n这么一看，原本非常复杂的 StatefulSet，是不是也很容易理解了呢？\n","source":"_posts/StatefulSet之存储状态.md","raw":"---\ntitle: StatefulSet之存储状态\ndate: 2022-02-25 13:56:50\ncategories:\n    - [云原生, k8s]\ntags: \n    - k8s\n---\n\n在上一篇文章中，我和你分享了 StatefulSet 如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定。\n\n而在今天这篇文章中，我将继续为你解读 StatefulSet 对存储状态的管理机制。这个机制，主要使用的是一个叫作 Persistent Volume Claim 的功能。\n\n在前面介绍 Pod 的时候，我曾提到过，要在一个 Pod 里声明 Volume，只要在 Pod 里加上 spec.volumes 字段即可。然后，你就可以在这个字段里定义一个具体类型的 Volume 了，比如：hostPath。\n\n可是，你有没有想过这样一个场景：**如果你并不知道有哪些 Volume 类型可以用，要怎么办呢？**\n\n更具体地说，作为一个应用开发者，我可能对持久化存储项目（比如 Ceph、GlusterFS 等）一窍不通，也不知道公司的 Kubernetes 集群里到底是怎么搭建出来的，我也自然不会编写它们对应的 Volume 定义文件。\n\n所谓“术业有专攻”，这些关于 Volume 的管理和远程持久化存储的知识，不仅超越了开发者的知识储备，还会有暴露公司基础设施秘密的风险。\n\n比如，下面这个例子，就是一个声明了 Ceph RBD 类型 Volume 的 Pod：\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: rbd\nspec:\n  containers:\n    - image: kubernetes/pause\n      name: rbd-rw\n      volumeMounts:\n      - name: rbdpd\n        mountPath: /mnt/rbd\n  volumes:\n    - name: rbdpd\n      rbd:\n        monitors:\n        - '10.16.154.78:6789'\n        - '10.16.154.82:6789'\n        - '10.16.154.83:6789'\n        pool: kube\n        image: foo\n        fsType: ext4\n        readOnly: true\n        user: admin\n        keyring: /etc/ceph/keyring\n        imageformat: \"2\"\n        imagefeatures: \"layering\"\n```\n\n其一，如果不懂得 Ceph RBD 的使用方法，那么这个 Pod 里 Volumes 字段，你十有八九也完全看不懂。其二，这个 Ceph RBD 对应的存储服务器的地址、用户名、授权文件的位置，也都被轻易地暴露给了全公司的所有开发人员，这是一个典型的信息被“过度暴露”的例子。\n\n这也是为什么，在后来的演化中，**Kubernetes 项目引入了一组叫作 Persistent Volume Claim（PVC）和 Persistent Volume（PV）的 API 对象，大大降低了用户声明和使用持久化 Volume 的门槛。**\n\n举个例子，有了 PVC 之后，一个开发人员想要使用一个 Volume，只需要简单的两步即可。\n\n**第一步：定义一个 PVC，声明想要的 Volume 的属性：**\n\n```yaml\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: pv-claim\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n```\n\n可以看到，在这个 PVC 对象里，不需要任何关于 Volume 细节的字段，只有描述性的属性和定义。比如，storage: 1Gi，表示我想要的 Volume 大小至少是 1 GiB；accessModes: ReadWriteOnce，表示这个 Volume 的挂载方式是可读写，并且只能被挂载在一个节点上而非被多个节点共享。\n\n> 备注：关于哪种类型的 Volume 支持哪种类型的 AccessMode，你可以查看 Kubernetes 项目官方文档中的[详细列表](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes \"Volume AccessMode\")。\n\n**第二步：在应用的 Pod 中，声明使用这个 PVC：**\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pv-pod\nspec:\n  containers:\n    - name: pv-container\n      image: nginx\n      ports:\n        - containerPort: 80\n          name: \"http-server\"\n      volumeMounts:\n        - mountPath: \"/usr/share/nginx/html\"\n          name: pv-storage\n  volumes:\n    - name: pv-storage\n      persistentVolumeClaim:\n        claimName: pv-claim\n```\n\n可以看到，在这个 Pod 的 Volumes 定义中，我们只需要声明它的类型是 persistentVolumeClaim，然后指定 PVC 的名字，而完全不必关心 Volume 本身的定义。\n\n这时候，只要我们创建这个 PVC 对象，Kubernetes 就会自动为它绑定一个符合条件的 Volume。可是，这些符合条件的 Volume 又是从哪里来的呢？\n\n答案是，它们来自于由运维人员维护的 PV（Persistent Volume）对象。接下来，我们一起看一个常见的 PV 对象的 YAML 文件：\n\n```yaml\nkind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: pv-volume\n  labels:\n    type: local\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  rbd:\n    monitors:\n    # 使用 kubectl get pods -n rook-ceph 查看 rook-ceph-mon- 开头的 POD IP 即可得下面的列表\n    - '10.16.154.78:6789'\n    - '10.16.154.82:6789'\n    - '10.16.154.83:6789'\n    pool: kube\n    image: foo\n    fsType: ext4\n    readOnly: true\n    user: admin\n    keyring: /etc/ceph/keyring\n```\n\n可以看到，这个 PV 对象的 spec.rbd 字段，正是我们前面介绍过的 Ceph RBD Volume 的详细定义。而且，它还声明了这个 PV 的容量是 10 GiB。这样，Kubernetes 就会为我们刚刚创建的 PVC 对象绑定这个 PV。\n\n所以，Kubernetes 中 PVC 和 PV 的设计，实际上类似于“接口”和“实现”的思想。开发者只要知道并会使用“接口”，即：PVC；而运维人员则负责给“接口”绑定具体的实现，即：PV。\n\n这种解耦，就避免了因为向开发者暴露过多的存储系统细节而带来的隐患。此外，这种职责的分离，往往也意味着出现事故时可以更容易定位问题和明确责任，从而避免“扯皮”现象的出现。\n\n我们还是以上一篇文章中用到的 StatefulSet 为例:\n\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  serviceName: \"nginx\"\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.9.1\n        ports:\n        - containerPort: 80\n          name: web\n        volumeMounts:\n        - name: www\n          mountPath: /usr/share/nginx/html\n  volumeClaimTemplates:\n  - metadata:\n      name: www\n    spec:\n      accessModes:\n      - ReadWriteOnce\n      resources:\n        requests:\n          storage: 1Gi\n```\n\n这次，我们为这个 StatefulSet 额外添加了一个 volumeClaimTemplates 字段。从名字就可以看出来，它跟 Deployment 里 Pod 模板（PodTemplate）的作用类似。也就是说，凡是被这个 StatefulSet 管理的 Pod，都会声明一个对应的 PVC；而这个 PVC 的定义，就来自于 volumeClaimTemplates 这个模板字段。更重要的是，这个 PVC 的名字，会被分配一个与这个 Pod 完全一致的编号。\n\n这个自动创建的 PVC，与 PV 绑定成功后，就会进入 Bound 状态，这就意味着这个 Pod 可以挂载并使用这个 PV 了。\n\n如果你还是不太理解 PVC 的话，可以先记住这样一个结论：PVC 其实就是一种特殊的 Volume。只不过一个 PVC 具体是什么类型的 Volume，要在跟某个 PV 绑定之后才知道。关于 PV、PVC 更详细的知识，我会在容器存储部分做进一步解读。\n\n当然，PVC 与 PV 的绑定得以实现的前提是，运维人员已经在系统里创建好了符合条件的 PV（比如，我们在前面用到的 pv-volume）；或者，你的 Kubernetes 集群运行在公有云上，这样 Kubernetes 就会通过 Dynamic Provisioning 的方式，自动为你创建与 PVC 匹配的 PV。\n\n所以，我们在使用 kubectl create 创建了 StatefulSet 之后，就会看到 Kubernetes 集群里出现了两个 PVC：\n\n```bash\n$ kubectl create -f statefulset.yaml\n$ kubectl get pvc -l app=nginx\nNAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE\nwww-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s\nwww-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s\n```\n\n可以看到，这些 PVC，都以“< PVC名字 >-< StatefulSet 名字 >-< 编号 >”的方式命名，并且处于 Bound 状态。\n\n我们前面已经讲到过，这个 StatefulSet 创建出来的所有 Pod，都会声明使用编号的 PVC。比如，在名叫 web-0 的 Pod 的 volumes 字段，它会声明使用名叫 www-web-0 的 PVC，从而挂载到这个 PVC 所绑定的 PV。\n\n所以，我们就可以使用如下所示的指令，在 Pod 的 Volume 目录里写入一个文件，来验证一下上述 Volume 的分配情况：\n\n```bash\n$ for i in 0 1; do kubectl exec web-$i -- sh -c 'echo hello $(hostname) > /usr/share/nginx/html/index.html'; done\n```\n\n如上所示，通过 kubectl exec 指令，我们在每个 Pod 的 Volume 目录里，写入了一个 index.html 文件。这个文件的内容，正是 Pod 的 hostname。比如，我们在 web-0 的 index.html 里写入的内容就是\"hello web-0\"。\n\n此时，如果你在这个 Pod 容器里访问“http://localhost”，你实际访问到的就是 Pod 里 Nginx 服务器进程，而它会为你返回 /usr/share/nginx/html/index.html 里的内容。这个操作的执行方法如下所示：\n\n```bash\n$ for i in 0 1; do kubectl exec -it web-$i -- curl localhost; done\nhello web-0\nhello web-1\n```\n\n现在，关键来了。\n\n如果你使用 kubectl delete 命令删除这两个 Pod，这些 Volume 里的文件会不会丢失呢？\n\n```bash\n$ kubectl delete pod -l app=nginx\npod \"web-0\" deleted\npod \"web-1\" deleted\n```\n\n可以看到，正如我们前面介绍过的，在被删除之后，这两个 Pod 会被按照编号的顺序被重新创建出来。而这时候，如果你在新创建的容器里通过访问“http://localhost”的方式去访问 web-0 里的 Nginx 服务：\n\n```bash\n# 在被重新创建出来的Pod容器里访问http://localhost\n$ kubectl exec -it web-0 -- curl localhost\nhello web-0\n```\n\n就会发现，这个请求依然会返回：hello web-0。也就是说，原先与名叫 web-0 的 Pod 绑定的 PV，在这个 Pod 被重新创建之后，依然同新的名叫 web-0 的 Pod 绑定在了一起。对于 Pod web-1 来说，也是完全一样的情况。\n\n**这是怎么做到的呢？**\n\n其实，我和你分析一下 StatefulSet 控制器恢复这个 Pod 的过程，你就可以很容易理解了。\n\n首先，当你把一个 Pod，比如 web-0，删除之后，这个 Pod 对应的 PVC 和 PV，并不会被删除，而这个 Volume 里已经写入的数据，也依然会保存在远程存储服务里（比如，我们在这个例子里用到的 Ceph 服务器）。\n\n此时，StatefulSet 控制器发现，一个名叫 web-0 的 Pod 消失了。所以，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。\n\n需要注意的是，在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作：www-web-0。这个 PVC 的定义，还是来自于 PVC 模板（volumeClaimTemplates），这是 StatefulSet 创建 Pod 的标准流程。\n\n所以，在这个新的 web-0 Pod 被创建出来之后，Kubernetes 为它查找名叫 www-web-0 的 PVC 时，就会直接找到旧 Pod 遗留下来的同名的 PVC，进而找到跟这个 PVC 绑定在一起的 PV。\n\n这样，新的 Pod 就可以挂载到旧 Pod 对应的那个 Volume，并且获取到保存在 Volume 里的数据。\n\n**通过这种方式，Kubernetes 的 StatefulSet 就实现了对应用存储状态的管理。**\n\n<font color=orange>看到这里，你是不是已经大致理解了 StatefulSet 的工作原理呢？现在，我再为你详细梳理一下吧。</font>\n\n**首先，StatefulSet 的控制器直接管理的是 Pod。**这是因为，StatefulSet 里的不同 Pod 实例，不再像 ReplicaSet 中那样都是完全一样的，而是有了细微区别的。比如，每个 Pod 的 hostname、名字等都是不同的、携带了编号的。而 StatefulSet 区分这些实例的方式，就是通过在 Pod 的名字里加上事先约定好的编号。\n\n**其次，Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录。**只要 StatefulSet 能够保证这些 Pod 名字里的编号不变，那么 Service 里类似于 web-0.nginx.default.svc.cluster.local 这样的 DNS 记录也就不会变，而这条记录解析出来的 Pod 的 IP 地址，则会随着后端 Pod 的删除和再创建而自动更新。这当然是 Service 机制本身的能力，不需要 StatefulSet 操心。\n\n**最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC。**这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。\n\n在这种情况下，即使 Pod 被删除，它所对应的 PVC 和 PV 依然会保留下来。所以当这个 Pod 被重新创建出来之后，Kubernetes 会为它找到同样编号的 PVC，挂载这个 PVC 对应的 Volume，从而获取到以前保存在 Volume 里的数据。\n\n这么一看，原本非常复杂的 StatefulSet，是不是也很容易理解了呢？\n","slug":"StatefulSet之存储状态","published":1,"updated":"2022-02-28T03:25:51.390Z","_id":"cl064wjw3000mlcrb7zszb90u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在上一篇文章中，我和你分享了 StatefulSet 如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定。</p>\n<p>而在今天这篇文章中，我将继续为你解读 StatefulSet 对存储状态的管理机制。这个机制，主要使用的是一个叫作 Persistent Volume Claim 的功能。</p>\n<p>在前面介绍 Pod 的时候，我曾提到过，要在一个 Pod 里声明 Volume，只要在 Pod 里加上 spec.volumes 字段即可。然后，你就可以在这个字段里定义一个具体类型的 Volume 了，比如：hostPath。</p>\n<p>可是，你有没有想过这样一个场景：<strong>如果你并不知道有哪些 Volume 类型可以用，要怎么办呢？</strong></p>\n<p>更具体地说，作为一个应用开发者，我可能对持久化存储项目（比如 Ceph、GlusterFS 等）一窍不通，也不知道公司的 Kubernetes 集群里到底是怎么搭建出来的，我也自然不会编写它们对应的 Volume 定义文件。</p>\n<p>所谓“术业有专攻”，这些关于 Volume 的管理和远程持久化存储的知识，不仅超越了开发者的知识储备，还会有暴露公司基础设施秘密的风险。</p>\n<p>比如，下面这个例子，就是一个声明了 Ceph RBD 类型 Volume 的 Pod：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">rbd</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">kubernetes/pause</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">rbd-rw</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">rbdpd</span></span><br><span class=\"line\">        <span class=\"attr\">mountPath:</span> <span class=\"string\">/mnt/rbd</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">rbdpd</span></span><br><span class=\"line\">      <span class=\"attr\">rbd:</span></span><br><span class=\"line\">        <span class=\"attr\">monitors:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.78:6789&#x27;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.82:6789&#x27;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.83:6789&#x27;</span></span><br><span class=\"line\">        <span class=\"attr\">pool:</span> <span class=\"string\">kube</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\">        <span class=\"attr\">fsType:</span> <span class=\"string\">ext4</span></span><br><span class=\"line\">        <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"attr\">user:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">        <span class=\"attr\">keyring:</span> <span class=\"string\">/etc/ceph/keyring</span></span><br><span class=\"line\">        <span class=\"attr\">imageformat:</span> <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">imagefeatures:</span> <span class=\"string\">&quot;layering&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>其一，如果不懂得 Ceph RBD 的使用方法，那么这个 Pod 里 Volumes 字段，你十有八九也完全看不懂。其二，这个 Ceph RBD 对应的存储服务器的地址、用户名、授权文件的位置，也都被轻易地暴露给了全公司的所有开发人员，这是一个典型的信息被“过度暴露”的例子。</p>\n<p>这也是为什么，在后来的演化中，<strong>Kubernetes 项目引入了一组叫作 Persistent Volume Claim（PVC）和 Persistent Volume（PV）的 API 对象，大大降低了用户声明和使用持久化 Volume 的门槛。</strong></p>\n<p>举个例子，有了 PVC 之后，一个开发人员想要使用一个 Volume，只需要简单的两步即可。</p>\n<p><strong>第一步：定义一个 PVC，声明想要的 Volume 的属性：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-claim</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个 PVC 对象里，不需要任何关于 Volume 细节的字段，只有描述性的属性和定义。比如，storage: 1Gi，表示我想要的 Volume 大小至少是 1 GiB；accessModes: ReadWriteOnce，表示这个 Volume 的挂载方式是可读写，并且只能被挂载在一个节点上而非被多个节点共享。</p>\n<blockquote>\n<p>备注：关于哪种类型的 Volume 支持哪种类型的 AccessMode，你可以查看 Kubernetes 项目官方文档中的<a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes\" title=\"Volume AccessMode\">详细列表</a>。</p>\n</blockquote>\n<p><strong>第二步：在应用的 Pod 中，声明使用这个 PVC：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">pv-container</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">&quot;http-server&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">mountPath:</span> <span class=\"string\">&quot;/usr/share/nginx/html&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">pv-storage</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">pv-storage</span></span><br><span class=\"line\">      <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">        <span class=\"attr\">claimName:</span> <span class=\"string\">pv-claim</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个 Pod 的 Volumes 定义中，我们只需要声明它的类型是 persistentVolumeClaim，然后指定 PVC 的名字，而完全不必关心 Volume 本身的定义。</p>\n<p>这时候，只要我们创建这个 PVC 对象，Kubernetes 就会自动为它绑定一个符合条件的 Volume。可是，这些符合条件的 Volume 又是从哪里来的呢？</p>\n<p>答案是，它们来自于由运维人员维护的 PV（Persistent Volume）对象。接下来，我们一起看一个常见的 PV 对象的 YAML 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-volume</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">local</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">rbd:</span></span><br><span class=\"line\">    <span class=\"attr\">monitors:</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 kubectl get pods -n rook-ceph 查看 rook-ceph-mon- 开头的 POD IP 即可得下面的列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.78:6789&#x27;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.82:6789&#x27;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.83:6789&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">pool:</span> <span class=\"string\">kube</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\">    <span class=\"attr\">fsType:</span> <span class=\"string\">ext4</span></span><br><span class=\"line\">    <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">user:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">    <span class=\"attr\">keyring:</span> <span class=\"string\">/etc/ceph/keyring</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个 PV 对象的 spec.rbd 字段，正是我们前面介绍过的 Ceph RBD Volume 的详细定义。而且，它还声明了这个 PV 的容量是 10 GiB。这样，Kubernetes 就会为我们刚刚创建的 PVC 对象绑定这个 PV。</p>\n<p>所以，Kubernetes 中 PVC 和 PV 的设计，实际上类似于“接口”和“实现”的思想。开发者只要知道并会使用“接口”，即：PVC；而运维人员则负责给“接口”绑定具体的实现，即：PV。</p>\n<p>这种解耦，就避免了因为向开发者暴露过多的存储系统细节而带来的隐患。此外，这种职责的分离，往往也意味着出现事故时可以更容易定位问题和明确责任，从而避免“扯皮”现象的出现。</p>\n<p>我们还是以上一篇文章中用到的 StatefulSet 为例:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.9.1</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">www</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/usr/share/nginx/html</span></span><br><span class=\"line\">  <span class=\"attr\">volumeClaimTemplates:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">www</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">          <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br></pre></td></tr></table></figure>\n\n<p>这次，我们为这个 StatefulSet 额外添加了一个 volumeClaimTemplates 字段。从名字就可以看出来，它跟 Deployment 里 Pod 模板（PodTemplate）的作用类似。也就是说，凡是被这个 StatefulSet 管理的 Pod，都会声明一个对应的 PVC；而这个 PVC 的定义，就来自于 volumeClaimTemplates 这个模板字段。更重要的是，这个 PVC 的名字，会被分配一个与这个 Pod 完全一致的编号。</p>\n<p>这个自动创建的 PVC，与 PV 绑定成功后，就会进入 Bound 状态，这就意味着这个 Pod 可以挂载并使用这个 PV 了。</p>\n<p>如果你还是不太理解 PVC 的话，可以先记住这样一个结论：PVC 其实就是一种特殊的 Volume。只不过一个 PVC 具体是什么类型的 Volume，要在跟某个 PV 绑定之后才知道。关于 PV、PVC 更详细的知识，我会在容器存储部分做进一步解读。</p>\n<p>当然，PVC 与 PV 的绑定得以实现的前提是，运维人员已经在系统里创建好了符合条件的 PV（比如，我们在前面用到的 pv-volume）；或者，你的 Kubernetes 集群运行在公有云上，这样 Kubernetes 就会通过 Dynamic Provisioning 的方式，自动为你创建与 PVC 匹配的 PV。</p>\n<p>所以，我们在使用 kubectl create 创建了 StatefulSet 之后，就会看到 Kubernetes 集群里出现了两个 PVC：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl create -f statefulset.yaml</span><br><span class=\"line\">$ kubectl get pvc -l app=nginx</span><br><span class=\"line\">NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE</span><br><span class=\"line\">www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s</span><br><span class=\"line\">www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这些 PVC，都以“&lt; PVC名字 &gt;-&lt; StatefulSet 名字 &gt;-&lt; 编号 &gt;”的方式命名，并且处于 Bound 状态。</p>\n<p>我们前面已经讲到过，这个 StatefulSet 创建出来的所有 Pod，都会声明使用编号的 PVC。比如，在名叫 web-0 的 Pod 的 volumes 字段，它会声明使用名叫 www-web-0 的 PVC，从而挂载到这个 PVC 所绑定的 PV。</p>\n<p>所以，我们就可以使用如下所示的指令，在 Pod 的 Volume 目录里写入一个文件，来验证一下上述 Volume 的分配情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0 1; <span class=\"keyword\">do</span> kubectl <span class=\"built_in\">exec</span> web-<span class=\"variable\">$i</span> -- sh -c <span class=\"string\">&#x27;echo hello $(hostname) &gt; /usr/share/nginx/html/index.html&#x27;</span>; <span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>如上所示，通过 kubectl exec 指令，我们在每个 Pod 的 Volume 目录里，写入了一个 index.html 文件。这个文件的内容，正是 Pod 的 hostname。比如，我们在 web-0 的 index.html 里写入的内容就是”hello web-0”。</p>\n<p>此时，如果你在这个 Pod 容器里访问“<a href=\"http://localhost”,你实际访问到的就是/\">http://localhost”，你实际访问到的就是</a> Pod 里 Nginx 服务器进程，而它会为你返回 /usr/share/nginx/html/index.html 里的内容。这个操作的执行方法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0 1; <span class=\"keyword\">do</span> kubectl <span class=\"built_in\">exec</span> -it web-<span class=\"variable\">$i</span> -- curl localhost; <span class=\"keyword\">done</span></span><br><span class=\"line\">hello web-0</span><br><span class=\"line\">hello web-1</span><br></pre></td></tr></table></figure>\n\n<p>现在，关键来了。</p>\n<p>如果你使用 kubectl delete 命令删除这两个 Pod，这些 Volume 里的文件会不会丢失呢？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pod -l app=nginx</span><br><span class=\"line\">pod <span class=\"string\">&quot;web-0&quot;</span> deleted</span><br><span class=\"line\">pod <span class=\"string\">&quot;web-1&quot;</span> deleted</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，正如我们前面介绍过的，在被删除之后，这两个 Pod 会被按照编号的顺序被重新创建出来。而这时候，如果你在新创建的容器里通过访问“<a href=\"http://localhost”的方式去访问/\">http://localhost”的方式去访问</a> web-0 里的 Nginx 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在被重新创建出来的Pod容器里访问http://localhost</span></span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> -it web-0 -- curl localhost</span><br><span class=\"line\">hello web-0</span><br></pre></td></tr></table></figure>\n\n<p>就会发现，这个请求依然会返回：hello web-0。也就是说，原先与名叫 web-0 的 Pod 绑定的 PV，在这个 Pod 被重新创建之后，依然同新的名叫 web-0 的 Pod 绑定在了一起。对于 Pod web-1 来说，也是完全一样的情况。</p>\n<p><strong>这是怎么做到的呢？</strong></p>\n<p>其实，我和你分析一下 StatefulSet 控制器恢复这个 Pod 的过程，你就可以很容易理解了。</p>\n<p>首先，当你把一个 Pod，比如 web-0，删除之后，这个 Pod 对应的 PVC 和 PV，并不会被删除，而这个 Volume 里已经写入的数据，也依然会保存在远程存储服务里（比如，我们在这个例子里用到的 Ceph 服务器）。</p>\n<p>此时，StatefulSet 控制器发现，一个名叫 web-0 的 Pod 消失了。所以，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。</p>\n<p>需要注意的是，在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作：www-web-0。这个 PVC 的定义，还是来自于 PVC 模板（volumeClaimTemplates），这是 StatefulSet 创建 Pod 的标准流程。</p>\n<p>所以，在这个新的 web-0 Pod 被创建出来之后，Kubernetes 为它查找名叫 www-web-0 的 PVC 时，就会直接找到旧 Pod 遗留下来的同名的 PVC，进而找到跟这个 PVC 绑定在一起的 PV。</p>\n<p>这样，新的 Pod 就可以挂载到旧 Pod 对应的那个 Volume，并且获取到保存在 Volume 里的数据。</p>\n<p><strong>通过这种方式，Kubernetes 的 StatefulSet 就实现了对应用存储状态的管理。</strong></p>\n<p><font color=orange>看到这里，你是不是已经大致理解了 StatefulSet 的工作原理呢？现在，我再为你详细梳理一下吧。</font></p>\n<p><strong>首先，StatefulSet 的控制器直接管理的是 Pod。</strong>这是因为，StatefulSet 里的不同 Pod 实例，不再像 ReplicaSet 中那样都是完全一样的，而是有了细微区别的。比如，每个 Pod 的 hostname、名字等都是不同的、携带了编号的。而 StatefulSet 区分这些实例的方式，就是通过在 Pod 的名字里加上事先约定好的编号。</p>\n<p><strong>其次，Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录。</strong>只要 StatefulSet 能够保证这些 Pod 名字里的编号不变，那么 Service 里类似于 web-0.nginx.default.svc.cluster.local 这样的 DNS 记录也就不会变，而这条记录解析出来的 Pod 的 IP 地址，则会随着后端 Pod 的删除和再创建而自动更新。这当然是 Service 机制本身的能力，不需要 StatefulSet 操心。</p>\n<p><strong>最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC。</strong>这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。</p>\n<p>在这种情况下，即使 Pod 被删除，它所对应的 PVC 和 PV 依然会保留下来。所以当这个 Pod 被重新创建出来之后，Kubernetes 会为它找到同样编号的 PVC，挂载这个 PVC 对应的 Volume，从而获取到以前保存在 Volume 里的数据。</p>\n<p>这么一看，原本非常复杂的 StatefulSet，是不是也很容易理解了呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在上一篇文章中，我和你分享了 StatefulSet 如何保证应用实例的拓扑状态，在 Pod 删除和再创建的过程中保持稳定。</p>\n<p>而在今天这篇文章中，我将继续为你解读 StatefulSet 对存储状态的管理机制。这个机制，主要使用的是一个叫作 Persistent Volume Claim 的功能。</p>\n<p>在前面介绍 Pod 的时候，我曾提到过，要在一个 Pod 里声明 Volume，只要在 Pod 里加上 spec.volumes 字段即可。然后，你就可以在这个字段里定义一个具体类型的 Volume 了，比如：hostPath。</p>\n<p>可是，你有没有想过这样一个场景：<strong>如果你并不知道有哪些 Volume 类型可以用，要怎么办呢？</strong></p>\n<p>更具体地说，作为一个应用开发者，我可能对持久化存储项目（比如 Ceph、GlusterFS 等）一窍不通，也不知道公司的 Kubernetes 集群里到底是怎么搭建出来的，我也自然不会编写它们对应的 Volume 定义文件。</p>\n<p>所谓“术业有专攻”，这些关于 Volume 的管理和远程持久化存储的知识，不仅超越了开发者的知识储备，还会有暴露公司基础设施秘密的风险。</p>\n<p>比如，下面这个例子，就是一个声明了 Ceph RBD 类型 Volume 的 Pod：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">rbd</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">kubernetes/pause</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">rbd-rw</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">rbdpd</span></span><br><span class=\"line\">        <span class=\"attr\">mountPath:</span> <span class=\"string\">/mnt/rbd</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">rbdpd</span></span><br><span class=\"line\">      <span class=\"attr\">rbd:</span></span><br><span class=\"line\">        <span class=\"attr\">monitors:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.78:6789&#x27;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.82:6789&#x27;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.83:6789&#x27;</span></span><br><span class=\"line\">        <span class=\"attr\">pool:</span> <span class=\"string\">kube</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\">        <span class=\"attr\">fsType:</span> <span class=\"string\">ext4</span></span><br><span class=\"line\">        <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"attr\">user:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">        <span class=\"attr\">keyring:</span> <span class=\"string\">/etc/ceph/keyring</span></span><br><span class=\"line\">        <span class=\"attr\">imageformat:</span> <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">imagefeatures:</span> <span class=\"string\">&quot;layering&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>其一，如果不懂得 Ceph RBD 的使用方法，那么这个 Pod 里 Volumes 字段，你十有八九也完全看不懂。其二，这个 Ceph RBD 对应的存储服务器的地址、用户名、授权文件的位置，也都被轻易地暴露给了全公司的所有开发人员，这是一个典型的信息被“过度暴露”的例子。</p>\n<p>这也是为什么，在后来的演化中，<strong>Kubernetes 项目引入了一组叫作 Persistent Volume Claim（PVC）和 Persistent Volume（PV）的 API 对象，大大降低了用户声明和使用持久化 Volume 的门槛。</strong></p>\n<p>举个例子，有了 PVC 之后，一个开发人员想要使用一个 Volume，只需要简单的两步即可。</p>\n<p><strong>第一步：定义一个 PVC，声明想要的 Volume 的属性：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-claim</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个 PVC 对象里，不需要任何关于 Volume 细节的字段，只有描述性的属性和定义。比如，storage: 1Gi，表示我想要的 Volume 大小至少是 1 GiB；accessModes: ReadWriteOnce，表示这个 Volume 的挂载方式是可读写，并且只能被挂载在一个节点上而非被多个节点共享。</p>\n<blockquote>\n<p>备注：关于哪种类型的 Volume 支持哪种类型的 AccessMode，你可以查看 Kubernetes 项目官方文档中的<a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes\" title=\"Volume AccessMode\">详细列表</a>。</p>\n</blockquote>\n<p><strong>第二步：在应用的 Pod 中，声明使用这个 PVC：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">pv-container</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">&quot;http-server&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">mountPath:</span> <span class=\"string\">&quot;/usr/share/nginx/html&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">pv-storage</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">pv-storage</span></span><br><span class=\"line\">      <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">        <span class=\"attr\">claimName:</span> <span class=\"string\">pv-claim</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个 Pod 的 Volumes 定义中，我们只需要声明它的类型是 persistentVolumeClaim，然后指定 PVC 的名字，而完全不必关心 Volume 本身的定义。</p>\n<p>这时候，只要我们创建这个 PVC 对象，Kubernetes 就会自动为它绑定一个符合条件的 Volume。可是，这些符合条件的 Volume 又是从哪里来的呢？</p>\n<p>答案是，它们来自于由运维人员维护的 PV（Persistent Volume）对象。接下来，我们一起看一个常见的 PV 对象的 YAML 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pv-volume</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">local</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">rbd:</span></span><br><span class=\"line\">    <span class=\"attr\">monitors:</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 kubectl get pods -n rook-ceph 查看 rook-ceph-mon- 开头的 POD IP 即可得下面的列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.78:6789&#x27;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.82:6789&#x27;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&#x27;10.16.154.83:6789&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">pool:</span> <span class=\"string\">kube</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\">    <span class=\"attr\">fsType:</span> <span class=\"string\">ext4</span></span><br><span class=\"line\">    <span class=\"attr\">readOnly:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">user:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">    <span class=\"attr\">keyring:</span> <span class=\"string\">/etc/ceph/keyring</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个 PV 对象的 spec.rbd 字段，正是我们前面介绍过的 Ceph RBD Volume 的详细定义。而且，它还声明了这个 PV 的容量是 10 GiB。这样，Kubernetes 就会为我们刚刚创建的 PVC 对象绑定这个 PV。</p>\n<p>所以，Kubernetes 中 PVC 和 PV 的设计，实际上类似于“接口”和“实现”的思想。开发者只要知道并会使用“接口”，即：PVC；而运维人员则负责给“接口”绑定具体的实现，即：PV。</p>\n<p>这种解耦，就避免了因为向开发者暴露过多的存储系统细节而带来的隐患。此外，这种职责的分离，往往也意味着出现事故时可以更容易定位问题和明确责任，从而避免“扯皮”现象的出现。</p>\n<p>我们还是以上一篇文章中用到的 StatefulSet 为例:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.9.1</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">web</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">www</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/usr/share/nginx/html</span></span><br><span class=\"line\">  <span class=\"attr\">volumeClaimTemplates:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">www</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">          <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br></pre></td></tr></table></figure>\n\n<p>这次，我们为这个 StatefulSet 额外添加了一个 volumeClaimTemplates 字段。从名字就可以看出来，它跟 Deployment 里 Pod 模板（PodTemplate）的作用类似。也就是说，凡是被这个 StatefulSet 管理的 Pod，都会声明一个对应的 PVC；而这个 PVC 的定义，就来自于 volumeClaimTemplates 这个模板字段。更重要的是，这个 PVC 的名字，会被分配一个与这个 Pod 完全一致的编号。</p>\n<p>这个自动创建的 PVC，与 PV 绑定成功后，就会进入 Bound 状态，这就意味着这个 Pod 可以挂载并使用这个 PV 了。</p>\n<p>如果你还是不太理解 PVC 的话，可以先记住这样一个结论：PVC 其实就是一种特殊的 Volume。只不过一个 PVC 具体是什么类型的 Volume，要在跟某个 PV 绑定之后才知道。关于 PV、PVC 更详细的知识，我会在容器存储部分做进一步解读。</p>\n<p>当然，PVC 与 PV 的绑定得以实现的前提是，运维人员已经在系统里创建好了符合条件的 PV（比如，我们在前面用到的 pv-volume）；或者，你的 Kubernetes 集群运行在公有云上，这样 Kubernetes 就会通过 Dynamic Provisioning 的方式，自动为你创建与 PVC 匹配的 PV。</p>\n<p>所以，我们在使用 kubectl create 创建了 StatefulSet 之后，就会看到 Kubernetes 集群里出现了两个 PVC：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl create -f statefulset.yaml</span><br><span class=\"line\">$ kubectl get pvc -l app=nginx</span><br><span class=\"line\">NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE</span><br><span class=\"line\">www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s</span><br><span class=\"line\">www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这些 PVC，都以“&lt; PVC名字 &gt;-&lt; StatefulSet 名字 &gt;-&lt; 编号 &gt;”的方式命名，并且处于 Bound 状态。</p>\n<p>我们前面已经讲到过，这个 StatefulSet 创建出来的所有 Pod，都会声明使用编号的 PVC。比如，在名叫 web-0 的 Pod 的 volumes 字段，它会声明使用名叫 www-web-0 的 PVC，从而挂载到这个 PVC 所绑定的 PV。</p>\n<p>所以，我们就可以使用如下所示的指令，在 Pod 的 Volume 目录里写入一个文件，来验证一下上述 Volume 的分配情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0 1; <span class=\"keyword\">do</span> kubectl <span class=\"built_in\">exec</span> web-<span class=\"variable\">$i</span> -- sh -c <span class=\"string\">&#x27;echo hello $(hostname) &gt; /usr/share/nginx/html/index.html&#x27;</span>; <span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>如上所示，通过 kubectl exec 指令，我们在每个 Pod 的 Volume 目录里，写入了一个 index.html 文件。这个文件的内容，正是 Pod 的 hostname。比如，我们在 web-0 的 index.html 里写入的内容就是”hello web-0”。</p>\n<p>此时，如果你在这个 Pod 容器里访问“<a href=\"http://localhost”,你实际访问到的就是/\">http://localhost”，你实际访问到的就是</a> Pod 里 Nginx 服务器进程，而它会为你返回 /usr/share/nginx/html/index.html 里的内容。这个操作的执行方法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0 1; <span class=\"keyword\">do</span> kubectl <span class=\"built_in\">exec</span> -it web-<span class=\"variable\">$i</span> -- curl localhost; <span class=\"keyword\">done</span></span><br><span class=\"line\">hello web-0</span><br><span class=\"line\">hello web-1</span><br></pre></td></tr></table></figure>\n\n<p>现在，关键来了。</p>\n<p>如果你使用 kubectl delete 命令删除这两个 Pod，这些 Volume 里的文件会不会丢失呢？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pod -l app=nginx</span><br><span class=\"line\">pod <span class=\"string\">&quot;web-0&quot;</span> deleted</span><br><span class=\"line\">pod <span class=\"string\">&quot;web-1&quot;</span> deleted</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，正如我们前面介绍过的，在被删除之后，这两个 Pod 会被按照编号的顺序被重新创建出来。而这时候，如果你在新创建的容器里通过访问“<a href=\"http://localhost”的方式去访问/\">http://localhost”的方式去访问</a> web-0 里的 Nginx 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在被重新创建出来的Pod容器里访问http://localhost</span></span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> -it web-0 -- curl localhost</span><br><span class=\"line\">hello web-0</span><br></pre></td></tr></table></figure>\n\n<p>就会发现，这个请求依然会返回：hello web-0。也就是说，原先与名叫 web-0 的 Pod 绑定的 PV，在这个 Pod 被重新创建之后，依然同新的名叫 web-0 的 Pod 绑定在了一起。对于 Pod web-1 来说，也是完全一样的情况。</p>\n<p><strong>这是怎么做到的呢？</strong></p>\n<p>其实，我和你分析一下 StatefulSet 控制器恢复这个 Pod 的过程，你就可以很容易理解了。</p>\n<p>首先，当你把一个 Pod，比如 web-0，删除之后，这个 Pod 对应的 PVC 和 PV，并不会被删除，而这个 Volume 里已经写入的数据，也依然会保存在远程存储服务里（比如，我们在这个例子里用到的 Ceph 服务器）。</p>\n<p>此时，StatefulSet 控制器发现，一个名叫 web-0 的 Pod 消失了。所以，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。</p>\n<p>需要注意的是，在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作：www-web-0。这个 PVC 的定义，还是来自于 PVC 模板（volumeClaimTemplates），这是 StatefulSet 创建 Pod 的标准流程。</p>\n<p>所以，在这个新的 web-0 Pod 被创建出来之后，Kubernetes 为它查找名叫 www-web-0 的 PVC 时，就会直接找到旧 Pod 遗留下来的同名的 PVC，进而找到跟这个 PVC 绑定在一起的 PV。</p>\n<p>这样，新的 Pod 就可以挂载到旧 Pod 对应的那个 Volume，并且获取到保存在 Volume 里的数据。</p>\n<p><strong>通过这种方式，Kubernetes 的 StatefulSet 就实现了对应用存储状态的管理。</strong></p>\n<p><font color=orange>看到这里，你是不是已经大致理解了 StatefulSet 的工作原理呢？现在，我再为你详细梳理一下吧。</font></p>\n<p><strong>首先，StatefulSet 的控制器直接管理的是 Pod。</strong>这是因为，StatefulSet 里的不同 Pod 实例，不再像 ReplicaSet 中那样都是完全一样的，而是有了细微区别的。比如，每个 Pod 的 hostname、名字等都是不同的、携带了编号的。而 StatefulSet 区分这些实例的方式，就是通过在 Pod 的名字里加上事先约定好的编号。</p>\n<p><strong>其次，Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录。</strong>只要 StatefulSet 能够保证这些 Pod 名字里的编号不变，那么 Service 里类似于 web-0.nginx.default.svc.cluster.local 这样的 DNS 记录也就不会变，而这条记录解析出来的 Pod 的 IP 地址，则会随着后端 Pod 的删除和再创建而自动更新。这当然是 Service 机制本身的能力，不需要 StatefulSet 操心。</p>\n<p><strong>最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC。</strong>这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。</p>\n<p>在这种情况下，即使 Pod 被删除，它所对应的 PVC 和 PV 依然会保留下来。所以当这个 Pod 被重新创建出来之后，Kubernetes 会为它找到同样编号的 PVC，挂载这个 PVC 对应的 Volume，从而获取到以前保存在 Volume 里的数据。</p>\n<p>这么一看，原本非常复杂的 StatefulSet，是不是也很容易理解了呢？</p>\n"},{"title":"rabbitmq","date":"2022-02-23T08:00:43.000Z","_content":"","source":"_posts/rabbitmq.md","raw":"---\ntitle: rabbitmq\ndate: 2022-02-23 16:00:43\ncategories: \n    - middleware\ntags: [middleware]\n---\n","slug":"rabbitmq","published":1,"updated":"2022-02-27T11:30:00.838Z","_id":"cl064wjw4000olcrbbwui1fr0","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"k8s命令","date":"2022-02-22T10:37:25.000Z","comments":1,"_content":"---\n\n## 1. master节点\n   1. **查看node节点加入命令** \n        \n        ```bash\n        $ kubeadm token create --print-join-command\n        ```\n        \n   2. **查看创建节点日志**  \n        ```bash\n        $ kubectl describe pods -l app=${pod_name}\n              \n        $ kubectl describe pod ${pod_name} -n ${name_space}\n        ```\n   3. **重启k8s集群**\n        \n        ```bash\n        master节点执行：\n        $ kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets\n        $ kubectl delete node k8s-node1\n        在相应node节点执行：\n        $ kubeadm reset\n    $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n            \n\tmaster节点执行：\n\t$ kubectl drain k8s-node2 --delete-local-data --force --ignore-daemonsets\n\t$ kubectl delete node k8s-node2\n\t在相应node节点执行:\n        $ kubeadm reset\n        $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n        \n\t删除master节点：\n\t$ kubectl drain k8s-master --delete-local-data --force --ignore-daemonsets\n\t$ kubectl delete node k8s-master\n\t$ kubeadm reset\n        $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n        ```\n   4. **实时查看 Deployment 对象的状态变化**\n        ```bash\n        $ kubectl rollout status deployment/${deployment_name}\n        ```\n   5. **修改镜像信息信息**\n        \n        ```bash\n        $ kubectl set image deployment/nginx-deployment nginx=nginx:1.91\n        ```\n   6. **回滚上一版本**\n        \n        ```bash\n        $ kubectl rollout undo deployment/nginx-deployment\n        ```\n   7. **查看Deployment 变更对应的版本**\n        \n        ```bash\n        $ kubectl rollout history deployment/nginx-deployment\n        ```\n   8. **回滚到执行版本**\n        \n        ```bash\n        $ kubectl rollout undo deployment/nginx-deployment --to-revision=2\n        ```\n   9. **暂停滚动更新**\n        \n        ```bash\n        $ kubectl rollout pause deployment/nginx-deployment\n        ```\n        <font color=orange>因为我们每修改一次deployment，都会生成一个新的ReplicaSet对象，这样显得有些多余和浪费资源，所以，当我们需要修改deployment的时候，先暂时暂停滚动更新，等到我们一次性修改完成后，再重新恢复即可。</font>\n   10. **恢复滚动更新**\n       \n        ```bash\n        $ kubectl rollout resume deployment/nginx-deployment\n        ```\n\n## 2. node节点\n\n   1. **重置节点**\n\n      ```bash\n      $ kubeadm reset\n      删除配置信息\n      $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n      ```\n\n      \n\n","source":"_posts/k8s命令.md","raw":"---\ntitle: k8s命令\ndate: 2022-02-22 18:37:25\ncomments: true\ncategories:\n    - [云原生, k8s]\ntags: \n    - k8s\n---\n---\n\n## 1. master节点\n   1. **查看node节点加入命令** \n        \n        ```bash\n        $ kubeadm token create --print-join-command\n        ```\n        \n   2. **查看创建节点日志**  \n        ```bash\n        $ kubectl describe pods -l app=${pod_name}\n              \n        $ kubectl describe pod ${pod_name} -n ${name_space}\n        ```\n   3. **重启k8s集群**\n        \n        ```bash\n        master节点执行：\n        $ kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets\n        $ kubectl delete node k8s-node1\n        在相应node节点执行：\n        $ kubeadm reset\n    $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n            \n\tmaster节点执行：\n\t$ kubectl drain k8s-node2 --delete-local-data --force --ignore-daemonsets\n\t$ kubectl delete node k8s-node2\n\t在相应node节点执行:\n        $ kubeadm reset\n        $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n        \n\t删除master节点：\n\t$ kubectl drain k8s-master --delete-local-data --force --ignore-daemonsets\n\t$ kubectl delete node k8s-master\n\t$ kubeadm reset\n        $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n        ```\n   4. **实时查看 Deployment 对象的状态变化**\n        ```bash\n        $ kubectl rollout status deployment/${deployment_name}\n        ```\n   5. **修改镜像信息信息**\n        \n        ```bash\n        $ kubectl set image deployment/nginx-deployment nginx=nginx:1.91\n        ```\n   6. **回滚上一版本**\n        \n        ```bash\n        $ kubectl rollout undo deployment/nginx-deployment\n        ```\n   7. **查看Deployment 变更对应的版本**\n        \n        ```bash\n        $ kubectl rollout history deployment/nginx-deployment\n        ```\n   8. **回滚到执行版本**\n        \n        ```bash\n        $ kubectl rollout undo deployment/nginx-deployment --to-revision=2\n        ```\n   9. **暂停滚动更新**\n        \n        ```bash\n        $ kubectl rollout pause deployment/nginx-deployment\n        ```\n        <font color=orange>因为我们每修改一次deployment，都会生成一个新的ReplicaSet对象，这样显得有些多余和浪费资源，所以，当我们需要修改deployment的时候，先暂时暂停滚动更新，等到我们一次性修改完成后，再重新恢复即可。</font>\n   10. **恢复滚动更新**\n       \n        ```bash\n        $ kubectl rollout resume deployment/nginx-deployment\n        ```\n\n## 2. node节点\n\n   1. **重置节点**\n\n      ```bash\n      $ kubeadm reset\n      删除配置信息\n      $ rm -rf /var/lib/cni/ $HOME/.kube/config /etc/cni/net.d\n      ```\n\n      \n\n","slug":"k8s命令","published":1,"updated":"2022-02-28T03:25:14.264Z","_id":"cl064wjw6000qlcrb4sh65cm7","layout":"post","photos":[],"link":"","content":"<hr>\n<h2 id=\"1-master节点\"><a href=\"#1-master节点\" class=\"headerlink\" title=\"1. master节点\"></a>1. master节点</h2><ol>\n<li><strong>查看node节点加入命令</strong>   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>\n</li>\n<li><strong>查看创建节点日志</strong>    <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe pods -l app=<span class=\"variable\">$&#123;pod_name&#125;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">$ kubectl describe pod <span class=\"variable\">$&#123;pod_name&#125;</span> -n <span class=\"variable\">$&#123;name_space&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>重启k8s集群</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       master节点执行：</span><br><span class=\"line\">       $ kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets</span><br><span class=\"line\">       $ kubectl delete node k8s-node1</span><br><span class=\"line\">       在相应node节点执行：</span><br><span class=\"line\">       $ kubeadm reset</span><br><span class=\"line\">   $ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br><span class=\"line\">           </span><br><span class=\"line\">master节点执行：</span><br><span class=\"line\">$ kubectl drain k8s-node2 --delete-local-data --force --ignore-daemonsets</span><br><span class=\"line\">$ kubectl delete node k8s-node2</span><br><span class=\"line\">在相应node节点执行:</span><br><span class=\"line\">       $ kubeadm reset</span><br><span class=\"line\">       $ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br><span class=\"line\">       </span><br><span class=\"line\">删除master节点：</span><br><span class=\"line\">$ kubectl drain k8s-master --delete-local-data --force --ignore-daemonsets</span><br><span class=\"line\">$ kubectl delete node k8s-master</span><br><span class=\"line\">$ kubeadm reset</span><br><span class=\"line\">       $ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br></pre></td></tr></table></figure></li>\n<li><strong>实时查看 Deployment 对象的状态变化</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout status deployment/<span class=\"variable\">$&#123;deployment_name&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>修改镜像信息信息</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">set</span> image deployment/nginx-deployment nginx=nginx:1.91</span><br></pre></td></tr></table></figure></li>\n<li><strong>回滚上一版本</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li>\n<li><strong>查看Deployment 变更对应的版本</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout <span class=\"built_in\">history</span> deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li>\n<li><strong>回滚到执行版本</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure></li>\n<li><strong>暂停滚动更新</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout pause deployment/nginx-deployment</span><br></pre></td></tr></table></figure>\n  <font color=orange>因为我们每修改一次deployment，都会生成一个新的ReplicaSet对象，这样显得有些多余和浪费资源，所以，当我们需要修改deployment的时候，先暂时暂停滚动更新，等到我们一次性修改完成后，再重新恢复即可。</font></li>\n<li><strong>恢复滚动更新</strong> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout resume deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-node节点\"><a href=\"#2-node节点\" class=\"headerlink\" title=\"2. node节点\"></a>2. node节点</h2><ol>\n<li><p><strong>重置节点</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubeadm reset</span><br><span class=\"line\">删除配置信息</span><br><span class=\"line\">$ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"1-master节点\"><a href=\"#1-master节点\" class=\"headerlink\" title=\"1. master节点\"></a>1. master节点</h2><ol>\n<li><strong>查看node节点加入命令</strong>   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>\n</li>\n<li><strong>查看创建节点日志</strong>    <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe pods -l app=<span class=\"variable\">$&#123;pod_name&#125;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">$ kubectl describe pod <span class=\"variable\">$&#123;pod_name&#125;</span> -n <span class=\"variable\">$&#123;name_space&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>重启k8s集群</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       master节点执行：</span><br><span class=\"line\">       $ kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets</span><br><span class=\"line\">       $ kubectl delete node k8s-node1</span><br><span class=\"line\">       在相应node节点执行：</span><br><span class=\"line\">       $ kubeadm reset</span><br><span class=\"line\">   $ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br><span class=\"line\">           </span><br><span class=\"line\">master节点执行：</span><br><span class=\"line\">$ kubectl drain k8s-node2 --delete-local-data --force --ignore-daemonsets</span><br><span class=\"line\">$ kubectl delete node k8s-node2</span><br><span class=\"line\">在相应node节点执行:</span><br><span class=\"line\">       $ kubeadm reset</span><br><span class=\"line\">       $ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br><span class=\"line\">       </span><br><span class=\"line\">删除master节点：</span><br><span class=\"line\">$ kubectl drain k8s-master --delete-local-data --force --ignore-daemonsets</span><br><span class=\"line\">$ kubectl delete node k8s-master</span><br><span class=\"line\">$ kubeadm reset</span><br><span class=\"line\">       $ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br></pre></td></tr></table></figure></li>\n<li><strong>实时查看 Deployment 对象的状态变化</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout status deployment/<span class=\"variable\">$&#123;deployment_name&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>修改镜像信息信息</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">set</span> image deployment/nginx-deployment nginx=nginx:1.91</span><br></pre></td></tr></table></figure></li>\n<li><strong>回滚上一版本</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li>\n<li><strong>查看Deployment 变更对应的版本</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout <span class=\"built_in\">history</span> deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li>\n<li><strong>回滚到执行版本</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure></li>\n<li><strong>暂停滚动更新</strong>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout pause deployment/nginx-deployment</span><br></pre></td></tr></table></figure>\n  <font color=orange>因为我们每修改一次deployment，都会生成一个新的ReplicaSet对象，这样显得有些多余和浪费资源，所以，当我们需要修改deployment的时候，先暂时暂停滚动更新，等到我们一次性修改完成后，再重新恢复即可。</font></li>\n<li><strong>恢复滚动更新</strong> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl rollout resume deployment/nginx-deployment</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-node节点\"><a href=\"#2-node节点\" class=\"headerlink\" title=\"2. node节点\"></a>2. node节点</h2><ol>\n<li><p><strong>重置节点</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubeadm reset</span><br><span class=\"line\">删除配置信息</span><br><span class=\"line\">$ <span class=\"built_in\">rm</span> -rf /var/lib/cni/ <span class=\"variable\">$HOME</span>/.kube/config /etc/cni/net.d</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"mysql命令","date":"2020-02-23T08:01:44.000Z","_content":"","source":"_posts/mysql命令.md","raw":"---\ntitle: mysql命令\ndate: 2020-02-23 16:01:44\ncategories:\n    - db\ntags: [db]\n---\n","slug":"mysql命令","published":1,"updated":"2022-02-27T11:30:00.838Z","_id":"cl064wjw7000tlcrb4ou48xof","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"linux命令","date":"2019-04-13T09:07:28.000Z","_content":"\n### Linux基本命令\n\n1. 目录示意\n   * /:根目录\n     整个文件系统，有一个顶层目录，称为根。 bin:存放一些可执行的程序、命令。\n   * boot: 系统启动所需的一些文件。\n   * dev:系统中的设备(硬件在linux中通过“文件”来标识) etc:存放系统、软件的配置文件\n   * home:普通用户目录的主目录，以用户名命名。\n   * home/fred lib:系统库目录(32位)\n   * lib64: 系统库目录(64位)\n   * media:媒体\n   * mnt:挂载外部存储设备的文件目录\n   * opt\n   * proc\n   * root:root用户的主目录\n   * run\n   * sbin:系统的可执行命令\n   * srv\n   * sys\n   * test\n   * tmp:系统临时目录 usr:共享资源目录(多个用户可以共享该目录中的程序)\n   * var\n\n2. 命令\n\n   * ls命令\n\n     ```bash\n     ls /: 查看根目录\n     ls -l: 显示详细信息\n     ls -lh: 显示跟符合人类查看方式 \n     ls -a: 显示隐藏文件\n     ```\n\n     \n\n   * 目录切换\n\n     ```bash\n     pwd: 查看当前所在目录\n     cd: 切换目录\n     cd ...: 退回到上一级目录cat\n     ```\n\n     \n\n   * 创建文件夹\n\n     ```bash\n     mkdir aaa: 相对路径写法\n     mkdir /bbb: 绝对路径写法\n     mkdir -p aaa/bbb/ccc: 级联创建目录\n     ```\n\n     \n\n   * 删除目录/文件\n\n     ```bash\n     rm: 删除目录\n     rm -r: 递归删除\n     rm -rf: 递归删除，不提示\n     ```\n\n     \n\n   * 查看信息\n\n     ```bash\n     touch: 创建空文件\n     cat: 查看文件内容\n     ```\n\n     \n\n   * 编辑\n\n     ```bash\n     vi : 编辑文件\n     -i: 编辑模式 \n     -o: 编辑模式(直接到下一行)\n     -w: 保存\n     -q: 退出\n     esc: 退出编辑 \n     ```\n\n     \n\n   * Vim快捷键 (非编辑模式下)\n\n     ```bash\n     a: 在光标后一位开始插入\n     A: 在该行的最后插入\n     I: 在该行的最前插入\n     yy: 复制整行 \n     3yy: 复制三行\n     p: 粘贴\n     gg: 直接跳到文件首行\n     G: 直接跳到文件的末行\n     dd: 删除一行\n     3dd: 删除三行\n     /: 搜索内容,n匹配下一个 u:undo(撤销) ctrl+r:redo(执行之前撤销的) :set nu: 设置行号\n     :set nonu: 设置不显示行号\n     :q!: 强制不保存退出\n     fg 程序编号: 切换后台挂起程序\n     jobs: 查看后台挂起的程序\n     ctrl+z: 将程序挂起\n     ```\n\n     \n\n   * 拷贝\n\n     ```bash\n     cp a.txt b.txt: 将a.txt 拷贝为b.txt\n     ```\n\n     \n\n   * 移动/改名\n\n     ```bash\n     mv a.txt aa.txt: 将a.txt 改为 aa.txt\n     mv a.txt aa/aa.txt: 将a.txt 移动到 aa/aa.txt\n     ```\n\n\n\n \n\n 3. 权限\n\n    * 添加用户\n\n      ```bash\n      useradd fred passwd 1234: 添加 fred 用户并设置密码为 1234\n      ```\n\n      \n\n    * linux文件权限的描述格式\n\n      ```bash\n      d rwx rwx rwx\n      d: 标识节点类型(d:文件夹 -:文件 |:链接)\n      r: 可读\n      w: 可写\n      x: 可执行\n      第一组rwx: 表示这个文件的拥有者对它的权限\n      第二组rwx: 表示这个文件的所属组用户对它的权限\n      第三组rwx: 表示这个文件的其他用户(除以上两种)对它的权限\n      使用二进制表示权限:例如-rw-rw-r–二进制表示为110,110,100，十进制表示为664\n      \n      补充:\n      r: 对文件来说，是可读取内容;对文件夹来说，是可以ls\n      w: 对文件来说，是可修改文件的内容;对文件夹来说，是可以在其中创建或者删除子节点\n      x: 对文件来说，是能否运行这个文件;对文件夹来说，是能否cd进入这个目录\n      ```\n\n      \n\n    * 用户管理\n\n      * 增加用户\n\n        ```bash\n        useradd ant: 增加 ant 用户\n        passwd ant: 给用户ant设置密码\n        userdel -r 用户名: 删除用户(加一个-r表示把用户及用户的主目录都删除)\n        exit: 退出会话\n        ```\n\n        \n\n      * 增加用户组\n\n        ```bash\n        groupadd 组名: 增加组\n        usermod -g 组名 用户名: 将用户添加到组中\n        usermod -G 组名1,组名2 用户名: 将用户添加到多个组中\n        gpasswd -d 用户名 组名: 将用户从组中删除\n        \t—例如:gpasswd -d jack root | gpasswd -d jack sys\n        ```\n\n        \n\n      * 查看所属组\n\n        ```bash\n        groups: 查看当前用户所属组 \n        groups jack: 查看指定用户所属组\n        ```\n\n        \n\n      * su 和 sudo\n\n        ```bash\n        su: 身份切换\n        su username 输入密码(root切换不需要输入密码)\n        sudo: 让普通用户具备root的权限(需要配置 /etc/sudoers)\n        \n        ```\n\n        > 了解完su和sudo，是不是发现sudo有太多的优点了。\n        >\n        > su方式切换是须要输入目标用户的password。而sudo仅仅须要 输入自己的password，所以sudo能够保护目标用户的password不外流的。\n        >\n        > 当帮root管理系统的时候，su是直接将 root全部权利交给用户。而sudo能够更好分工，仅仅要配置好/etc/sudoers，这样sudo能够保护系统更安全，并且分 工明白，有条不紊。\n\n        \n\n\n","source":"_posts/linux命令.md","raw":"---\ntitle: linux命令\ndate: 2019-04-13 17:07:28\ncategories:\n    - linux\ntags: [linux]\n---\n\n### Linux基本命令\n\n1. 目录示意\n   * /:根目录\n     整个文件系统，有一个顶层目录，称为根。 bin:存放一些可执行的程序、命令。\n   * boot: 系统启动所需的一些文件。\n   * dev:系统中的设备(硬件在linux中通过“文件”来标识) etc:存放系统、软件的配置文件\n   * home:普通用户目录的主目录，以用户名命名。\n   * home/fred lib:系统库目录(32位)\n   * lib64: 系统库目录(64位)\n   * media:媒体\n   * mnt:挂载外部存储设备的文件目录\n   * opt\n   * proc\n   * root:root用户的主目录\n   * run\n   * sbin:系统的可执行命令\n   * srv\n   * sys\n   * test\n   * tmp:系统临时目录 usr:共享资源目录(多个用户可以共享该目录中的程序)\n   * var\n\n2. 命令\n\n   * ls命令\n\n     ```bash\n     ls /: 查看根目录\n     ls -l: 显示详细信息\n     ls -lh: 显示跟符合人类查看方式 \n     ls -a: 显示隐藏文件\n     ```\n\n     \n\n   * 目录切换\n\n     ```bash\n     pwd: 查看当前所在目录\n     cd: 切换目录\n     cd ...: 退回到上一级目录cat\n     ```\n\n     \n\n   * 创建文件夹\n\n     ```bash\n     mkdir aaa: 相对路径写法\n     mkdir /bbb: 绝对路径写法\n     mkdir -p aaa/bbb/ccc: 级联创建目录\n     ```\n\n     \n\n   * 删除目录/文件\n\n     ```bash\n     rm: 删除目录\n     rm -r: 递归删除\n     rm -rf: 递归删除，不提示\n     ```\n\n     \n\n   * 查看信息\n\n     ```bash\n     touch: 创建空文件\n     cat: 查看文件内容\n     ```\n\n     \n\n   * 编辑\n\n     ```bash\n     vi : 编辑文件\n     -i: 编辑模式 \n     -o: 编辑模式(直接到下一行)\n     -w: 保存\n     -q: 退出\n     esc: 退出编辑 \n     ```\n\n     \n\n   * Vim快捷键 (非编辑模式下)\n\n     ```bash\n     a: 在光标后一位开始插入\n     A: 在该行的最后插入\n     I: 在该行的最前插入\n     yy: 复制整行 \n     3yy: 复制三行\n     p: 粘贴\n     gg: 直接跳到文件首行\n     G: 直接跳到文件的末行\n     dd: 删除一行\n     3dd: 删除三行\n     /: 搜索内容,n匹配下一个 u:undo(撤销) ctrl+r:redo(执行之前撤销的) :set nu: 设置行号\n     :set nonu: 设置不显示行号\n     :q!: 强制不保存退出\n     fg 程序编号: 切换后台挂起程序\n     jobs: 查看后台挂起的程序\n     ctrl+z: 将程序挂起\n     ```\n\n     \n\n   * 拷贝\n\n     ```bash\n     cp a.txt b.txt: 将a.txt 拷贝为b.txt\n     ```\n\n     \n\n   * 移动/改名\n\n     ```bash\n     mv a.txt aa.txt: 将a.txt 改为 aa.txt\n     mv a.txt aa/aa.txt: 将a.txt 移动到 aa/aa.txt\n     ```\n\n\n\n \n\n 3. 权限\n\n    * 添加用户\n\n      ```bash\n      useradd fred passwd 1234: 添加 fred 用户并设置密码为 1234\n      ```\n\n      \n\n    * linux文件权限的描述格式\n\n      ```bash\n      d rwx rwx rwx\n      d: 标识节点类型(d:文件夹 -:文件 |:链接)\n      r: 可读\n      w: 可写\n      x: 可执行\n      第一组rwx: 表示这个文件的拥有者对它的权限\n      第二组rwx: 表示这个文件的所属组用户对它的权限\n      第三组rwx: 表示这个文件的其他用户(除以上两种)对它的权限\n      使用二进制表示权限:例如-rw-rw-r–二进制表示为110,110,100，十进制表示为664\n      \n      补充:\n      r: 对文件来说，是可读取内容;对文件夹来说，是可以ls\n      w: 对文件来说，是可修改文件的内容;对文件夹来说，是可以在其中创建或者删除子节点\n      x: 对文件来说，是能否运行这个文件;对文件夹来说，是能否cd进入这个目录\n      ```\n\n      \n\n    * 用户管理\n\n      * 增加用户\n\n        ```bash\n        useradd ant: 增加 ant 用户\n        passwd ant: 给用户ant设置密码\n        userdel -r 用户名: 删除用户(加一个-r表示把用户及用户的主目录都删除)\n        exit: 退出会话\n        ```\n\n        \n\n      * 增加用户组\n\n        ```bash\n        groupadd 组名: 增加组\n        usermod -g 组名 用户名: 将用户添加到组中\n        usermod -G 组名1,组名2 用户名: 将用户添加到多个组中\n        gpasswd -d 用户名 组名: 将用户从组中删除\n        \t—例如:gpasswd -d jack root | gpasswd -d jack sys\n        ```\n\n        \n\n      * 查看所属组\n\n        ```bash\n        groups: 查看当前用户所属组 \n        groups jack: 查看指定用户所属组\n        ```\n\n        \n\n      * su 和 sudo\n\n        ```bash\n        su: 身份切换\n        su username 输入密码(root切换不需要输入密码)\n        sudo: 让普通用户具备root的权限(需要配置 /etc/sudoers)\n        \n        ```\n\n        > 了解完su和sudo，是不是发现sudo有太多的优点了。\n        >\n        > su方式切换是须要输入目标用户的password。而sudo仅仅须要 输入自己的password，所以sudo能够保护目标用户的password不外流的。\n        >\n        > 当帮root管理系统的时候，su是直接将 root全部权利交给用户。而sudo能够更好分工，仅仅要配置好/etc/sudoers，这样sudo能够保护系统更安全，并且分 工明白，有条不紊。\n\n        \n\n\n","slug":"linux命令","published":1,"updated":"2022-02-27T11:30:00.837Z","_id":"cl064wjwa0014lcrbe8u0csrq","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Linux基本命令\"><a href=\"#Linux基本命令\" class=\"headerlink\" title=\"Linux基本命令\"></a>Linux基本命令</h3><ol>\n<li><p>目录示意</p>\n<ul>\n<li>/:根目录<br>整个文件系统，有一个顶层目录，称为根。 bin:存放一些可执行的程序、命令。</li>\n<li>boot: 系统启动所需的一些文件。</li>\n<li>dev:系统中的设备(硬件在linux中通过“文件”来标识) etc:存放系统、软件的配置文件</li>\n<li>home:普通用户目录的主目录，以用户名命名。</li>\n<li>home/fred lib:系统库目录(32位)</li>\n<li>lib64: 系统库目录(64位)</li>\n<li>media:媒体</li>\n<li>mnt:挂载外部存储设备的文件目录</li>\n<li>opt</li>\n<li>proc</li>\n<li>root:root用户的主目录</li>\n<li>run</li>\n<li>sbin:系统的可执行命令</li>\n<li>srv</li>\n<li>sys</li>\n<li>test</li>\n<li>tmp:系统临时目录 usr:共享资源目录(多个用户可以共享该目录中的程序)</li>\n<li>var</li>\n</ul>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>ls命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> /: 查看根目录</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l: 显示详细信息</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -lh: 显示跟符合人类查看方式 </span><br><span class=\"line\"><span class=\"built_in\">ls</span> -a: 显示隐藏文件</span><br></pre></td></tr></table></figure></li>\n<li><p>目录切换</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pwd</span>: 查看当前所在目录</span><br><span class=\"line\"><span class=\"built_in\">cd</span>: 切换目录</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ...: 退回到上一级目录<span class=\"built_in\">cat</span></span><br></pre></td></tr></table></figure></li>\n<li><p>创建文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> aaa: 相对路径写法</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /bbb: 绝对路径写法</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p aaa/bbb/ccc: 级联创建目录</span><br></pre></td></tr></table></figure></li>\n<li><p>删除目录/文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span>: 删除目录</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -r: 递归删除</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf: 递归删除，不提示</span><br></pre></td></tr></table></figure></li>\n<li><p>查看信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">touch</span>: 创建空文件</span><br><span class=\"line\"><span class=\"built_in\">cat</span>: 查看文件内容</span><br></pre></td></tr></table></figure></li>\n<li><p>编辑</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi : 编辑文件</span><br><span class=\"line\">-i: 编辑模式 </span><br><span class=\"line\">-o: 编辑模式(直接到下一行)</span><br><span class=\"line\">-w: 保存</span><br><span class=\"line\">-q: 退出</span><br><span class=\"line\">esc: 退出编辑 </span><br></pre></td></tr></table></figure></li>\n<li><p>Vim快捷键 (非编辑模式下)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a: 在光标后一位开始插入</span><br><span class=\"line\">A: 在该行的最后插入</span><br><span class=\"line\">I: 在该行的最前插入</span><br><span class=\"line\">yy: 复制整行 </span><br><span class=\"line\">3yy: 复制三行</span><br><span class=\"line\">p: 粘贴</span><br><span class=\"line\">gg: 直接跳到文件首行</span><br><span class=\"line\">G: 直接跳到文件的末行</span><br><span class=\"line\"><span class=\"built_in\">dd</span>: 删除一行</span><br><span class=\"line\">3dd: 删除三行</span><br><span class=\"line\">/: 搜索内容,n匹配下一个 u:undo(撤销) ctrl+r:redo(执行之前撤销的) :<span class=\"built_in\">set</span> nu: 设置行号</span><br><span class=\"line\">:<span class=\"built_in\">set</span> nonu: 设置不显示行号</span><br><span class=\"line\">:q!: 强制不保存退出</span><br><span class=\"line\"><span class=\"built_in\">fg</span> 程序编号: 切换后台挂起程序</span><br><span class=\"line\"><span class=\"built_in\">jobs</span>: 查看后台挂起的程序</span><br><span class=\"line\">ctrl+z: 将程序挂起</span><br></pre></td></tr></table></figure></li>\n<li><p>拷贝</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> a.txt b.txt: 将a.txt 拷贝为b.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>移动/改名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mv</span> a.txt aa.txt: 将a.txt 改为 aa.txt</span><br><span class=\"line\"><span class=\"built_in\">mv</span> a.txt aa/aa.txt: 将a.txt 移动到 aa/aa.txt</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>权限</p>\n<ul>\n<li><p>添加用户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd fred passwd 1234: 添加 fred 用户并设置密码为 1234</span><br></pre></td></tr></table></figure></li>\n<li><p>linux文件权限的描述格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d rwx rwx rwx</span><br><span class=\"line\">d: 标识节点类型(d:文件夹 -:文件 |:链接)</span><br><span class=\"line\">r: 可读</span><br><span class=\"line\">w: 可写</span><br><span class=\"line\">x: 可执行</span><br><span class=\"line\">第一组rwx: 表示这个文件的拥有者对它的权限</span><br><span class=\"line\">第二组rwx: 表示这个文件的所属组用户对它的权限</span><br><span class=\"line\">第三组rwx: 表示这个文件的其他用户(除以上两种)对它的权限</span><br><span class=\"line\">使用二进制表示权限:例如-rw-rw-r–二进制表示为110,110,100，十进制表示为664</span><br><span class=\"line\"></span><br><span class=\"line\">补充:</span><br><span class=\"line\">r: 对文件来说，是可读取内容;对文件夹来说，是可以<span class=\"built_in\">ls</span></span><br><span class=\"line\">w: 对文件来说，是可修改文件的内容;对文件夹来说，是可以在其中创建或者删除子节点</span><br><span class=\"line\">x: 对文件来说，是能否运行这个文件;对文件夹来说，是能否<span class=\"built_in\">cd</span>进入这个目录</span><br></pre></td></tr></table></figure></li>\n<li><p>用户管理</p>\n<ul>\n<li><p>增加用户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd ant: 增加 ant 用户</span><br><span class=\"line\">passwd ant: 给用户ant设置密码</span><br><span class=\"line\">userdel -r 用户名: 删除用户(加一个-r表示把用户及用户的主目录都删除)</span><br><span class=\"line\"><span class=\"built_in\">exit</span>: 退出会话</span><br></pre></td></tr></table></figure></li>\n<li><p>增加用户组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd 组名: 增加组</span><br><span class=\"line\">usermod -g 组名 用户名: 将用户添加到组中</span><br><span class=\"line\">usermod -G 组名1,组名2 用户名: 将用户添加到多个组中</span><br><span class=\"line\">gpasswd -d 用户名 组名: 将用户从组中删除</span><br><span class=\"line\">\t—例如:gpasswd -d jack root | gpasswd -d jack sys</span><br></pre></td></tr></table></figure></li>\n<li><p>查看所属组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">groups</span>: 查看当前用户所属组 </span><br><span class=\"line\"><span class=\"built_in\">groups</span> jack: 查看指定用户所属组</span><br></pre></td></tr></table></figure></li>\n<li><p>su 和 sudo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su: 身份切换</span><br><span class=\"line\">su username 输入密码(root切换不需要输入密码)</span><br><span class=\"line\">sudo: 让普通用户具备root的权限(需要配置 /etc/sudoers)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>了解完su和sudo，是不是发现sudo有太多的优点了。</p>\n<p>su方式切换是须要输入目标用户的password。而sudo仅仅须要 输入自己的password，所以sudo能够保护目标用户的password不外流的。</p>\n<p>当帮root管理系统的时候，su是直接将 root全部权利交给用户。而sudo能够更好分工，仅仅要配置好/etc/sudoers，这样sudo能够保护系统更安全，并且分 工明白，有条不紊。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Linux基本命令\"><a href=\"#Linux基本命令\" class=\"headerlink\" title=\"Linux基本命令\"></a>Linux基本命令</h3><ol>\n<li><p>目录示意</p>\n<ul>\n<li>/:根目录<br>整个文件系统，有一个顶层目录，称为根。 bin:存放一些可执行的程序、命令。</li>\n<li>boot: 系统启动所需的一些文件。</li>\n<li>dev:系统中的设备(硬件在linux中通过“文件”来标识) etc:存放系统、软件的配置文件</li>\n<li>home:普通用户目录的主目录，以用户名命名。</li>\n<li>home/fred lib:系统库目录(32位)</li>\n<li>lib64: 系统库目录(64位)</li>\n<li>media:媒体</li>\n<li>mnt:挂载外部存储设备的文件目录</li>\n<li>opt</li>\n<li>proc</li>\n<li>root:root用户的主目录</li>\n<li>run</li>\n<li>sbin:系统的可执行命令</li>\n<li>srv</li>\n<li>sys</li>\n<li>test</li>\n<li>tmp:系统临时目录 usr:共享资源目录(多个用户可以共享该目录中的程序)</li>\n<li>var</li>\n</ul>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>ls命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> /: 查看根目录</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l: 显示详细信息</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -lh: 显示跟符合人类查看方式 </span><br><span class=\"line\"><span class=\"built_in\">ls</span> -a: 显示隐藏文件</span><br></pre></td></tr></table></figure></li>\n<li><p>目录切换</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pwd</span>: 查看当前所在目录</span><br><span class=\"line\"><span class=\"built_in\">cd</span>: 切换目录</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ...: 退回到上一级目录<span class=\"built_in\">cat</span></span><br></pre></td></tr></table></figure></li>\n<li><p>创建文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> aaa: 相对路径写法</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /bbb: 绝对路径写法</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p aaa/bbb/ccc: 级联创建目录</span><br></pre></td></tr></table></figure></li>\n<li><p>删除目录/文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span>: 删除目录</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -r: 递归删除</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf: 递归删除，不提示</span><br></pre></td></tr></table></figure></li>\n<li><p>查看信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">touch</span>: 创建空文件</span><br><span class=\"line\"><span class=\"built_in\">cat</span>: 查看文件内容</span><br></pre></td></tr></table></figure></li>\n<li><p>编辑</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi : 编辑文件</span><br><span class=\"line\">-i: 编辑模式 </span><br><span class=\"line\">-o: 编辑模式(直接到下一行)</span><br><span class=\"line\">-w: 保存</span><br><span class=\"line\">-q: 退出</span><br><span class=\"line\">esc: 退出编辑 </span><br></pre></td></tr></table></figure></li>\n<li><p>Vim快捷键 (非编辑模式下)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a: 在光标后一位开始插入</span><br><span class=\"line\">A: 在该行的最后插入</span><br><span class=\"line\">I: 在该行的最前插入</span><br><span class=\"line\">yy: 复制整行 </span><br><span class=\"line\">3yy: 复制三行</span><br><span class=\"line\">p: 粘贴</span><br><span class=\"line\">gg: 直接跳到文件首行</span><br><span class=\"line\">G: 直接跳到文件的末行</span><br><span class=\"line\"><span class=\"built_in\">dd</span>: 删除一行</span><br><span class=\"line\">3dd: 删除三行</span><br><span class=\"line\">/: 搜索内容,n匹配下一个 u:undo(撤销) ctrl+r:redo(执行之前撤销的) :<span class=\"built_in\">set</span> nu: 设置行号</span><br><span class=\"line\">:<span class=\"built_in\">set</span> nonu: 设置不显示行号</span><br><span class=\"line\">:q!: 强制不保存退出</span><br><span class=\"line\"><span class=\"built_in\">fg</span> 程序编号: 切换后台挂起程序</span><br><span class=\"line\"><span class=\"built_in\">jobs</span>: 查看后台挂起的程序</span><br><span class=\"line\">ctrl+z: 将程序挂起</span><br></pre></td></tr></table></figure></li>\n<li><p>拷贝</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> a.txt b.txt: 将a.txt 拷贝为b.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>移动/改名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mv</span> a.txt aa.txt: 将a.txt 改为 aa.txt</span><br><span class=\"line\"><span class=\"built_in\">mv</span> a.txt aa/aa.txt: 将a.txt 移动到 aa/aa.txt</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>权限</p>\n<ul>\n<li><p>添加用户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd fred passwd 1234: 添加 fred 用户并设置密码为 1234</span><br></pre></td></tr></table></figure></li>\n<li><p>linux文件权限的描述格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d rwx rwx rwx</span><br><span class=\"line\">d: 标识节点类型(d:文件夹 -:文件 |:链接)</span><br><span class=\"line\">r: 可读</span><br><span class=\"line\">w: 可写</span><br><span class=\"line\">x: 可执行</span><br><span class=\"line\">第一组rwx: 表示这个文件的拥有者对它的权限</span><br><span class=\"line\">第二组rwx: 表示这个文件的所属组用户对它的权限</span><br><span class=\"line\">第三组rwx: 表示这个文件的其他用户(除以上两种)对它的权限</span><br><span class=\"line\">使用二进制表示权限:例如-rw-rw-r–二进制表示为110,110,100，十进制表示为664</span><br><span class=\"line\"></span><br><span class=\"line\">补充:</span><br><span class=\"line\">r: 对文件来说，是可读取内容;对文件夹来说，是可以<span class=\"built_in\">ls</span></span><br><span class=\"line\">w: 对文件来说，是可修改文件的内容;对文件夹来说，是可以在其中创建或者删除子节点</span><br><span class=\"line\">x: 对文件来说，是能否运行这个文件;对文件夹来说，是能否<span class=\"built_in\">cd</span>进入这个目录</span><br></pre></td></tr></table></figure></li>\n<li><p>用户管理</p>\n<ul>\n<li><p>增加用户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd ant: 增加 ant 用户</span><br><span class=\"line\">passwd ant: 给用户ant设置密码</span><br><span class=\"line\">userdel -r 用户名: 删除用户(加一个-r表示把用户及用户的主目录都删除)</span><br><span class=\"line\"><span class=\"built_in\">exit</span>: 退出会话</span><br></pre></td></tr></table></figure></li>\n<li><p>增加用户组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd 组名: 增加组</span><br><span class=\"line\">usermod -g 组名 用户名: 将用户添加到组中</span><br><span class=\"line\">usermod -G 组名1,组名2 用户名: 将用户添加到多个组中</span><br><span class=\"line\">gpasswd -d 用户名 组名: 将用户从组中删除</span><br><span class=\"line\">\t—例如:gpasswd -d jack root | gpasswd -d jack sys</span><br></pre></td></tr></table></figure></li>\n<li><p>查看所属组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">groups</span>: 查看当前用户所属组 </span><br><span class=\"line\"><span class=\"built_in\">groups</span> jack: 查看指定用户所属组</span><br></pre></td></tr></table></figure></li>\n<li><p>su 和 sudo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su: 身份切换</span><br><span class=\"line\">su username 输入密码(root切换不需要输入密码)</span><br><span class=\"line\">sudo: 让普通用户具备root的权限(需要配置 /etc/sudoers)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>了解完su和sudo，是不是发现sudo有太多的优点了。</p>\n<p>su方式切换是须要输入目标用户的password。而sudo仅仅须要 输入自己的password，所以sudo能够保护目标用户的password不外流的。</p>\n<p>当帮root管理系统的时候，su是直接将 root全部权利交给用户。而sudo能够更好分工，仅仅要配置好/etc/sudoers，这样sudo能够保护系统更安全，并且分 工明白，有条不紊。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"linux编程-文件读取操作","date":"2019-05-28T02:21:56.000Z","_content":"\n### 这里写一个最简单的文件读取的操作流程：\n\n1. 安装环境\n\n   我的系统是centos7，默认是不带有linux函数系统手册的，所以有需要的要先安装一下。具体的命令如下：\n\n   ```bash\n   $ yum -y install man-pages\n   ```\n\n   出现如下提示，说明安装成功；\n\n   ```bash\n   $ Running transaction 正在安装 : man-pages-3.53-5.el7.noarch\n   $ 1/1 验证中 : man-pages-3.53-5.el7.noarch\n   $ 1/1 已安装: man-pages.noarch 0:3.53-5.el7\n   $ 完毕！\n   ```\n\n2. 开始着手写我们的程序\n\n   + 文件读取操作\n\n     我们这里随便建一个c程序，就叫open_test1.c,首先写一个main函数\n\n     ```c\n     int main(void)\n     {\n     \treturn 0;\n     }\n     ```\n\n     下面我们需要查询手册，来看linux系统是怎么打开一个文件的；这里我们要使用man 2 open 命令查看：\n\n     ```bash\n     $ man 2 open\n     ```\n\n     > OPEN(2)                     BSD System Calls Manual                    OPEN(2)\n     >\n     > NAME\n     >      open, openat -- open or create a file for reading or writing\n     >\n     > SYNOPSIS\n     >      #include <fcntl.h>\n     >\n     >      int\n     >      open(const char *path, int oflag, ...);\n     >     \n     >      int\n     >      openat(int fd, const char *path, int oflag, ...);\n     >\n     > DESCRIPTION\n     >      The file name specified by path is opened for reading and/or writing, as specified by the\n     >      argument oflag; the file descriptor is returned to the calling process.\n     >\n     > ```bash\n     >  The oflag argument may indicate that the file is to be created if it does not exist (by speci-\n     >  fying the O_CREAT flag).  In this case, open() and openat() require an additional argument\n     >  mode_t mode; the file is created with mode mode as described in chmod(2) and modified by the\n     >  process' umask value (see umask(2)).\n     >  省略部分内容..........\n     > ```\n\n     具体的描述如如上面所示，所以我们根据他给我们的提示，写一个打开文件的操作，我们的程序中增加如下代码：\n\n     ```c\n     #include <stdio.h>\n     #include <sys/types.h>\n     #include <sys/stat.h>\n     #include <fcntl.h>\n     \n     int main(void)\n     {\n             int fd = 0;\n             fd = open(\"./file.txt\",O_RDWR);\n             if(-1 == fd)\n             {\n                     printf(\"open fail\\n\");\n                     return 0;\n             }\n             else\n             {\n                     printf(\"open ok\\n\");\n             }\n             \n              // 关闭文件\n             close(fd);\n     }\n     ```\n\n     如果文件打开正常，会打印出，open ok；\n\n     \n\n   + 写文件操作\n\n     同样的我们去查写操作手册，命令为：\n\n     ```bash\n     $ man 2 write\n     ```\n\n     > WRITE(2)                    BSD System Calls Manual                   WRITE(2)\n     >\n     > NAME\n     >      pwrite, write, writev -- write output\n     >\n     > LIBRARY\n     >      Standard C Library (libc, -lc)\n     >\n     > SYNOPSIS\n     >      #include <unistd.h>\n     >\n     >      ssize_t\n     >      pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);\n     >     \n     >      ssize_t\n     >      write(int fildes, const void *buf, size_t nbyte);\n     >     \n     >      #include <sys/uio.h>\n     >     \n     >      ssize_t\n     >      writev(int fildes, const struct iovec *iov, int iovcnt);\n     >\n     > DESCRIPTION\n     >\n     > 省略部分内容.....................\n\n     所以我们的程序中增加代码如下：\n\n     ```c\n     #include <stdio.h>\n     #include <sys/types.h>\n     #include <sys/stat.h>\n     #include <fcntl.h>\n     #include <unistd.h>\n       \n     int main(void)\n     {\n             int fd = 0;\n             // 打开file.txt文件\n             fd = open(\"./file.txt\",O_RDWR);\n     \n             if(-1 == fd)\n             {\n                     printf(\"open fail\\n\");\n                     return 0;\n             }\n             else\n             {\n                     printf(\"open ok\\n\");\n             }\n             \n             // 往file.txt文件里面写入hello world\n             char buf[] = \"hello world\";\n             write(fd,(void *)buf,11);\n     \n             //ssize_t write(int fd, const void *buf, size_t count);\n     \n     \t    // 关闭文件\n             close(fd);\n     }\n     \n     \n     ```\n\n     \n\n   + 读取写入文件的到缓冲区，然后输出\n\n     读取file.txt文件里的内容到buf2中，然后输出，同样我们查看读文件的函数命令: \n\n     ```bash\n     $ man 2 read\n     ```\n\n     > READ(2)                     BSD System Calls Manual                    READ(2)\n     >\n     > NAME\n     >      pread, read, readv -- read input\n     >\n     > LIBRARY\n     >      Standard C Library (libc, -lc)\n     >\n     > SYNOPSIS\n     >      #include <sys/types.h>\n     >      #include <sys/uio.h>\n     >      #include <unistd.h>\n     >\n     > ```bash\n     >  ssize_t\n     >  pread(int d, void *buf, size_t nbyte, off_t offset);\n     > \n     >  ssize_t\n     >  read(int fildes, void *buf, size_t nbyte);\n     > \n     >  ssize_t\n     >  readv(int d, const struct iovec *iov, int iovcnt);\n     >  省略剩余内容.....................\n     > ```\n\n     然后我们的程序增加如下：\n\n     ```c\n     #include <sys/types.h>\n     #include <sys/stat.h>\n     #include <fcntl.h>\n     #include <unistd.h>\n     #include <stdio.h>\n     \n     int main(void)\n     {\n             int fd = 0;\n             // 打开file.txt文件\n             fd = open(\"./file.txt\",O_RDWR);\n     \n             if(-1 == fd)\n             {\n                     printf(\"open fail\\n\");\n                     return 0;\n             }\n             else\n             {\n                     printf(\"open ok\\n\");\n             }\n             // 往file.txt文件里面写入hello world\n             char buf[] = \"hello world\";\n             write(fd,(void *)buf,11);\n     \n             //ssize_t write(int fd, const void *buf, size_t count);\n     \n             // 把文件指向调到文件头部位置\n             lseek(fd, SEEK_SET, 0);\n             //off_t lseek(int fd, off_t offset, int whence);\n     \n             // 读取file.txt的内容到buf2中，然后输出\n             char buf2[30] = {0};\n             read(fd, buf2, sizeof(buf2));\n     \n             printf(\"buf2 = %s\\n\", buf2);\n     \n             // 关闭文件\n             close(fd);\n             \n             return 0;\n     }\n     \n     ```\n\n     到此为止，我们的程序基本就算是写完了！\n\n     \n\n3. 运行\n\n   + 那么让我们编译运行一下：\n\n     ```bash\n     $ gcc open_test1.c\n     ```\n\n     如果没有报错，则说明我们的程序没有问题：编译后会出现一个a.out文件如下：\n\n     ```bash\n     $ ll\n     总用量 20\n     -rwxr-xr-x. 1 root root 8704 5月 28 10:19 a.out\n     -rw-r–r--. 1 root root 11 5月 28 09:52 file.txt\n     -rw-r–r--. 1 root root 757 5月 28 10:12 open_test1.c\n     ```\n\n     然后让我们运行一下看一下结果：\n\n     ```bash\n     $ ./a.out\n     open ok\n     buf2 = hello world\n     ```\n\n     成功输出！！！\n\n     \n\n到这里一个简单的文件打开->写入->输出的简单操作就完成了。\n\n","source":"_posts/linux编程-文件读取操作.md","raw":"---\ntitle: linux编程-文件读取操作\ndate: 2019-05-28 10:21:56\ncategories:\n    - linuxProgram\ntags: [linuxProgram]\n---\n\n### 这里写一个最简单的文件读取的操作流程：\n\n1. 安装环境\n\n   我的系统是centos7，默认是不带有linux函数系统手册的，所以有需要的要先安装一下。具体的命令如下：\n\n   ```bash\n   $ yum -y install man-pages\n   ```\n\n   出现如下提示，说明安装成功；\n\n   ```bash\n   $ Running transaction 正在安装 : man-pages-3.53-5.el7.noarch\n   $ 1/1 验证中 : man-pages-3.53-5.el7.noarch\n   $ 1/1 已安装: man-pages.noarch 0:3.53-5.el7\n   $ 完毕！\n   ```\n\n2. 开始着手写我们的程序\n\n   + 文件读取操作\n\n     我们这里随便建一个c程序，就叫open_test1.c,首先写一个main函数\n\n     ```c\n     int main(void)\n     {\n     \treturn 0;\n     }\n     ```\n\n     下面我们需要查询手册，来看linux系统是怎么打开一个文件的；这里我们要使用man 2 open 命令查看：\n\n     ```bash\n     $ man 2 open\n     ```\n\n     > OPEN(2)                     BSD System Calls Manual                    OPEN(2)\n     >\n     > NAME\n     >      open, openat -- open or create a file for reading or writing\n     >\n     > SYNOPSIS\n     >      #include <fcntl.h>\n     >\n     >      int\n     >      open(const char *path, int oflag, ...);\n     >     \n     >      int\n     >      openat(int fd, const char *path, int oflag, ...);\n     >\n     > DESCRIPTION\n     >      The file name specified by path is opened for reading and/or writing, as specified by the\n     >      argument oflag; the file descriptor is returned to the calling process.\n     >\n     > ```bash\n     >  The oflag argument may indicate that the file is to be created if it does not exist (by speci-\n     >  fying the O_CREAT flag).  In this case, open() and openat() require an additional argument\n     >  mode_t mode; the file is created with mode mode as described in chmod(2) and modified by the\n     >  process' umask value (see umask(2)).\n     >  省略部分内容..........\n     > ```\n\n     具体的描述如如上面所示，所以我们根据他给我们的提示，写一个打开文件的操作，我们的程序中增加如下代码：\n\n     ```c\n     #include <stdio.h>\n     #include <sys/types.h>\n     #include <sys/stat.h>\n     #include <fcntl.h>\n     \n     int main(void)\n     {\n             int fd = 0;\n             fd = open(\"./file.txt\",O_RDWR);\n             if(-1 == fd)\n             {\n                     printf(\"open fail\\n\");\n                     return 0;\n             }\n             else\n             {\n                     printf(\"open ok\\n\");\n             }\n             \n              // 关闭文件\n             close(fd);\n     }\n     ```\n\n     如果文件打开正常，会打印出，open ok；\n\n     \n\n   + 写文件操作\n\n     同样的我们去查写操作手册，命令为：\n\n     ```bash\n     $ man 2 write\n     ```\n\n     > WRITE(2)                    BSD System Calls Manual                   WRITE(2)\n     >\n     > NAME\n     >      pwrite, write, writev -- write output\n     >\n     > LIBRARY\n     >      Standard C Library (libc, -lc)\n     >\n     > SYNOPSIS\n     >      #include <unistd.h>\n     >\n     >      ssize_t\n     >      pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);\n     >     \n     >      ssize_t\n     >      write(int fildes, const void *buf, size_t nbyte);\n     >     \n     >      #include <sys/uio.h>\n     >     \n     >      ssize_t\n     >      writev(int fildes, const struct iovec *iov, int iovcnt);\n     >\n     > DESCRIPTION\n     >\n     > 省略部分内容.....................\n\n     所以我们的程序中增加代码如下：\n\n     ```c\n     #include <stdio.h>\n     #include <sys/types.h>\n     #include <sys/stat.h>\n     #include <fcntl.h>\n     #include <unistd.h>\n       \n     int main(void)\n     {\n             int fd = 0;\n             // 打开file.txt文件\n             fd = open(\"./file.txt\",O_RDWR);\n     \n             if(-1 == fd)\n             {\n                     printf(\"open fail\\n\");\n                     return 0;\n             }\n             else\n             {\n                     printf(\"open ok\\n\");\n             }\n             \n             // 往file.txt文件里面写入hello world\n             char buf[] = \"hello world\";\n             write(fd,(void *)buf,11);\n     \n             //ssize_t write(int fd, const void *buf, size_t count);\n     \n     \t    // 关闭文件\n             close(fd);\n     }\n     \n     \n     ```\n\n     \n\n   + 读取写入文件的到缓冲区，然后输出\n\n     读取file.txt文件里的内容到buf2中，然后输出，同样我们查看读文件的函数命令: \n\n     ```bash\n     $ man 2 read\n     ```\n\n     > READ(2)                     BSD System Calls Manual                    READ(2)\n     >\n     > NAME\n     >      pread, read, readv -- read input\n     >\n     > LIBRARY\n     >      Standard C Library (libc, -lc)\n     >\n     > SYNOPSIS\n     >      #include <sys/types.h>\n     >      #include <sys/uio.h>\n     >      #include <unistd.h>\n     >\n     > ```bash\n     >  ssize_t\n     >  pread(int d, void *buf, size_t nbyte, off_t offset);\n     > \n     >  ssize_t\n     >  read(int fildes, void *buf, size_t nbyte);\n     > \n     >  ssize_t\n     >  readv(int d, const struct iovec *iov, int iovcnt);\n     >  省略剩余内容.....................\n     > ```\n\n     然后我们的程序增加如下：\n\n     ```c\n     #include <sys/types.h>\n     #include <sys/stat.h>\n     #include <fcntl.h>\n     #include <unistd.h>\n     #include <stdio.h>\n     \n     int main(void)\n     {\n             int fd = 0;\n             // 打开file.txt文件\n             fd = open(\"./file.txt\",O_RDWR);\n     \n             if(-1 == fd)\n             {\n                     printf(\"open fail\\n\");\n                     return 0;\n             }\n             else\n             {\n                     printf(\"open ok\\n\");\n             }\n             // 往file.txt文件里面写入hello world\n             char buf[] = \"hello world\";\n             write(fd,(void *)buf,11);\n     \n             //ssize_t write(int fd, const void *buf, size_t count);\n     \n             // 把文件指向调到文件头部位置\n             lseek(fd, SEEK_SET, 0);\n             //off_t lseek(int fd, off_t offset, int whence);\n     \n             // 读取file.txt的内容到buf2中，然后输出\n             char buf2[30] = {0};\n             read(fd, buf2, sizeof(buf2));\n     \n             printf(\"buf2 = %s\\n\", buf2);\n     \n             // 关闭文件\n             close(fd);\n             \n             return 0;\n     }\n     \n     ```\n\n     到此为止，我们的程序基本就算是写完了！\n\n     \n\n3. 运行\n\n   + 那么让我们编译运行一下：\n\n     ```bash\n     $ gcc open_test1.c\n     ```\n\n     如果没有报错，则说明我们的程序没有问题：编译后会出现一个a.out文件如下：\n\n     ```bash\n     $ ll\n     总用量 20\n     -rwxr-xr-x. 1 root root 8704 5月 28 10:19 a.out\n     -rw-r–r--. 1 root root 11 5月 28 09:52 file.txt\n     -rw-r–r--. 1 root root 757 5月 28 10:12 open_test1.c\n     ```\n\n     然后让我们运行一下看一下结果：\n\n     ```bash\n     $ ./a.out\n     open ok\n     buf2 = hello world\n     ```\n\n     成功输出！！！\n\n     \n\n到这里一个简单的文件打开->写入->输出的简单操作就完成了。\n\n","slug":"linux编程-文件读取操作","published":1,"updated":"2022-02-27T11:30:00.838Z","_id":"cl064wjwa0015lcrbeqchhn80","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"这里写一个最简单的文件读取的操作流程：\"><a href=\"#这里写一个最简单的文件读取的操作流程：\" class=\"headerlink\" title=\"这里写一个最简单的文件读取的操作流程：\"></a>这里写一个最简单的文件读取的操作流程：</h3><ol>\n<li><p>安装环境</p>\n<p>我的系统是centos7，默认是不带有linux函数系统手册的，所以有需要的要先安装一下。具体的命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum -y install man-pages</span><br></pre></td></tr></table></figure>\n\n<p>出现如下提示，说明安装成功；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ Running transaction 正在安装 : man-pages-3.53-5.el7.noarch</span><br><span class=\"line\">$ 1/1 验证中 : man-pages-3.53-5.el7.noarch</span><br><span class=\"line\">$ 1/1 已安装: man-pages.noarch 0:3.53-5.el7</span><br><span class=\"line\">$ 完毕！</span><br></pre></td></tr></table></figure></li>\n<li><p>开始着手写我们的程序</p>\n<ul>\n<li><p>文件读取操作</p>\n<p>我们这里随便建一个c程序，就叫open_test1.c,首先写一个main函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们需要查询手册，来看linux系统是怎么打开一个文件的；这里我们要使用man 2 open 命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man 2 open</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>OPEN(2)                     BSD System Calls Manual                    OPEN(2)</p>\n<p>NAME</p>\n<pre><code> open, openat -- open or create a file for reading or writing\n</code></pre>\n<p>SYNOPSIS</p>\n<pre><code> #include &lt;fcntl.h&gt;\n\n int\n open(const char *path, int oflag, ...);\n\n int\n openat(int fd, const char *path, int oflag, ...);\n</code></pre>\n<p>DESCRIPTION</p>\n<pre><code> The file name specified by path is opened for reading and/or writing, as specified by the\n argument oflag; the file descriptor is returned to the calling process.\n</code></pre>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The oflag argument may indicate that the file is to be created <span class=\"keyword\">if</span> it does not exist (by speci-</span><br><span class=\"line\">fying the O_CREAT flag).  In this <span class=\"keyword\">case</span>, open() and openat() require an additional argument</span><br><span class=\"line\">mode_t mode; the file is created with mode mode as described <span class=\"keyword\">in</span> <span class=\"built_in\">chmod</span>(2) and modified by the</span><br><span class=\"line\">process<span class=\"string\">&#x27; umask value (see umask(2)).</span></span><br><span class=\"line\"><span class=\"string\">省略部分内容..........</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>具体的描述如如上面所示，所以我们根据他给我们的提示，写一个打开文件的操作，我们的程序中增加如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\">        fd = open(<span class=\"string\">&quot;./file.txt&quot;</span>,O_RDWR);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == fd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open fail\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open ok\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">         <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果文件打开正常，会打印出，open ok；</p>\n</li>\n<li><p>写文件操作</p>\n<p>同样的我们去查写操作手册，命令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man 2 write</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>WRITE(2)                    BSD System Calls Manual                   WRITE(2)</p>\n<p>NAME</p>\n<pre><code> pwrite, write, writev -- write output\n</code></pre>\n<p>LIBRARY</p>\n<pre><code> Standard C Library (libc, -lc)\n</code></pre>\n<p>SYNOPSIS</p>\n<pre><code> #include &lt;unistd.h&gt;\n\n ssize_t\n pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);\n\n ssize_t\n write(int fildes, const void *buf, size_t nbyte);\n\n #include &lt;sys/uio.h&gt;\n\n ssize_t\n writev(int fildes, const struct iovec *iov, int iovcnt);\n</code></pre>\n<p>DESCRIPTION</p>\n<p>省略部分内容…………………</p>\n</blockquote>\n<p>所以我们的程序中增加代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 打开file.txt文件</span></span><br><span class=\"line\">        fd = open(<span class=\"string\">&quot;./file.txt&quot;</span>,O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == fd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open fail\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open ok\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 往file.txt文件里面写入hello world</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[] = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        write(fd,(<span class=\"type\">void</span> *)buf,<span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>读取写入文件的到缓冲区，然后输出</p>\n<p>读取file.txt文件里的内容到buf2中，然后输出，同样我们查看读文件的函数命令: </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man 2 <span class=\"built_in\">read</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>READ(2)                     BSD System Calls Manual                    READ(2)</p>\n<p>NAME</p>\n<pre><code> pread, read, readv -- read input\n</code></pre>\n<p>LIBRARY</p>\n<pre><code> Standard C Library (libc, -lc)\n</code></pre>\n<p>SYNOPSIS</p>\n<pre><code> #include &lt;sys/types.h&gt;\n #include &lt;sys/uio.h&gt;\n #include &lt;unistd.h&gt;\n</code></pre>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t</span><br><span class=\"line\">pread(int d, void *buf, size_t nbyte, off_t offset);</span><br><span class=\"line\"></span><br><span class=\"line\">ssize_t</span><br><span class=\"line\"><span class=\"built_in\">read</span>(int fildes, void *buf, size_t nbyte);</span><br><span class=\"line\"></span><br><span class=\"line\">ssize_t</span><br><span class=\"line\">readv(int d, const struct iovec *iov, int iovcnt);</span><br><span class=\"line\">省略剩余内容.....................</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>然后我们的程序增加如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 打开file.txt文件</span></span><br><span class=\"line\">        fd = open(<span class=\"string\">&quot;./file.txt&quot;</span>,O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == fd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open fail\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open ok\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 往file.txt文件里面写入hello world</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[] = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        write(fd,(<span class=\"type\">void</span> *)buf,<span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把文件指向调到文件头部位置</span></span><br><span class=\"line\">        lseek(fd, SEEK_SET, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 读取file.txt的内容到buf2中，然后输出</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf2[<span class=\"number\">30</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        read(fd, buf2, <span class=\"keyword\">sizeof</span>(buf2));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;buf2 = %s\\n&quot;</span>, buf2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>到此为止，我们的程序基本就算是写完了！</p>\n</li>\n</ul>\n</li>\n<li><p>运行</p>\n<ul>\n<li><p>那么让我们编译运行一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc open_test1.c</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错，则说明我们的程序没有问题：编译后会出现一个a.out文件如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ll</span><br><span class=\"line\">总用量 20</span><br><span class=\"line\">-rwxr-xr-x. 1 root root 8704 5月 28 10:19 a.out</span><br><span class=\"line\">-rw-r–r--. 1 root root 11 5月 28 09:52 file.txt</span><br><span class=\"line\">-rw-r–r--. 1 root root 757 5月 28 10:12 open_test1.c</span><br></pre></td></tr></table></figure>\n\n<p>然后让我们运行一下看一下结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.out</span><br><span class=\"line\">open ok</span><br><span class=\"line\">buf2 = hello world</span><br></pre></td></tr></table></figure>\n\n<p>成功输出！！！</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>到这里一个简单的文件打开-&gt;写入-&gt;输出的简单操作就完成了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"这里写一个最简单的文件读取的操作流程：\"><a href=\"#这里写一个最简单的文件读取的操作流程：\" class=\"headerlink\" title=\"这里写一个最简单的文件读取的操作流程：\"></a>这里写一个最简单的文件读取的操作流程：</h3><ol>\n<li><p>安装环境</p>\n<p>我的系统是centos7，默认是不带有linux函数系统手册的，所以有需要的要先安装一下。具体的命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum -y install man-pages</span><br></pre></td></tr></table></figure>\n\n<p>出现如下提示，说明安装成功；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ Running transaction 正在安装 : man-pages-3.53-5.el7.noarch</span><br><span class=\"line\">$ 1/1 验证中 : man-pages-3.53-5.el7.noarch</span><br><span class=\"line\">$ 1/1 已安装: man-pages.noarch 0:3.53-5.el7</span><br><span class=\"line\">$ 完毕！</span><br></pre></td></tr></table></figure></li>\n<li><p>开始着手写我们的程序</p>\n<ul>\n<li><p>文件读取操作</p>\n<p>我们这里随便建一个c程序，就叫open_test1.c,首先写一个main函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们需要查询手册，来看linux系统是怎么打开一个文件的；这里我们要使用man 2 open 命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man 2 open</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>OPEN(2)                     BSD System Calls Manual                    OPEN(2)</p>\n<p>NAME</p>\n<pre><code> open, openat -- open or create a file for reading or writing\n</code></pre>\n<p>SYNOPSIS</p>\n<pre><code> #include &lt;fcntl.h&gt;\n\n int\n open(const char *path, int oflag, ...);\n\n int\n openat(int fd, const char *path, int oflag, ...);\n</code></pre>\n<p>DESCRIPTION</p>\n<pre><code> The file name specified by path is opened for reading and/or writing, as specified by the\n argument oflag; the file descriptor is returned to the calling process.\n</code></pre>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The oflag argument may indicate that the file is to be created <span class=\"keyword\">if</span> it does not exist (by speci-</span><br><span class=\"line\">fying the O_CREAT flag).  In this <span class=\"keyword\">case</span>, open() and openat() require an additional argument</span><br><span class=\"line\">mode_t mode; the file is created with mode mode as described <span class=\"keyword\">in</span> <span class=\"built_in\">chmod</span>(2) and modified by the</span><br><span class=\"line\">process<span class=\"string\">&#x27; umask value (see umask(2)).</span></span><br><span class=\"line\"><span class=\"string\">省略部分内容..........</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>具体的描述如如上面所示，所以我们根据他给我们的提示，写一个打开文件的操作，我们的程序中增加如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\">        fd = open(<span class=\"string\">&quot;./file.txt&quot;</span>,O_RDWR);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == fd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open fail\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open ok\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">         <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果文件打开正常，会打印出，open ok；</p>\n</li>\n<li><p>写文件操作</p>\n<p>同样的我们去查写操作手册，命令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man 2 write</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>WRITE(2)                    BSD System Calls Manual                   WRITE(2)</p>\n<p>NAME</p>\n<pre><code> pwrite, write, writev -- write output\n</code></pre>\n<p>LIBRARY</p>\n<pre><code> Standard C Library (libc, -lc)\n</code></pre>\n<p>SYNOPSIS</p>\n<pre><code> #include &lt;unistd.h&gt;\n\n ssize_t\n pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);\n\n ssize_t\n write(int fildes, const void *buf, size_t nbyte);\n\n #include &lt;sys/uio.h&gt;\n\n ssize_t\n writev(int fildes, const struct iovec *iov, int iovcnt);\n</code></pre>\n<p>DESCRIPTION</p>\n<p>省略部分内容…………………</p>\n</blockquote>\n<p>所以我们的程序中增加代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 打开file.txt文件</span></span><br><span class=\"line\">        fd = open(<span class=\"string\">&quot;./file.txt&quot;</span>,O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == fd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open fail\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open ok\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 往file.txt文件里面写入hello world</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[] = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        write(fd,(<span class=\"type\">void</span> *)buf,<span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>读取写入文件的到缓冲区，然后输出</p>\n<p>读取file.txt文件里的内容到buf2中，然后输出，同样我们查看读文件的函数命令: </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man 2 <span class=\"built_in\">read</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>READ(2)                     BSD System Calls Manual                    READ(2)</p>\n<p>NAME</p>\n<pre><code> pread, read, readv -- read input\n</code></pre>\n<p>LIBRARY</p>\n<pre><code> Standard C Library (libc, -lc)\n</code></pre>\n<p>SYNOPSIS</p>\n<pre><code> #include &lt;sys/types.h&gt;\n #include &lt;sys/uio.h&gt;\n #include &lt;unistd.h&gt;\n</code></pre>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t</span><br><span class=\"line\">pread(int d, void *buf, size_t nbyte, off_t offset);</span><br><span class=\"line\"></span><br><span class=\"line\">ssize_t</span><br><span class=\"line\"><span class=\"built_in\">read</span>(int fildes, void *buf, size_t nbyte);</span><br><span class=\"line\"></span><br><span class=\"line\">ssize_t</span><br><span class=\"line\">readv(int d, const struct iovec *iov, int iovcnt);</span><br><span class=\"line\">省略剩余内容.....................</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>然后我们的程序增加如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 打开file.txt文件</span></span><br><span class=\"line\">        fd = open(<span class=\"string\">&quot;./file.txt&quot;</span>,O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == fd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open fail\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;open ok\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 往file.txt文件里面写入hello world</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf[] = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        write(fd,(<span class=\"type\">void</span> *)buf,<span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把文件指向调到文件头部位置</span></span><br><span class=\"line\">        lseek(fd, SEEK_SET, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 读取file.txt的内容到buf2中，然后输出</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buf2[<span class=\"number\">30</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        read(fd, buf2, <span class=\"keyword\">sizeof</span>(buf2));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;buf2 = %s\\n&quot;</span>, buf2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>到此为止，我们的程序基本就算是写完了！</p>\n</li>\n</ul>\n</li>\n<li><p>运行</p>\n<ul>\n<li><p>那么让我们编译运行一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc open_test1.c</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错，则说明我们的程序没有问题：编译后会出现一个a.out文件如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ll</span><br><span class=\"line\">总用量 20</span><br><span class=\"line\">-rwxr-xr-x. 1 root root 8704 5月 28 10:19 a.out</span><br><span class=\"line\">-rw-r–r--. 1 root root 11 5月 28 09:52 file.txt</span><br><span class=\"line\">-rw-r–r--. 1 root root 757 5月 28 10:12 open_test1.c</span><br></pre></td></tr></table></figure>\n\n<p>然后让我们运行一下看一下结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.out</span><br><span class=\"line\">open ok</span><br><span class=\"line\">buf2 = hello world</span><br></pre></td></tr></table></figure>\n\n<p>成功输出！！！</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>到这里一个简单的文件打开-&gt;写入-&gt;输出的简单操作就完成了。</p>\n"},{"title":"深入解析声明式API（一）：API对象的奥秘","date":"2022-03-08T02:09:49.000Z","_content":"\n## Kubernetes 声明式 API 的工作原理\n\n> 如何利用这套 API 机制，在 Kubernetes 里添加自定义的 API 对象。\n\n\n\n你可能一直就很好奇：当我把一个 YAML 文件提交给 Kubernetes 之后，它究竟是如何创建出一个 API 对象的呢？\n\n这得从声明式 API 的设计谈起了。\n\n在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。\n\n通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：\n\n![image-20220308101716245](/Users/mayi/work/Ant/projects/blog/source/images/k8s/k8s-api-tree.png)\n\n在这幅图中，你可以很清楚地看到 **Kubernetes 里 API 对象的组织方式，其实是层层递进的。**\n\n比如，现在我要声明要创建一个 CronJob 对象，那么我的 YAML 文件的开始部分会这么写：\n\n```yaml\napiVersion: batch/v2alpha1\nkind: CronJob\n...\n```\n\n在这个 YAML 文件中，“CronJob”就是这个 API 对象的资源类型（Resource），“batch”就是它的组（Group），v2alpha1 就是它的版本（Version）。\n\n当我们提交了这个 YAML 文件之后，Kubernetes 就会把这个 YAML 文件里描述的内容，转换成 Kubernetes 里的一个 CronJob 对象。\n\n那么，<font color=orange>Kubernetes 是如何对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项目里找到 CronJob 对象的定义呢？</font>\n\n**首先，Kubernetes 会匹配 API 对象的组。**\n\n需要明确的是，对于 Kubernetes 里的核心 API 对象，比如：Pod、Node 等，是不需要 Group 的（即：它们的 Group 是“”）。所以，对于这些 API 对象来说，Kubernetes 会直接在 /api 这个层级进行下一步的匹配过程。\n\n而对于 CronJob 等非核心 API 对象来说，Kubernetes 就必须在 /apis 这个层级里查找它对应的 Group，进而根据“batch”这个 Group 的名字，找到 /apis/batch。\n\n不难发现，这些 API Group 的分类是以对象功能为依据的，比如 Job 和 CronJob 就都属于“batch” （离线业务）这个 Group。\n\n**然后，Kubernetes 会进一步匹配到 API 对象的版本号。**\n\n对于 CronJob 这个 API 对象来说，Kubernetes 在 batch 这个 Group 下，匹配到的版本号就是 v2alpha1。\n\n在 Kubernetes 中，同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。这样，比如在 CronJob 的开发过程中，对于会影响到用户的变更就可以通过升级新版本来处理，从而保证了向后兼容。\n\n**最后，Kubernetes 会匹配 API 对象的资源类型。**\n\n在前面匹配到正确的版本之后，Kubernetes 就知道，我要创建的原来是一个 /apis/batch/v2alpha1 下的 CronJob 对象。\n\n这时候，<font color=orange>APIServer 就可以继续创建这个 CronJob 对象了。</font>为了方便理解，我为你总结了一个如下所示流程图来阐述这个创建过程：\n\n![img](/Users/mayi/work/Ant/projects/blog/source/images/k8s/api-server-build.png)\n\n**首先，**当我们发起了创建 CronJob 的 POST 请求之后，我们编写的 YAML 的信息就被提交给了 APIServer。\n\n而 APIServer 的第一个功能，就是过滤这个请求，并完成一些前置性的工作，比如授权、超时处理、审计等。\n\n**然后，**请求会进入 MUX 和 Routes 流程。如果你编写过 Web Server 的话就会知道，MUX 和 Routes 是 APIServer 完成 URL 和 Handler 绑定的场所。而 APIServer 的 Handler 要做的事情，就是按照我刚刚介绍的匹配过程，找到对应的 CronJob 类型定义。\n\n**接着，**APIServer 最重要的职责就来了：根据这个 CronJob 类型定义，使用用户提交的 YAML 文件里的字段，创建一个 CronJob 对象。\n\n而在这个过程中，APIServer 会进行一个 Convert 工作，即：把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。这样用户提交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理了。\n\n**接下来，**APIServer 会先后进行 Admission() 和 Validation() 操作。比如，我在上一篇文章中提到的 Admission Controller 和 Initializer，就都属于 Admission 的内容。\n\n而 Validation，则负责验证这个对象里的各个字段是否合法。这个被验证过的 API 对象，都保存在了 APIServer 里一个叫作 Registry 的数据结构中。也就是说，只要一个 API 对象的定义能在 Registry 里查到，它就是一个有效的 Kubernetes API 对象。\n\n**最后，**APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 把它保存起来。\n\n由此可见，声明式 API 对于 Kubernetes 来说非常重要。所以，**APIServer 这样一个在其他项目里“平淡无奇”的组件，却成了 Kubernetes 项目的重中之重。**它不仅是 Google Borg 设计思想的集中体现，也是 Kubernetes 项目里唯一一个被 Google 公司和 RedHat 公司双重控制、其他势力根本无法参与其中的组件。\n\n此外，由于同时要兼顾性能、API 完备性、版本化、向后兼容等很多工程化指标，所以 Kubernetes 团队在 APIServer 项目里大量使用了 Go 语言的代码生成功能，来自动化诸如 Convert、DeepCopy 等与 API 资源相关的操作。这部分自动生成的代码，曾一度占到 Kubernetes 项目总代码的 20%~30%。\n\n这也是为何，在过去很长一段时间里，在这样一个极其“复杂”的 APIServer 中，添加一个 Kubernetes 风格的 API 资源类型，是一个非常困难的工作。\n\n不过，在 Kubernetes v1.7 之后，这个工作就变得轻松得多了。这，当然得益于一个全新的 API 插件机制：CRD。\n\nCRD 的全称是 Custom Resource Definition。顾名思义，它指的就是，允许用户在 Kubernetes 中添加一个跟 Pod、Node 类似的、新的 API 资源类型，即：自定义 API 资源。\n\n举个例子，<font color=orange>我现在要为 Kubernetes 添加一个名叫 Network 的 API 资源类型。</font>\n\n它的作用是，一旦用户创建一个 Network 对象，那么 Kubernetes 就应该使用这个对象定义的网络参数，调用真实的网络插件，比如 Neutron 项目，为用户创建一个真正的“网络”。这样，将来用户创建的 Pod，就可以声明使用这个“网络”了。\n\n这个 Network 对象的 YAML 文件，名叫 example-network.yaml，它的内容如下所示：\n\n```yaml\napiVersion: samplecrd.x-k8s.io/v1\nkind: Network\nmetadata:\n  name: example-network\nspec:\n  cidr: \"192.168.0.0/16\"\n  gateway: \"192.168.0.1\"\n```\n\n\n\n可以看到，我想要描述“网络”的 API 资源类型是 Network；API 组是samplecrd.k8s.io；API 版本是 v1。\n\n那么，<font color=orange>Kubernetes 又该如何知道这个 API（samplecrd.k8s.io/v1/network）的存在呢？</font>\n\n其实，上面的这个 YAML 文件，就是一个具体的“自定义 API 资源”实例，也叫 CR（Custom Resource）。而为了能够让 Kubernetes 认识这个 CR，你就需要让 Kubernetes 明白这个 CR 的宏观定义是什么，也就是 CRD（Custom Resource Definition）。\n\n这就好比，你想让计算机认识各种兔子的照片，就得先让计算机明白，兔子的普遍定义是什么。比如，兔子“是哺乳动物”“有长耳朵，三瓣嘴”。\n\n所以，接下来，我就先编写一个 CRD 的 YAML 文件，它的名字叫作 network.yaml，内容如下所示：\n\n```yaml\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  # name must match the spec fields below, and be in the form: <plural>.<group>\n  name: networks.samplecrd.x-k8s.io\nspec:\n  # group name to use for REST API: /apis/<group>/<version>\n  group: samplecrd.x-k8s.io\n  versions:\n    - name: v1\n      # Each version can be enabled/disabled by Served flag.\n      served: true\n      # One and only one version must be marked as the storage version.\n      storage: true\n      schema:\n        openAPIV3Schema:\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                cidr:\n                  type: string\n                gateway:\n                  type: string\n  # either Namespaced or Cluster\n  scope: Namespaced\n  names:\n    # plural name to be used in the URL: /apis/<group>/<version>/<plural>\n    plural: networks\n    # singular name to be used as an alias on the CLI and for display\n    singular: network\n    # kind is normally the CamelCased singular type. Your resource manifests use this.\n    kind: Network\n    shortNames:\n    - nw\n```\n\n可以看到，在这个 CRD 中，我指定了“group: samplecrd.x-k8s.io” “version: v1”这样的 API 信息，也指定了这个 CR 的资源类型叫作 Network，复数（plural）是 networks。\n\n> <font color=red>**注意: **</font> 这里最新的1.23.0版本的k8s不能使用*.k8s.io后缀，最好替换为.x-k8s.io。\n\n\n\n然后，我还声明了它的 scope 是 Namespaced，即：我们定义的这个 Network 是一个属于 Namespace 的对象，类似于 Pod。\n\n这就是一个 Network API 资源类型的 API 部分的宏观定义了。这就等同于告诉了计算机：“兔子是哺乳动物”。所以这时候，Kubernetes 就能够认识和处理所有声明了 API 类型是“samplecrd.k8s.io/v1/network”的 YAML 文件了。\n\n接下来，我还需要让 Kubernetes“认识”这种 YAML 文件里描述的“网络”部分，比如“cidr”（网段），“gateway”（网关）这些字段的含义。这就相当于我要告诉计算机：“兔子有长耳朵和三瓣嘴”。\n\n这时候呢，我就需要稍微做些代码工作了。\n\n**首先，我要在 GOPATH 下，创建一个结构如下的项目：**\n\n> 备注：在这里，我并不要求你具有完备的 Go 语言知识体系，但我会假设你已经了解了 Golang 的一些基本知识（比如，知道什么是 GOPATH）。而如果你还不了解的话，可以在涉及到相关内容时，再去查阅一些相关资料。\n\n```bash\n\n$ tree $GOPATH/src/github.com/<your-name>/k8s-controller-custom-resource\n.\n├── controller.go\n├── crd\n│   └── network.yaml\n├── example\n│   └── example-network.yaml\n├── main.go\n└── pkg\n    └── apis\n        └── samplecrd\n            ├── register.go\n            └── v1\n                ├── doc.go\n                ├── register.go\n                └── types.go\n```\n\n其中，pkg/apis/samplecrd 就是 API 组的名字，v1 是版本，而 v1 下面的 types.go 文件里，则定义了 Network 对象的完整描述。我已经把这个[项目上传到了 GitHub 上](https://github.com/gxstax/k8s-custom-controller \"github地址\")，你可以随时参考。\n\n**然后，我在 pkg/apis/samplecrd 目录下创建了一个 register.go 文件，用来放置后面要用到的全局变量。**这个文件的内容如下所示：\n\n```go\npackage samplecrd\n\nconst (\n GroupName = \"samplecrd.k8s.io\"\n Version   = \"v1\"\n)\n```\n\n**接着，我需要在 pkg/apis/samplecrd 目录下添加一个 doc.go 文件（Golang 的文档源文件）。**这个文件里的内容如下所示：\n\n```go\n// +k8s:deepcopy-gen=package\n\n// +groupName=samplecrd.k8s.io\npackage v1\n```\n\n在这个文件中，你会看到 +< tag_name >[=value]格式的注释，这就是 Kubernetes 进行代码生成要用的 Annotation 风格的注释。\n\n其中，+k8s:deepcopy-gen=package 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；而+groupName=samplecrd.k8s.io，则定义了这个包对应的 API 组的名字。\n\n可以看到，这些定义在 doc.go 文件的注释，起到的是全局的代码生成控制的作用，所以也被称为 Global Tags。\n\n**接下来，我需要添加 types.go 文件。**顾名思义，它的作用就是定义一个 Network 类型到底有哪些字段（比如，spec 字段里的内容）。这个文件的主要内容如下所示：\n\n```go\n\npackage v1\n...\n// +genclient\n// +genclient:noStatus\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// Network describes a Network resource\ntype Network struct {\n // TypeMeta is the metadata for the resource, like kind and apiversion\n metav1.TypeMeta `json:\",inline\"`\n // ObjectMeta contains the metadata for the particular object, including\n // things like...\n //  - name\n //  - namespace\n //  - self link\n //  - labels\n //  - ... etc ...\n metav1.ObjectMeta `json:\"metadata,omitempty\"`\n \n Spec networkspec `json:\"spec\"`\n}\n// networkspec is the spec for a Network resource\ntype networkspec struct {\n Cidr    string `json:\"cidr\"`\n Gateway string `json:\"gateway\"`\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// NetworkList is a list of Network resources\ntype NetworkList struct {\n metav1.TypeMeta `json:\",inline\"`\n metav1.ListMeta `json:\"metadata\"`\n \n Items []Network `json:\"items\"`\n}\n```\n\n在上面这部分代码里，你可以看到 Network 类型定义方法跟标准的 Kubernetes 对象一样，都包括了 TypeMeta（API 元数据）和 ObjectMeta（对象元数据）字段。\n\n而其中的 Spec 字段，就是需要我们自己定义的部分。所以，在 networkspec 里，我定义了 Cidr 和 Gateway 两个字段。其中，每个字段最后面的部分比如json:\"cidr\"，指的就是这个字段被转换成 JSON 格式之后的名字，也就是 YAML 文件里的字段名字。\n\n> 如果你不熟悉这个用法的话，可以查阅一下 Golang 的文档。\n\n此外，除了定义 Network 类型，你还需要定义一个 NetworkList 类型，用来描述一组 Network 对象应该包括哪些字段。之所以需要这样一个类型，是因为在 Kubernetes 中，获取所有 X 对象的 List() 方法，返回值都是List 类型，而不是 X 类型的数组。这是不一样的。\n\n同样地，在 Network 和 NetworkList 类型上，也有代码生成注释。\n\n其中，+genclient 的意思是：请为下面这个 API 资源类型生成对应的 Client 代码（这个 Client，我马上会讲到）。而 +genclient:noStatus 的意思是：这个 API 资源类型定义里，没有 Status 字段。否则，生成的 Client 就会自动带上 UpdateStatus 方法。\n\n如果你的类型定义包括了 Status 字段的话，就不需要这句 +genclient:noStatus 注释了。比如下面这个例子：\n\n```go\n\n// +genclient\n\n// Network is a specification for a Network resource\ntype Network struct {\n metav1.TypeMeta   `json:\",inline\"`\n metav1.ObjectMeta `json:\"metadata,omitempty\"`\n \n Spec   NetworkSpec   `json:\"spec\"`\n Status NetworkStatus `json:\"status\"`\n}\n```\n\n需要注意的是，+genclient 只需要写在 Network 类型上，而不用写在 NetworkList 上。因为 NetworkList 只是一个返回值类型，Network 才是“主类型”。\n\n而由于我在 Global Tags 里已经定义了为所有类型生成 DeepCopy 方法，所以这里就不需要再显式地加上 +k8s:deepcopy-gen=true 了。当然，这也就意味着你可以用 +k8s:deepcopy-gen=false 来阻止为某些类型生成 DeepCopy。\n\n你可能已经注意到，在这两个类型上面还有一句+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object的注释。它的意思是，请在生成 DeepCopy 的时候，实现 Kubernetes 提供的 runtime.Object 接口。否则，在某些版本的 Kubernetes 里，你的这个类型定义会出现编译错误。这是一个固定的操作，记住即可。\n\n不过，你或许会有这样的顾虑：这些代码生成注释这么灵活，我该怎么掌握呢？\n\n其实，上面我所讲述的内容，已经足以应对 99% 的场景了。当然，如果你对代码生成感兴趣的话，我推荐你阅读这篇博客，它详细地介绍了 Kubernetes 的代码生成语法。\n\n**最后，我需要再编写一个 pkg/apis/samplecrd/v1/register.go 文件。**\n\n在前面对 APIServer 工作原理的讲解中，我已经提到，“registry”的作用就是注册一个类型（Type）给 APIServer。其中，Network 资源类型在服务器端注册的工作，APIServer 会自动帮我们完成。但与之对应的，我们还需要让客户端也能“知道”Network 资源类型的定义。这就需要我们在项目里添加一个 register.go 文件。它最主要的功能，就是定义了如下所示的 addKnownTypes() 方法：\n\n```go\npackage v1\n...\n// addKnownTypes adds our types to the API scheme by registering\n// Network and NetworkList\nfunc addKnownTypes(scheme *runtime.Scheme) error {\n scheme.AddKnownTypes(\n  SchemeGroupVersion,\n  &Network{},\n  &NetworkList{},\n )\n \n // register the type in the scheme\n metav1.AddToGroupVersion(scheme, SchemeGroupVersion)\n return nil\n}\n```\n\n\n\n有了这个方法，Kubernetes 就能够在后面生成客户端的时候，“知道”Network 以及 NetworkList 类型的定义了。\n\n像上面这种 **register.go 文件里的内容其实是非常固定的，你以后可以直接使用我提供的这部分代码做模板，然后把其中的资源类型、GroupName 和 Version 替换成你自己的定义即可。**\n\n这样，Network 对象的定义工作就全部完成了。可以看到，它其实定义了两部分内容：\n\n* 第一部分是，自定义资源类型的 API 描述，包括：组（Group）、版本（Version）、资源类型（Resource）等。这相当于告诉了计算机：兔子是哺乳动物。\n* 第二部分是，自定义资源类型的对象描述，包括：Spec、Status 等。这相当于告诉了计算机：兔子有长耳朵和三瓣嘴。\n\n接下来，<font color=orange>我就要使用 Kubernetes 提供的代码生成工具，为上面定义的 Network 资源类型自动生成 clientset、informer 和 lister。</font>其中，clientset 就是操作 Network 对象所需要使用的客户端，而 informer 和 lister 这两个包的主要功能，我会在下一篇文章中重点讲解。\n\n这个代码生成工具名叫k8s.io/code-generator，使用方法如下所示：\n\n```bash\n\n# 代码生成的工作目录，也就是我们的项目路径\n$ ROOT_PACKAGE=\"github.com/gxstax/k8s-custom-controller\"\n# API Group\n$ CUSTOM_RESOURCE_NAME=\"samplecrd\"\n# API Version\n$ CUSTOM_RESOURCE_VERSION=\"v1\"\n\n# 安装k8s.io/code-generator\n$ go get -u k8s.io/code-generator/...\n$ cd $GOPATH/src/k8s.io/code-generator\n\n# 执行代码自动生成，其中pkg/client是生成目标目录，pkg/apis是类型定义目录\n$ ./generate-groups.sh all \"$ROOT_PACKAGE/pkg/client\" \"$ROOT_PACKAGE/pkg/apis\" \"$CUSTOM_RESOURCE_NAME:$CUSTOM_RESOURCE_VERSION\"\n```\n\n代码生成工作完成之后，我们再查看一下这个项目的目录结构：\n\n```\n$ tree\n.\n└── pkg\n    ├── apis\n    │   └── samplecrd\n    │       ├── register.go\n    │       └── v1\n    │           ├── doc.go\n    │           ├── register.go\n    │           └── types.go\n    └── client\n        └── clientset\n            └── versioned\n                ├── clientset.go\n                ├── doc.go\n                ├── fake\n                │   ├── clientset_generated.go\n                │   ├── doc.go\n                │   └── register.go\n                ├── scheme\n                │   ├── doc.go\n                │   └── register.go\n                └── typed\n                    └── samplecrd\n                        └── v1\n                            ├── doc.go\n                            ├── fake\n                            │   ├── doc.go\n                            │   └── fake_samplecrd_client.go\n                            ├── generated_expansion.go\n                            └── samplecrd_client.go\n```\n\n其中，pkg/apis/samplecrd/v1 下面的 zz_generated.deepcopy.go 文件，就是自动生成的 DeepCopy 代码文件。\n\n而整个 client 目录，以及下面的三个包（clientset、informers、 listers），都是 Kubernetes 为 Network 类型生成的客户端库，这些库会在后面编写自定义控制器的时候用到。\n\n可以看到，到目前为止的这些工作，其实并不要求你写多少代码，主要考验的是“复制、粘贴、替换”这样的“基本功”。\n\n而有了这些内容，现在你就可以<font color=orange>在 Kubernetes 集群里创建一个 Network 类型的 API 对象了。</font>我们不妨一起来试验下。\n\n**首先，** 使用 network.yaml 文件，在 Kubernetes 中创建 Network 对象的 CRD（Custom Resource Definition）：\n\n```bash\n$ kubectl apply -f crd/network.yaml\ncustomresourcedefinition.apiextensions.k8s.io/networks.samplecrd.x-k8s.io created\n```\n\n这个操作，就告诉了 Kubernetes，我现在要添加一个自定义的 API 对象。而这个对象的 API 信息，正是 network.yaml 里定义的内容。我们可以通过 kubectl get 命令，查看这个 CRD：\n\n```bash\n$ kubectl get crd\nNAME                                         CREATED AT\nnetworks.samplecrd.x-k8s.io                  2022-03-08T07:26:58Z\n```\n\n**然后，**我们就可以创建一个 Network 对象了，这里用到的是 example-network.yaml：\n\n```bash\n$ kubectl apply -f example/example-network.yaml\nnetwork.samplecrd.x-k8s.io/example-network created\n```\n\n通过这个操作，你就在 Kubernetes 集群里创建了一个 Network 对象。它的 API 资源路径是samplecrd.k8s.io/v1/networks。\n\n这时候，你就可以通过 kubectl get 命令，查看到新创建的 Network 对象：\n\n```bash\n$ kubectl get network\nNAME              AGE\nexample-network   101s\n```\n\n你还可以通过 kubectl describe 命令，看到这个 Network 对象的细节：\n\n```bash\n$ kubectl describe network example-network\nName:         example-network\nNamespace:    default\nLabels:       <none>\nAnnotations:  <none>\nAPI Version:  samplecrd.x-k8s.io/v1\nKind:         Network\nMetadata:\n  Creation Timestamp:  2022-03-08T07:27:22Z\n  Generation:          1\n  Managed Fields:\n    API Version:  samplecrd.x-k8s.io/v1\n    Fields Type:  FieldsV1\n    fieldsV1:\n      f:metadata:\n        f:annotations:\n          .:\n          f:kubectl.kubernetes.io/last-applied-configuration:\n      f:spec:\n        .:\n        f:cidr:\n        f:gateway:\n    Manager:         kubectl-client-side-apply\n    Operation:       Update\n    Time:            2022-03-08T07:27:22Z\n  Resource Version:  4582056\n  UID:               86a7188c-4dec-4479-9e72-36ac92b0af63\nSpec:\n  Cidr:     192.168.0.0/16\n  Gateway:  192.168.0.1\nEvents:     <none>\n```\n\n当然 ，你也可以编写更多的 YAML 文件来创建更多的 Network 对象，这和创建 Pod、Deployment 的操作，没有任何区别。\n\n","source":"_posts/深入解析声明式API（一）：API对象的奥秘.md","raw":"---\ntitle: 深入解析声明式API（一）：API对象的奥秘\ndate: 2022-03-08 10:09:49\ncategories: \n    - [云原生, k8s]\ntags: [k8s]\n---\n\n## Kubernetes 声明式 API 的工作原理\n\n> 如何利用这套 API 机制，在 Kubernetes 里添加自定义的 API 对象。\n\n\n\n你可能一直就很好奇：当我把一个 YAML 文件提交给 Kubernetes 之后，它究竟是如何创建出一个 API 对象的呢？\n\n这得从声明式 API 的设计谈起了。\n\n在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。\n\n通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：\n\n![image-20220308101716245](/Users/mayi/work/Ant/projects/blog/source/images/k8s/k8s-api-tree.png)\n\n在这幅图中，你可以很清楚地看到 **Kubernetes 里 API 对象的组织方式，其实是层层递进的。**\n\n比如，现在我要声明要创建一个 CronJob 对象，那么我的 YAML 文件的开始部分会这么写：\n\n```yaml\napiVersion: batch/v2alpha1\nkind: CronJob\n...\n```\n\n在这个 YAML 文件中，“CronJob”就是这个 API 对象的资源类型（Resource），“batch”就是它的组（Group），v2alpha1 就是它的版本（Version）。\n\n当我们提交了这个 YAML 文件之后，Kubernetes 就会把这个 YAML 文件里描述的内容，转换成 Kubernetes 里的一个 CronJob 对象。\n\n那么，<font color=orange>Kubernetes 是如何对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项目里找到 CronJob 对象的定义呢？</font>\n\n**首先，Kubernetes 会匹配 API 对象的组。**\n\n需要明确的是，对于 Kubernetes 里的核心 API 对象，比如：Pod、Node 等，是不需要 Group 的（即：它们的 Group 是“”）。所以，对于这些 API 对象来说，Kubernetes 会直接在 /api 这个层级进行下一步的匹配过程。\n\n而对于 CronJob 等非核心 API 对象来说，Kubernetes 就必须在 /apis 这个层级里查找它对应的 Group，进而根据“batch”这个 Group 的名字，找到 /apis/batch。\n\n不难发现，这些 API Group 的分类是以对象功能为依据的，比如 Job 和 CronJob 就都属于“batch” （离线业务）这个 Group。\n\n**然后，Kubernetes 会进一步匹配到 API 对象的版本号。**\n\n对于 CronJob 这个 API 对象来说，Kubernetes 在 batch 这个 Group 下，匹配到的版本号就是 v2alpha1。\n\n在 Kubernetes 中，同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。这样，比如在 CronJob 的开发过程中，对于会影响到用户的变更就可以通过升级新版本来处理，从而保证了向后兼容。\n\n**最后，Kubernetes 会匹配 API 对象的资源类型。**\n\n在前面匹配到正确的版本之后，Kubernetes 就知道，我要创建的原来是一个 /apis/batch/v2alpha1 下的 CronJob 对象。\n\n这时候，<font color=orange>APIServer 就可以继续创建这个 CronJob 对象了。</font>为了方便理解，我为你总结了一个如下所示流程图来阐述这个创建过程：\n\n![img](/Users/mayi/work/Ant/projects/blog/source/images/k8s/api-server-build.png)\n\n**首先，**当我们发起了创建 CronJob 的 POST 请求之后，我们编写的 YAML 的信息就被提交给了 APIServer。\n\n而 APIServer 的第一个功能，就是过滤这个请求，并完成一些前置性的工作，比如授权、超时处理、审计等。\n\n**然后，**请求会进入 MUX 和 Routes 流程。如果你编写过 Web Server 的话就会知道，MUX 和 Routes 是 APIServer 完成 URL 和 Handler 绑定的场所。而 APIServer 的 Handler 要做的事情，就是按照我刚刚介绍的匹配过程，找到对应的 CronJob 类型定义。\n\n**接着，**APIServer 最重要的职责就来了：根据这个 CronJob 类型定义，使用用户提交的 YAML 文件里的字段，创建一个 CronJob 对象。\n\n而在这个过程中，APIServer 会进行一个 Convert 工作，即：把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。这样用户提交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理了。\n\n**接下来，**APIServer 会先后进行 Admission() 和 Validation() 操作。比如，我在上一篇文章中提到的 Admission Controller 和 Initializer，就都属于 Admission 的内容。\n\n而 Validation，则负责验证这个对象里的各个字段是否合法。这个被验证过的 API 对象，都保存在了 APIServer 里一个叫作 Registry 的数据结构中。也就是说，只要一个 API 对象的定义能在 Registry 里查到，它就是一个有效的 Kubernetes API 对象。\n\n**最后，**APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 把它保存起来。\n\n由此可见，声明式 API 对于 Kubernetes 来说非常重要。所以，**APIServer 这样一个在其他项目里“平淡无奇”的组件，却成了 Kubernetes 项目的重中之重。**它不仅是 Google Borg 设计思想的集中体现，也是 Kubernetes 项目里唯一一个被 Google 公司和 RedHat 公司双重控制、其他势力根本无法参与其中的组件。\n\n此外，由于同时要兼顾性能、API 完备性、版本化、向后兼容等很多工程化指标，所以 Kubernetes 团队在 APIServer 项目里大量使用了 Go 语言的代码生成功能，来自动化诸如 Convert、DeepCopy 等与 API 资源相关的操作。这部分自动生成的代码，曾一度占到 Kubernetes 项目总代码的 20%~30%。\n\n这也是为何，在过去很长一段时间里，在这样一个极其“复杂”的 APIServer 中，添加一个 Kubernetes 风格的 API 资源类型，是一个非常困难的工作。\n\n不过，在 Kubernetes v1.7 之后，这个工作就变得轻松得多了。这，当然得益于一个全新的 API 插件机制：CRD。\n\nCRD 的全称是 Custom Resource Definition。顾名思义，它指的就是，允许用户在 Kubernetes 中添加一个跟 Pod、Node 类似的、新的 API 资源类型，即：自定义 API 资源。\n\n举个例子，<font color=orange>我现在要为 Kubernetes 添加一个名叫 Network 的 API 资源类型。</font>\n\n它的作用是，一旦用户创建一个 Network 对象，那么 Kubernetes 就应该使用这个对象定义的网络参数，调用真实的网络插件，比如 Neutron 项目，为用户创建一个真正的“网络”。这样，将来用户创建的 Pod，就可以声明使用这个“网络”了。\n\n这个 Network 对象的 YAML 文件，名叫 example-network.yaml，它的内容如下所示：\n\n```yaml\napiVersion: samplecrd.x-k8s.io/v1\nkind: Network\nmetadata:\n  name: example-network\nspec:\n  cidr: \"192.168.0.0/16\"\n  gateway: \"192.168.0.1\"\n```\n\n\n\n可以看到，我想要描述“网络”的 API 资源类型是 Network；API 组是samplecrd.k8s.io；API 版本是 v1。\n\n那么，<font color=orange>Kubernetes 又该如何知道这个 API（samplecrd.k8s.io/v1/network）的存在呢？</font>\n\n其实，上面的这个 YAML 文件，就是一个具体的“自定义 API 资源”实例，也叫 CR（Custom Resource）。而为了能够让 Kubernetes 认识这个 CR，你就需要让 Kubernetes 明白这个 CR 的宏观定义是什么，也就是 CRD（Custom Resource Definition）。\n\n这就好比，你想让计算机认识各种兔子的照片，就得先让计算机明白，兔子的普遍定义是什么。比如，兔子“是哺乳动物”“有长耳朵，三瓣嘴”。\n\n所以，接下来，我就先编写一个 CRD 的 YAML 文件，它的名字叫作 network.yaml，内容如下所示：\n\n```yaml\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  # name must match the spec fields below, and be in the form: <plural>.<group>\n  name: networks.samplecrd.x-k8s.io\nspec:\n  # group name to use for REST API: /apis/<group>/<version>\n  group: samplecrd.x-k8s.io\n  versions:\n    - name: v1\n      # Each version can be enabled/disabled by Served flag.\n      served: true\n      # One and only one version must be marked as the storage version.\n      storage: true\n      schema:\n        openAPIV3Schema:\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                cidr:\n                  type: string\n                gateway:\n                  type: string\n  # either Namespaced or Cluster\n  scope: Namespaced\n  names:\n    # plural name to be used in the URL: /apis/<group>/<version>/<plural>\n    plural: networks\n    # singular name to be used as an alias on the CLI and for display\n    singular: network\n    # kind is normally the CamelCased singular type. Your resource manifests use this.\n    kind: Network\n    shortNames:\n    - nw\n```\n\n可以看到，在这个 CRD 中，我指定了“group: samplecrd.x-k8s.io” “version: v1”这样的 API 信息，也指定了这个 CR 的资源类型叫作 Network，复数（plural）是 networks。\n\n> <font color=red>**注意: **</font> 这里最新的1.23.0版本的k8s不能使用*.k8s.io后缀，最好替换为.x-k8s.io。\n\n\n\n然后，我还声明了它的 scope 是 Namespaced，即：我们定义的这个 Network 是一个属于 Namespace 的对象，类似于 Pod。\n\n这就是一个 Network API 资源类型的 API 部分的宏观定义了。这就等同于告诉了计算机：“兔子是哺乳动物”。所以这时候，Kubernetes 就能够认识和处理所有声明了 API 类型是“samplecrd.k8s.io/v1/network”的 YAML 文件了。\n\n接下来，我还需要让 Kubernetes“认识”这种 YAML 文件里描述的“网络”部分，比如“cidr”（网段），“gateway”（网关）这些字段的含义。这就相当于我要告诉计算机：“兔子有长耳朵和三瓣嘴”。\n\n这时候呢，我就需要稍微做些代码工作了。\n\n**首先，我要在 GOPATH 下，创建一个结构如下的项目：**\n\n> 备注：在这里，我并不要求你具有完备的 Go 语言知识体系，但我会假设你已经了解了 Golang 的一些基本知识（比如，知道什么是 GOPATH）。而如果你还不了解的话，可以在涉及到相关内容时，再去查阅一些相关资料。\n\n```bash\n\n$ tree $GOPATH/src/github.com/<your-name>/k8s-controller-custom-resource\n.\n├── controller.go\n├── crd\n│   └── network.yaml\n├── example\n│   └── example-network.yaml\n├── main.go\n└── pkg\n    └── apis\n        └── samplecrd\n            ├── register.go\n            └── v1\n                ├── doc.go\n                ├── register.go\n                └── types.go\n```\n\n其中，pkg/apis/samplecrd 就是 API 组的名字，v1 是版本，而 v1 下面的 types.go 文件里，则定义了 Network 对象的完整描述。我已经把这个[项目上传到了 GitHub 上](https://github.com/gxstax/k8s-custom-controller \"github地址\")，你可以随时参考。\n\n**然后，我在 pkg/apis/samplecrd 目录下创建了一个 register.go 文件，用来放置后面要用到的全局变量。**这个文件的内容如下所示：\n\n```go\npackage samplecrd\n\nconst (\n GroupName = \"samplecrd.k8s.io\"\n Version   = \"v1\"\n)\n```\n\n**接着，我需要在 pkg/apis/samplecrd 目录下添加一个 doc.go 文件（Golang 的文档源文件）。**这个文件里的内容如下所示：\n\n```go\n// +k8s:deepcopy-gen=package\n\n// +groupName=samplecrd.k8s.io\npackage v1\n```\n\n在这个文件中，你会看到 +< tag_name >[=value]格式的注释，这就是 Kubernetes 进行代码生成要用的 Annotation 风格的注释。\n\n其中，+k8s:deepcopy-gen=package 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；而+groupName=samplecrd.k8s.io，则定义了这个包对应的 API 组的名字。\n\n可以看到，这些定义在 doc.go 文件的注释，起到的是全局的代码生成控制的作用，所以也被称为 Global Tags。\n\n**接下来，我需要添加 types.go 文件。**顾名思义，它的作用就是定义一个 Network 类型到底有哪些字段（比如，spec 字段里的内容）。这个文件的主要内容如下所示：\n\n```go\n\npackage v1\n...\n// +genclient\n// +genclient:noStatus\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// Network describes a Network resource\ntype Network struct {\n // TypeMeta is the metadata for the resource, like kind and apiversion\n metav1.TypeMeta `json:\",inline\"`\n // ObjectMeta contains the metadata for the particular object, including\n // things like...\n //  - name\n //  - namespace\n //  - self link\n //  - labels\n //  - ... etc ...\n metav1.ObjectMeta `json:\"metadata,omitempty\"`\n \n Spec networkspec `json:\"spec\"`\n}\n// networkspec is the spec for a Network resource\ntype networkspec struct {\n Cidr    string `json:\"cidr\"`\n Gateway string `json:\"gateway\"`\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// NetworkList is a list of Network resources\ntype NetworkList struct {\n metav1.TypeMeta `json:\",inline\"`\n metav1.ListMeta `json:\"metadata\"`\n \n Items []Network `json:\"items\"`\n}\n```\n\n在上面这部分代码里，你可以看到 Network 类型定义方法跟标准的 Kubernetes 对象一样，都包括了 TypeMeta（API 元数据）和 ObjectMeta（对象元数据）字段。\n\n而其中的 Spec 字段，就是需要我们自己定义的部分。所以，在 networkspec 里，我定义了 Cidr 和 Gateway 两个字段。其中，每个字段最后面的部分比如json:\"cidr\"，指的就是这个字段被转换成 JSON 格式之后的名字，也就是 YAML 文件里的字段名字。\n\n> 如果你不熟悉这个用法的话，可以查阅一下 Golang 的文档。\n\n此外，除了定义 Network 类型，你还需要定义一个 NetworkList 类型，用来描述一组 Network 对象应该包括哪些字段。之所以需要这样一个类型，是因为在 Kubernetes 中，获取所有 X 对象的 List() 方法，返回值都是List 类型，而不是 X 类型的数组。这是不一样的。\n\n同样地，在 Network 和 NetworkList 类型上，也有代码生成注释。\n\n其中，+genclient 的意思是：请为下面这个 API 资源类型生成对应的 Client 代码（这个 Client，我马上会讲到）。而 +genclient:noStatus 的意思是：这个 API 资源类型定义里，没有 Status 字段。否则，生成的 Client 就会自动带上 UpdateStatus 方法。\n\n如果你的类型定义包括了 Status 字段的话，就不需要这句 +genclient:noStatus 注释了。比如下面这个例子：\n\n```go\n\n// +genclient\n\n// Network is a specification for a Network resource\ntype Network struct {\n metav1.TypeMeta   `json:\",inline\"`\n metav1.ObjectMeta `json:\"metadata,omitempty\"`\n \n Spec   NetworkSpec   `json:\"spec\"`\n Status NetworkStatus `json:\"status\"`\n}\n```\n\n需要注意的是，+genclient 只需要写在 Network 类型上，而不用写在 NetworkList 上。因为 NetworkList 只是一个返回值类型，Network 才是“主类型”。\n\n而由于我在 Global Tags 里已经定义了为所有类型生成 DeepCopy 方法，所以这里就不需要再显式地加上 +k8s:deepcopy-gen=true 了。当然，这也就意味着你可以用 +k8s:deepcopy-gen=false 来阻止为某些类型生成 DeepCopy。\n\n你可能已经注意到，在这两个类型上面还有一句+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object的注释。它的意思是，请在生成 DeepCopy 的时候，实现 Kubernetes 提供的 runtime.Object 接口。否则，在某些版本的 Kubernetes 里，你的这个类型定义会出现编译错误。这是一个固定的操作，记住即可。\n\n不过，你或许会有这样的顾虑：这些代码生成注释这么灵活，我该怎么掌握呢？\n\n其实，上面我所讲述的内容，已经足以应对 99% 的场景了。当然，如果你对代码生成感兴趣的话，我推荐你阅读这篇博客，它详细地介绍了 Kubernetes 的代码生成语法。\n\n**最后，我需要再编写一个 pkg/apis/samplecrd/v1/register.go 文件。**\n\n在前面对 APIServer 工作原理的讲解中，我已经提到，“registry”的作用就是注册一个类型（Type）给 APIServer。其中，Network 资源类型在服务器端注册的工作，APIServer 会自动帮我们完成。但与之对应的，我们还需要让客户端也能“知道”Network 资源类型的定义。这就需要我们在项目里添加一个 register.go 文件。它最主要的功能，就是定义了如下所示的 addKnownTypes() 方法：\n\n```go\npackage v1\n...\n// addKnownTypes adds our types to the API scheme by registering\n// Network and NetworkList\nfunc addKnownTypes(scheme *runtime.Scheme) error {\n scheme.AddKnownTypes(\n  SchemeGroupVersion,\n  &Network{},\n  &NetworkList{},\n )\n \n // register the type in the scheme\n metav1.AddToGroupVersion(scheme, SchemeGroupVersion)\n return nil\n}\n```\n\n\n\n有了这个方法，Kubernetes 就能够在后面生成客户端的时候，“知道”Network 以及 NetworkList 类型的定义了。\n\n像上面这种 **register.go 文件里的内容其实是非常固定的，你以后可以直接使用我提供的这部分代码做模板，然后把其中的资源类型、GroupName 和 Version 替换成你自己的定义即可。**\n\n这样，Network 对象的定义工作就全部完成了。可以看到，它其实定义了两部分内容：\n\n* 第一部分是，自定义资源类型的 API 描述，包括：组（Group）、版本（Version）、资源类型（Resource）等。这相当于告诉了计算机：兔子是哺乳动物。\n* 第二部分是，自定义资源类型的对象描述，包括：Spec、Status 等。这相当于告诉了计算机：兔子有长耳朵和三瓣嘴。\n\n接下来，<font color=orange>我就要使用 Kubernetes 提供的代码生成工具，为上面定义的 Network 资源类型自动生成 clientset、informer 和 lister。</font>其中，clientset 就是操作 Network 对象所需要使用的客户端，而 informer 和 lister 这两个包的主要功能，我会在下一篇文章中重点讲解。\n\n这个代码生成工具名叫k8s.io/code-generator，使用方法如下所示：\n\n```bash\n\n# 代码生成的工作目录，也就是我们的项目路径\n$ ROOT_PACKAGE=\"github.com/gxstax/k8s-custom-controller\"\n# API Group\n$ CUSTOM_RESOURCE_NAME=\"samplecrd\"\n# API Version\n$ CUSTOM_RESOURCE_VERSION=\"v1\"\n\n# 安装k8s.io/code-generator\n$ go get -u k8s.io/code-generator/...\n$ cd $GOPATH/src/k8s.io/code-generator\n\n# 执行代码自动生成，其中pkg/client是生成目标目录，pkg/apis是类型定义目录\n$ ./generate-groups.sh all \"$ROOT_PACKAGE/pkg/client\" \"$ROOT_PACKAGE/pkg/apis\" \"$CUSTOM_RESOURCE_NAME:$CUSTOM_RESOURCE_VERSION\"\n```\n\n代码生成工作完成之后，我们再查看一下这个项目的目录结构：\n\n```\n$ tree\n.\n└── pkg\n    ├── apis\n    │   └── samplecrd\n    │       ├── register.go\n    │       └── v1\n    │           ├── doc.go\n    │           ├── register.go\n    │           └── types.go\n    └── client\n        └── clientset\n            └── versioned\n                ├── clientset.go\n                ├── doc.go\n                ├── fake\n                │   ├── clientset_generated.go\n                │   ├── doc.go\n                │   └── register.go\n                ├── scheme\n                │   ├── doc.go\n                │   └── register.go\n                └── typed\n                    └── samplecrd\n                        └── v1\n                            ├── doc.go\n                            ├── fake\n                            │   ├── doc.go\n                            │   └── fake_samplecrd_client.go\n                            ├── generated_expansion.go\n                            └── samplecrd_client.go\n```\n\n其中，pkg/apis/samplecrd/v1 下面的 zz_generated.deepcopy.go 文件，就是自动生成的 DeepCopy 代码文件。\n\n而整个 client 目录，以及下面的三个包（clientset、informers、 listers），都是 Kubernetes 为 Network 类型生成的客户端库，这些库会在后面编写自定义控制器的时候用到。\n\n可以看到，到目前为止的这些工作，其实并不要求你写多少代码，主要考验的是“复制、粘贴、替换”这样的“基本功”。\n\n而有了这些内容，现在你就可以<font color=orange>在 Kubernetes 集群里创建一个 Network 类型的 API 对象了。</font>我们不妨一起来试验下。\n\n**首先，** 使用 network.yaml 文件，在 Kubernetes 中创建 Network 对象的 CRD（Custom Resource Definition）：\n\n```bash\n$ kubectl apply -f crd/network.yaml\ncustomresourcedefinition.apiextensions.k8s.io/networks.samplecrd.x-k8s.io created\n```\n\n这个操作，就告诉了 Kubernetes，我现在要添加一个自定义的 API 对象。而这个对象的 API 信息，正是 network.yaml 里定义的内容。我们可以通过 kubectl get 命令，查看这个 CRD：\n\n```bash\n$ kubectl get crd\nNAME                                         CREATED AT\nnetworks.samplecrd.x-k8s.io                  2022-03-08T07:26:58Z\n```\n\n**然后，**我们就可以创建一个 Network 对象了，这里用到的是 example-network.yaml：\n\n```bash\n$ kubectl apply -f example/example-network.yaml\nnetwork.samplecrd.x-k8s.io/example-network created\n```\n\n通过这个操作，你就在 Kubernetes 集群里创建了一个 Network 对象。它的 API 资源路径是samplecrd.k8s.io/v1/networks。\n\n这时候，你就可以通过 kubectl get 命令，查看到新创建的 Network 对象：\n\n```bash\n$ kubectl get network\nNAME              AGE\nexample-network   101s\n```\n\n你还可以通过 kubectl describe 命令，看到这个 Network 对象的细节：\n\n```bash\n$ kubectl describe network example-network\nName:         example-network\nNamespace:    default\nLabels:       <none>\nAnnotations:  <none>\nAPI Version:  samplecrd.x-k8s.io/v1\nKind:         Network\nMetadata:\n  Creation Timestamp:  2022-03-08T07:27:22Z\n  Generation:          1\n  Managed Fields:\n    API Version:  samplecrd.x-k8s.io/v1\n    Fields Type:  FieldsV1\n    fieldsV1:\n      f:metadata:\n        f:annotations:\n          .:\n          f:kubectl.kubernetes.io/last-applied-configuration:\n      f:spec:\n        .:\n        f:cidr:\n        f:gateway:\n    Manager:         kubectl-client-side-apply\n    Operation:       Update\n    Time:            2022-03-08T07:27:22Z\n  Resource Version:  4582056\n  UID:               86a7188c-4dec-4479-9e72-36ac92b0af63\nSpec:\n  Cidr:     192.168.0.0/16\n  Gateway:  192.168.0.1\nEvents:     <none>\n```\n\n当然 ，你也可以编写更多的 YAML 文件来创建更多的 Network 对象，这和创建 Pod、Deployment 的操作，没有任何区别。\n\n","slug":"深入解析声明式API（一）：API对象的奥秘","published":1,"updated":"2022-03-08T07:35:50.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0htj09z0000lirbhnyg5eyy","content":"<h2 id=\"Kubernetes-声明式-API-的工作原理\"><a href=\"#Kubernetes-声明式-API-的工作原理\" class=\"headerlink\" title=\"Kubernetes 声明式 API 的工作原理\"></a>Kubernetes 声明式 API 的工作原理</h2><blockquote>\n<p>如何利用这套 API 机制，在 Kubernetes 里添加自定义的 API 对象。</p>\n</blockquote>\n<p>你可能一直就很好奇：当我把一个 YAML 文件提交给 Kubernetes 之后，它究竟是如何创建出一个 API 对象的呢？</p>\n<p>这得从声明式 API 的设计谈起了。</p>\n<p>在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。</p>\n<p>通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：</p>\n<p><img src=\"/Users/mayi/work/Ant/projects/blog/source/images/k8s/k8s-api-tree.png\" alt=\"image-20220308101716245\"></p>\n<p>在这幅图中，你可以很清楚地看到 <strong>Kubernetes 里 API 对象的组织方式，其实是层层递进的。</strong></p>\n<p>比如，现在我要声明要创建一个 CronJob 对象，那么我的 YAML 文件的开始部分会这么写：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">batch/v2alpha1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">CronJob</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个 YAML 文件中，“CronJob”就是这个 API 对象的资源类型（Resource），“batch”就是它的组（Group），v2alpha1 就是它的版本（Version）。</p>\n<p>当我们提交了这个 YAML 文件之后，Kubernetes 就会把这个 YAML 文件里描述的内容，转换成 Kubernetes 里的一个 CronJob 对象。</p>\n<p>那么，<font color=orange>Kubernetes 是如何对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项目里找到 CronJob 对象的定义呢？</font></p>\n<p><strong>首先，Kubernetes 会匹配 API 对象的组。</strong></p>\n<p>需要明确的是，对于 Kubernetes 里的核心 API 对象，比如：Pod、Node 等，是不需要 Group 的（即：它们的 Group 是“”）。所以，对于这些 API 对象来说，Kubernetes 会直接在 /api 这个层级进行下一步的匹配过程。</p>\n<p>而对于 CronJob 等非核心 API 对象来说，Kubernetes 就必须在 /apis 这个层级里查找它对应的 Group，进而根据“batch”这个 Group 的名字，找到 /apis/batch。</p>\n<p>不难发现，这些 API Group 的分类是以对象功能为依据的，比如 Job 和 CronJob 就都属于“batch” （离线业务）这个 Group。</p>\n<p><strong>然后，Kubernetes 会进一步匹配到 API 对象的版本号。</strong></p>\n<p>对于 CronJob 这个 API 对象来说，Kubernetes 在 batch 这个 Group 下，匹配到的版本号就是 v2alpha1。</p>\n<p>在 Kubernetes 中，同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。这样，比如在 CronJob 的开发过程中，对于会影响到用户的变更就可以通过升级新版本来处理，从而保证了向后兼容。</p>\n<p><strong>最后，Kubernetes 会匹配 API 对象的资源类型。</strong></p>\n<p>在前面匹配到正确的版本之后，Kubernetes 就知道，我要创建的原来是一个 /apis/batch/v2alpha1 下的 CronJob 对象。</p>\n<p>这时候，<font color=orange>APIServer 就可以继续创建这个 CronJob 对象了。</font>为了方便理解，我为你总结了一个如下所示流程图来阐述这个创建过程：</p>\n<p><img src=\"/Users/mayi/work/Ant/projects/blog/source/images/k8s/api-server-build.png\" alt=\"img\"></p>\n<p><strong>首先，</strong>当我们发起了创建 CronJob 的 POST 请求之后，我们编写的 YAML 的信息就被提交给了 APIServer。</p>\n<p>而 APIServer 的第一个功能，就是过滤这个请求，并完成一些前置性的工作，比如授权、超时处理、审计等。</p>\n<p><strong>然后，</strong>请求会进入 MUX 和 Routes 流程。如果你编写过 Web Server 的话就会知道，MUX 和 Routes 是 APIServer 完成 URL 和 Handler 绑定的场所。而 APIServer 的 Handler 要做的事情，就是按照我刚刚介绍的匹配过程，找到对应的 CronJob 类型定义。</p>\n<p><strong>接着，</strong>APIServer 最重要的职责就来了：根据这个 CronJob 类型定义，使用用户提交的 YAML 文件里的字段，创建一个 CronJob 对象。</p>\n<p>而在这个过程中，APIServer 会进行一个 Convert 工作，即：把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。这样用户提交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理了。</p>\n<p><strong>接下来，</strong>APIServer 会先后进行 Admission() 和 Validation() 操作。比如，我在上一篇文章中提到的 Admission Controller 和 Initializer，就都属于 Admission 的内容。</p>\n<p>而 Validation，则负责验证这个对象里的各个字段是否合法。这个被验证过的 API 对象，都保存在了 APIServer 里一个叫作 Registry 的数据结构中。也就是说，只要一个 API 对象的定义能在 Registry 里查到，它就是一个有效的 Kubernetes API 对象。</p>\n<p><strong>最后，</strong>APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 把它保存起来。</p>\n<p>由此可见，声明式 API 对于 Kubernetes 来说非常重要。所以，<strong>APIServer 这样一个在其他项目里“平淡无奇”的组件，却成了 Kubernetes 项目的重中之重。</strong>它不仅是 Google Borg 设计思想的集中体现，也是 Kubernetes 项目里唯一一个被 Google 公司和 RedHat 公司双重控制、其他势力根本无法参与其中的组件。</p>\n<p>此外，由于同时要兼顾性能、API 完备性、版本化、向后兼容等很多工程化指标，所以 Kubernetes 团队在 APIServer 项目里大量使用了 Go 语言的代码生成功能，来自动化诸如 Convert、DeepCopy 等与 API 资源相关的操作。这部分自动生成的代码，曾一度占到 Kubernetes 项目总代码的 20%~30%。</p>\n<p>这也是为何，在过去很长一段时间里，在这样一个极其“复杂”的 APIServer 中，添加一个 Kubernetes 风格的 API 资源类型，是一个非常困难的工作。</p>\n<p>不过，在 Kubernetes v1.7 之后，这个工作就变得轻松得多了。这，当然得益于一个全新的 API 插件机制：CRD。</p>\n<p>CRD 的全称是 Custom Resource Definition。顾名思义，它指的就是，允许用户在 Kubernetes 中添加一个跟 Pod、Node 类似的、新的 API 资源类型，即：自定义 API 资源。</p>\n<p>举个例子，<font color=orange>我现在要为 Kubernetes 添加一个名叫 Network 的 API 资源类型。</font></p>\n<p>它的作用是，一旦用户创建一个 Network 对象，那么 Kubernetes 就应该使用这个对象定义的网络参数，调用真实的网络插件，比如 Neutron 项目，为用户创建一个真正的“网络”。这样，将来用户创建的 Pod，就可以声明使用这个“网络”了。</p>\n<p>这个 Network 对象的 YAML 文件，名叫 example-network.yaml，它的内容如下所示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">samplecrd.x-k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Network</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">example-network</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">cidr:</span> <span class=\"string\">&quot;192.168.0.0/16&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">gateway:</span> <span class=\"string\">&quot;192.168.0.1&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看到，我想要描述“网络”的 API 资源类型是 Network；API 组是samplecrd.k8s.io；API 版本是 v1。</p>\n<p>那么，<font color=orange>Kubernetes 又该如何知道这个 API（samplecrd.k8s.io/v1/network）的存在呢？</font></p>\n<p>其实，上面的这个 YAML 文件，就是一个具体的“自定义 API 资源”实例，也叫 CR（Custom Resource）。而为了能够让 Kubernetes 认识这个 CR，你就需要让 Kubernetes 明白这个 CR 的宏观定义是什么，也就是 CRD（Custom Resource Definition）。</p>\n<p>这就好比，你想让计算机认识各种兔子的照片，就得先让计算机明白，兔子的普遍定义是什么。比如，兔子“是哺乳动物”“有长耳朵，三瓣嘴”。</p>\n<p>所以，接下来，我就先编写一个 CRD 的 YAML 文件，它的名字叫作 network.yaml，内容如下所示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apiextensions.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">CustomResourceDefinition</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"comment\"># name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">networks.samplecrd.x-k8s.io</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"comment\"># group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">group:</span> <span class=\"string\">samplecrd.x-k8s.io</span></span><br><span class=\"line\">  <span class=\"attr\">versions:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">v1</span></span><br><span class=\"line\">      <span class=\"comment\"># Each version can be enabled/disabled by Served flag.</span></span><br><span class=\"line\">      <span class=\"attr\">served:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"comment\"># One and only one version must be marked as the storage version.</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"attr\">schema:</span></span><br><span class=\"line\">        <span class=\"attr\">openAPIV3Schema:</span></span><br><span class=\"line\">          <span class=\"attr\">type:</span> <span class=\"string\">object</span></span><br><span class=\"line\">          <span class=\"attr\">properties:</span></span><br><span class=\"line\">            <span class=\"attr\">spec:</span></span><br><span class=\"line\">              <span class=\"attr\">type:</span> <span class=\"string\">object</span></span><br><span class=\"line\">              <span class=\"attr\">properties:</span></span><br><span class=\"line\">                <span class=\"attr\">cidr:</span></span><br><span class=\"line\">                  <span class=\"attr\">type:</span> <span class=\"string\">string</span></span><br><span class=\"line\">                <span class=\"attr\">gateway:</span></span><br><span class=\"line\">                  <span class=\"attr\">type:</span> <span class=\"string\">string</span></span><br><span class=\"line\">  <span class=\"comment\"># either Namespaced or Cluster</span></span><br><span class=\"line\">  <span class=\"attr\">scope:</span> <span class=\"string\">Namespaced</span></span><br><span class=\"line\">  <span class=\"attr\">names:</span></span><br><span class=\"line\">    <span class=\"comment\"># plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span></span><br><span class=\"line\">    <span class=\"attr\">plural:</span> <span class=\"string\">networks</span></span><br><span class=\"line\">    <span class=\"comment\"># singular name to be used as an alias on the CLI and for display</span></span><br><span class=\"line\">    <span class=\"attr\">singular:</span> <span class=\"string\">network</span></span><br><span class=\"line\">    <span class=\"comment\"># kind is normally the CamelCased singular type. Your resource manifests use this.</span></span><br><span class=\"line\">    <span class=\"attr\">kind:</span> <span class=\"string\">Network</span></span><br><span class=\"line\">    <span class=\"attr\">shortNames:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">nw</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个 CRD 中，我指定了“group: samplecrd.x-k8s.io” “version: v1”这样的 API 信息，也指定了这个 CR 的资源类型叫作 Network，复数（plural）是 networks。</p>\n<blockquote>\n<p><font color=red>**注意: **</font> 这里最新的1.23.0版本的k8s不能使用*.k8s.io后缀，最好替换为.x-k8s.io。</p>\n</blockquote>\n<p>然后，我还声明了它的 scope 是 Namespaced，即：我们定义的这个 Network 是一个属于 Namespace 的对象，类似于 Pod。</p>\n<p>这就是一个 Network API 资源类型的 API 部分的宏观定义了。这就等同于告诉了计算机：“兔子是哺乳动物”。所以这时候，Kubernetes 就能够认识和处理所有声明了 API 类型是“samplecrd.k8s.io/v1/network”的 YAML 文件了。</p>\n<p>接下来，我还需要让 Kubernetes“认识”这种 YAML 文件里描述的“网络”部分，比如“cidr”（网段），“gateway”（网关）这些字段的含义。这就相当于我要告诉计算机：“兔子有长耳朵和三瓣嘴”。</p>\n<p>这时候呢，我就需要稍微做些代码工作了。</p>\n<p><strong>首先，我要在 GOPATH 下，创建一个结构如下的项目：</strong></p>\n<blockquote>\n<p>备注：在这里，我并不要求你具有完备的 Go 语言知识体系，但我会假设你已经了解了 Golang 的一些基本知识（比如，知道什么是 GOPATH）。而如果你还不了解的话，可以在涉及到相关内容时，再去查阅一些相关资料。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ tree <span class=\"variable\">$GOPATH</span>/src/github.com/&lt;your-name&gt;/k8s-controller-custom-resource</span><br><span class=\"line\">.</span><br><span class=\"line\">├── controller.go</span><br><span class=\"line\">├── crd</span><br><span class=\"line\">│   └── network.yaml</span><br><span class=\"line\">├── example</span><br><span class=\"line\">│   └── example-network.yaml</span><br><span class=\"line\">├── main.go</span><br><span class=\"line\">└── pkg</span><br><span class=\"line\">    └── apis</span><br><span class=\"line\">        └── samplecrd</span><br><span class=\"line\">            ├── register.go</span><br><span class=\"line\">            └── v1</span><br><span class=\"line\">                ├── doc.go</span><br><span class=\"line\">                ├── register.go</span><br><span class=\"line\">                └── types.go</span><br></pre></td></tr></table></figure>\n\n<p>其中，pkg/apis/samplecrd 就是 API 组的名字，v1 是版本，而 v1 下面的 types.go 文件里，则定义了 Network 对象的完整描述。我已经把这个<a href=\"https://github.com/gxstax/k8s-custom-controller\" title=\"github地址\">项目上传到了 GitHub 上</a>，你可以随时参考。</p>\n<p><strong>然后，我在 pkg/apis/samplecrd 目录下创建了一个 register.go 文件，用来放置后面要用到的全局变量。</strong>这个文件的内容如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> samplecrd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\"> GroupName = <span class=\"string\">&quot;samplecrd.k8s.io&quot;</span></span><br><span class=\"line\"> Version   = <span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><strong>接着，我需要在 pkg/apis/samplecrd 目录下添加一个 doc.go 文件（Golang 的文档源文件）。</strong>这个文件里的内容如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// +k8s:deepcopy-gen=package</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +groupName=samplecrd.k8s.io</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> v1</span><br></pre></td></tr></table></figure>\n\n<p>在这个文件中，你会看到 +&lt; tag_name &gt;[=value]格式的注释，这就是 Kubernetes 进行代码生成要用的 Annotation 风格的注释。</p>\n<p>其中，+k8s:deepcopy-gen=package 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；而+groupName=samplecrd.k8s.io，则定义了这个包对应的 API 组的名字。</p>\n<p>可以看到，这些定义在 doc.go 文件的注释，起到的是全局的代码生成控制的作用，所以也被称为 Global Tags。</p>\n<p><strong>接下来，我需要添加 types.go 文件。</strong>顾名思义，它的作用就是定义一个 Network 类型到底有哪些字段（比如，spec 字段里的内容）。这个文件的主要内容如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> v1</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// +genclient</span></span><br><span class=\"line\"><span class=\"comment\">// +genclient:noStatus</span></span><br><span class=\"line\"><span class=\"comment\">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Network describes a Network resource</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Network <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// TypeMeta is the metadata for the resource, like kind and apiversion</span></span><br><span class=\"line\"> metav1.TypeMeta <span class=\"string\">`json:&quot;,inline&quot;`</span></span><br><span class=\"line\"> <span class=\"comment\">// ObjectMeta contains the metadata for the particular object, including</span></span><br><span class=\"line\"> <span class=\"comment\">// things like...</span></span><br><span class=\"line\"> <span class=\"comment\">//  - name</span></span><br><span class=\"line\"> <span class=\"comment\">//  - namespace</span></span><br><span class=\"line\"> <span class=\"comment\">//  - self link</span></span><br><span class=\"line\"> <span class=\"comment\">//  - labels</span></span><br><span class=\"line\"> <span class=\"comment\">//  - ... etc ...</span></span><br><span class=\"line\"> metav1.ObjectMeta <span class=\"string\">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Spec networkspec <span class=\"string\">`json:&quot;spec&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// networkspec is the spec for a Network resource</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> networkspec <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> Cidr    <span class=\"type\">string</span> <span class=\"string\">`json:&quot;cidr&quot;`</span></span><br><span class=\"line\"> Gateway <span class=\"type\">string</span> <span class=\"string\">`json:&quot;gateway&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NetworkList is a list of Network resources</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NetworkList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> metav1.TypeMeta <span class=\"string\">`json:&quot;,inline&quot;`</span></span><br><span class=\"line\"> metav1.ListMeta <span class=\"string\">`json:&quot;metadata&quot;`</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Items []Network <span class=\"string\">`json:&quot;items&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面这部分代码里，你可以看到 Network 类型定义方法跟标准的 Kubernetes 对象一样，都包括了 TypeMeta（API 元数据）和 ObjectMeta（对象元数据）字段。</p>\n<p>而其中的 Spec 字段，就是需要我们自己定义的部分。所以，在 networkspec 里，我定义了 Cidr 和 Gateway 两个字段。其中，每个字段最后面的部分比如json:”cidr”，指的就是这个字段被转换成 JSON 格式之后的名字，也就是 YAML 文件里的字段名字。</p>\n<blockquote>\n<p>如果你不熟悉这个用法的话，可以查阅一下 Golang 的文档。</p>\n</blockquote>\n<p>此外，除了定义 Network 类型，你还需要定义一个 NetworkList 类型，用来描述一组 Network 对象应该包括哪些字段。之所以需要这样一个类型，是因为在 Kubernetes 中，获取所有 X 对象的 List() 方法，返回值都是List 类型，而不是 X 类型的数组。这是不一样的。</p>\n<p>同样地，在 Network 和 NetworkList 类型上，也有代码生成注释。</p>\n<p>其中，+genclient 的意思是：请为下面这个 API 资源类型生成对应的 Client 代码（这个 Client，我马上会讲到）。而 +genclient:noStatus 的意思是：这个 API 资源类型定义里，没有 Status 字段。否则，生成的 Client 就会自动带上 UpdateStatus 方法。</p>\n<p>如果你的类型定义包括了 Status 字段的话，就不需要这句 +genclient:noStatus 注释了。比如下面这个例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +genclient</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Network is a specification for a Network resource</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Network <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> metav1.TypeMeta   <span class=\"string\">`json:&quot;,inline&quot;`</span></span><br><span class=\"line\"> metav1.ObjectMeta <span class=\"string\">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Spec   NetworkSpec   <span class=\"string\">`json:&quot;spec&quot;`</span></span><br><span class=\"line\"> Status NetworkStatus <span class=\"string\">`json:&quot;status&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，+genclient 只需要写在 Network 类型上，而不用写在 NetworkList 上。因为 NetworkList 只是一个返回值类型，Network 才是“主类型”。</p>\n<p>而由于我在 Global Tags 里已经定义了为所有类型生成 DeepCopy 方法，所以这里就不需要再显式地加上 +k8s:deepcopy-gen=true 了。当然，这也就意味着你可以用 +k8s:deepcopy-gen=false 来阻止为某些类型生成 DeepCopy。</p>\n<p>你可能已经注意到，在这两个类型上面还有一句+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object的注释。它的意思是，请在生成 DeepCopy 的时候，实现 Kubernetes 提供的 runtime.Object 接口。否则，在某些版本的 Kubernetes 里，你的这个类型定义会出现编译错误。这是一个固定的操作，记住即可。</p>\n<p>不过，你或许会有这样的顾虑：这些代码生成注释这么灵活，我该怎么掌握呢？</p>\n<p>其实，上面我所讲述的内容，已经足以应对 99% 的场景了。当然，如果你对代码生成感兴趣的话，我推荐你阅读这篇博客，它详细地介绍了 Kubernetes 的代码生成语法。</p>\n<p><strong>最后，我需要再编写一个 pkg/apis/samplecrd/v1/register.go 文件。</strong></p>\n<p>在前面对 APIServer 工作原理的讲解中，我已经提到，“registry”的作用就是注册一个类型（Type）给 APIServer。其中，Network 资源类型在服务器端注册的工作，APIServer 会自动帮我们完成。但与之对应的，我们还需要让客户端也能“知道”Network 资源类型的定义。这就需要我们在项目里添加一个 register.go 文件。它最主要的功能，就是定义了如下所示的 addKnownTypes() 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> v1</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// addKnownTypes adds our types to the API scheme by registering</span></span><br><span class=\"line\"><span class=\"comment\">// Network and NetworkList</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addKnownTypes</span><span class=\"params\">(scheme *runtime.Scheme)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"> scheme.AddKnownTypes(</span><br><span class=\"line\">  SchemeGroupVersion,</span><br><span class=\"line\">  &amp;Network&#123;&#125;,</span><br><span class=\"line\">  &amp;NetworkList&#123;&#125;,</span><br><span class=\"line\"> )</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// register the type in the scheme</span></span><br><span class=\"line\"> metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>有了这个方法，Kubernetes 就能够在后面生成客户端的时候，“知道”Network 以及 NetworkList 类型的定义了。</p>\n<p>像上面这种 <strong>register.go 文件里的内容其实是非常固定的，你以后可以直接使用我提供的这部分代码做模板，然后把其中的资源类型、GroupName 和 Version 替换成你自己的定义即可。</strong></p>\n<p>这样，Network 对象的定义工作就全部完成了。可以看到，它其实定义了两部分内容：</p>\n<ul>\n<li>第一部分是，自定义资源类型的 API 描述，包括：组（Group）、版本（Version）、资源类型（Resource）等。这相当于告诉了计算机：兔子是哺乳动物。</li>\n<li>第二部分是，自定义资源类型的对象描述，包括：Spec、Status 等。这相当于告诉了计算机：兔子有长耳朵和三瓣嘴。</li>\n</ul>\n<p>接下来，<font color=orange>我就要使用 Kubernetes 提供的代码生成工具，为上面定义的 Network 资源类型自动生成 clientset、informer 和 lister。</font>其中，clientset 就是操作 Network 对象所需要使用的客户端，而 informer 和 lister 这两个包的主要功能，我会在下一篇文章中重点讲解。</p>\n<p>这个代码生成工具名叫k8s.io/code-generator，使用方法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 代码生成的工作目录，也就是我们的项目路径</span></span><br><span class=\"line\">$ ROOT_PACKAGE=<span class=\"string\">&quot;github.com/gxstax/k8s-custom-controller&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># API Group</span></span><br><span class=\"line\">$ CUSTOM_RESOURCE_NAME=<span class=\"string\">&quot;samplecrd&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># API Version</span></span><br><span class=\"line\">$ CUSTOM_RESOURCE_VERSION=<span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装k8s.io/code-generator</span></span><br><span class=\"line\">$ go get -u k8s.io/code-generator/...</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"variable\">$GOPATH</span>/src/k8s.io/code-generator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行代码自动生成，其中pkg/client是生成目标目录，pkg/apis是类型定义目录</span></span><br><span class=\"line\">$ ./generate-groups.sh all <span class=\"string\">&quot;<span class=\"variable\">$ROOT_PACKAGE</span>/pkg/client&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$ROOT_PACKAGE</span>/pkg/apis&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$CUSTOM_RESOURCE_NAME</span>:<span class=\"variable\">$CUSTOM_RESOURCE_VERSION</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>代码生成工作完成之后，我们再查看一下这个项目的目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree</span><br><span class=\"line\">.</span><br><span class=\"line\">└── pkg</span><br><span class=\"line\">    ├── apis</span><br><span class=\"line\">    │   └── samplecrd</span><br><span class=\"line\">    │       ├── register.go</span><br><span class=\"line\">    │       └── v1</span><br><span class=\"line\">    │           ├── doc.go</span><br><span class=\"line\">    │           ├── register.go</span><br><span class=\"line\">    │           └── types.go</span><br><span class=\"line\">    └── client</span><br><span class=\"line\">        └── clientset</span><br><span class=\"line\">            └── versioned</span><br><span class=\"line\">                ├── clientset.go</span><br><span class=\"line\">                ├── doc.go</span><br><span class=\"line\">                ├── fake</span><br><span class=\"line\">                │   ├── clientset_generated.go</span><br><span class=\"line\">                │   ├── doc.go</span><br><span class=\"line\">                │   └── register.go</span><br><span class=\"line\">                ├── scheme</span><br><span class=\"line\">                │   ├── doc.go</span><br><span class=\"line\">                │   └── register.go</span><br><span class=\"line\">                └── typed</span><br><span class=\"line\">                    └── samplecrd</span><br><span class=\"line\">                        └── v1</span><br><span class=\"line\">                            ├── doc.go</span><br><span class=\"line\">                            ├── fake</span><br><span class=\"line\">                            │   ├── doc.go</span><br><span class=\"line\">                            │   └── fake_samplecrd_client.go</span><br><span class=\"line\">                            ├── generated_expansion.go</span><br><span class=\"line\">                            └── samplecrd_client.go</span><br></pre></td></tr></table></figure>\n\n<p>其中，pkg/apis/samplecrd/v1 下面的 zz_generated.deepcopy.go 文件，就是自动生成的 DeepCopy 代码文件。</p>\n<p>而整个 client 目录，以及下面的三个包（clientset、informers、 listers），都是 Kubernetes 为 Network 类型生成的客户端库，这些库会在后面编写自定义控制器的时候用到。</p>\n<p>可以看到，到目前为止的这些工作，其实并不要求你写多少代码，主要考验的是“复制、粘贴、替换”这样的“基本功”。</p>\n<p>而有了这些内容，现在你就可以<font color=orange>在 Kubernetes 集群里创建一个 Network 类型的 API 对象了。</font>我们不妨一起来试验下。</p>\n<p><strong>首先，</strong> 使用 network.yaml 文件，在 Kubernetes 中创建 Network 对象的 CRD（Custom Resource Definition）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f crd/network.yaml</span><br><span class=\"line\">customresourcedefinition.apiextensions.k8s.io/networks.samplecrd.x-k8s.io created</span><br></pre></td></tr></table></figure>\n\n<p>这个操作，就告诉了 Kubernetes，我现在要添加一个自定义的 API 对象。而这个对象的 API 信息，正是 network.yaml 里定义的内容。我们可以通过 kubectl get 命令，查看这个 CRD：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get crd</span><br><span class=\"line\">NAME                                         CREATED AT</span><br><span class=\"line\">networks.samplecrd.x-k8s.io                  2022-03-08T07:26:58Z</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后，</strong>我们就可以创建一个 Network 对象了，这里用到的是 example-network.yaml：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f example/example-network.yaml</span><br><span class=\"line\">network.samplecrd.x-k8s.io/example-network created</span><br></pre></td></tr></table></figure>\n\n<p>通过这个操作，你就在 Kubernetes 集群里创建了一个 Network 对象。它的 API 资源路径是samplecrd.k8s.io/v1/networks。</p>\n<p>这时候，你就可以通过 kubectl get 命令，查看到新创建的 Network 对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get network</span><br><span class=\"line\">NAME              AGE</span><br><span class=\"line\">example-network   101s</span><br></pre></td></tr></table></figure>\n\n<p>你还可以通过 kubectl describe 命令，看到这个 Network 对象的细节：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe network example-network</span><br><span class=\"line\">Name:         example-network</span><br><span class=\"line\">Namespace:    default</span><br><span class=\"line\">Labels:       &lt;none&gt;</span><br><span class=\"line\">Annotations:  &lt;none&gt;</span><br><span class=\"line\">API Version:  samplecrd.x-k8s.io/v1</span><br><span class=\"line\">Kind:         Network</span><br><span class=\"line\">Metadata:</span><br><span class=\"line\">  Creation Timestamp:  2022-03-08T07:27:22Z</span><br><span class=\"line\">  Generation:          1</span><br><span class=\"line\">  Managed Fields:</span><br><span class=\"line\">    API Version:  samplecrd.x-k8s.io/v1</span><br><span class=\"line\">    Fields Type:  FieldsV1</span><br><span class=\"line\">    fieldsV1:</span><br><span class=\"line\">      f:metadata:</span><br><span class=\"line\">        f:annotations:</span><br><span class=\"line\">          .:</span><br><span class=\"line\">          f:kubectl.kubernetes.io/last-applied-configuration:</span><br><span class=\"line\">      f:spec:</span><br><span class=\"line\">        .:</span><br><span class=\"line\">        f:cidr:</span><br><span class=\"line\">        f:gateway:</span><br><span class=\"line\">    Manager:         kubectl-client-side-apply</span><br><span class=\"line\">    Operation:       Update</span><br><span class=\"line\">    Time:            2022-03-08T07:27:22Z</span><br><span class=\"line\">  Resource Version:  4582056</span><br><span class=\"line\">  UID:               86a7188c-4dec-4479-9e72-36ac92b0af63</span><br><span class=\"line\">Spec:</span><br><span class=\"line\">  Cidr:     192.168.0.0/16</span><br><span class=\"line\">  Gateway:  192.168.0.1</span><br><span class=\"line\">Events:     &lt;none&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当然 ，你也可以编写更多的 YAML 文件来创建更多的 Network 对象，这和创建 Pod、Deployment 的操作，没有任何区别。</p>\n","site":{"data":{"links":{"马以":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"马以的网站"},"Ant":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"Ant"}}}},"excerpt":"","more":"<h2 id=\"Kubernetes-声明式-API-的工作原理\"><a href=\"#Kubernetes-声明式-API-的工作原理\" class=\"headerlink\" title=\"Kubernetes 声明式 API 的工作原理\"></a>Kubernetes 声明式 API 的工作原理</h2><blockquote>\n<p>如何利用这套 API 机制，在 Kubernetes 里添加自定义的 API 对象。</p>\n</blockquote>\n<p>你可能一直就很好奇：当我把一个 YAML 文件提交给 Kubernetes 之后，它究竟是如何创建出一个 API 对象的呢？</p>\n<p>这得从声明式 API 的设计谈起了。</p>\n<p>在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。</p>\n<p>通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：</p>\n<p><img src=\"/Users/mayi/work/Ant/projects/blog/source/images/k8s/k8s-api-tree.png\" alt=\"image-20220308101716245\"></p>\n<p>在这幅图中，你可以很清楚地看到 <strong>Kubernetes 里 API 对象的组织方式，其实是层层递进的。</strong></p>\n<p>比如，现在我要声明要创建一个 CronJob 对象，那么我的 YAML 文件的开始部分会这么写：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">batch/v2alpha1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">CronJob</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个 YAML 文件中，“CronJob”就是这个 API 对象的资源类型（Resource），“batch”就是它的组（Group），v2alpha1 就是它的版本（Version）。</p>\n<p>当我们提交了这个 YAML 文件之后，Kubernetes 就会把这个 YAML 文件里描述的内容，转换成 Kubernetes 里的一个 CronJob 对象。</p>\n<p>那么，<font color=orange>Kubernetes 是如何对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项目里找到 CronJob 对象的定义呢？</font></p>\n<p><strong>首先，Kubernetes 会匹配 API 对象的组。</strong></p>\n<p>需要明确的是，对于 Kubernetes 里的核心 API 对象，比如：Pod、Node 等，是不需要 Group 的（即：它们的 Group 是“”）。所以，对于这些 API 对象来说，Kubernetes 会直接在 /api 这个层级进行下一步的匹配过程。</p>\n<p>而对于 CronJob 等非核心 API 对象来说，Kubernetes 就必须在 /apis 这个层级里查找它对应的 Group，进而根据“batch”这个 Group 的名字，找到 /apis/batch。</p>\n<p>不难发现，这些 API Group 的分类是以对象功能为依据的，比如 Job 和 CronJob 就都属于“batch” （离线业务）这个 Group。</p>\n<p><strong>然后，Kubernetes 会进一步匹配到 API 对象的版本号。</strong></p>\n<p>对于 CronJob 这个 API 对象来说，Kubernetes 在 batch 这个 Group 下，匹配到的版本号就是 v2alpha1。</p>\n<p>在 Kubernetes 中，同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。这样，比如在 CronJob 的开发过程中，对于会影响到用户的变更就可以通过升级新版本来处理，从而保证了向后兼容。</p>\n<p><strong>最后，Kubernetes 会匹配 API 对象的资源类型。</strong></p>\n<p>在前面匹配到正确的版本之后，Kubernetes 就知道，我要创建的原来是一个 /apis/batch/v2alpha1 下的 CronJob 对象。</p>\n<p>这时候，<font color=orange>APIServer 就可以继续创建这个 CronJob 对象了。</font>为了方便理解，我为你总结了一个如下所示流程图来阐述这个创建过程：</p>\n<p><img src=\"/Users/mayi/work/Ant/projects/blog/source/images/k8s/api-server-build.png\" alt=\"img\"></p>\n<p><strong>首先，</strong>当我们发起了创建 CronJob 的 POST 请求之后，我们编写的 YAML 的信息就被提交给了 APIServer。</p>\n<p>而 APIServer 的第一个功能，就是过滤这个请求，并完成一些前置性的工作，比如授权、超时处理、审计等。</p>\n<p><strong>然后，</strong>请求会进入 MUX 和 Routes 流程。如果你编写过 Web Server 的话就会知道，MUX 和 Routes 是 APIServer 完成 URL 和 Handler 绑定的场所。而 APIServer 的 Handler 要做的事情，就是按照我刚刚介绍的匹配过程，找到对应的 CronJob 类型定义。</p>\n<p><strong>接着，</strong>APIServer 最重要的职责就来了：根据这个 CronJob 类型定义，使用用户提交的 YAML 文件里的字段，创建一个 CronJob 对象。</p>\n<p>而在这个过程中，APIServer 会进行一个 Convert 工作，即：把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。这样用户提交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理了。</p>\n<p><strong>接下来，</strong>APIServer 会先后进行 Admission() 和 Validation() 操作。比如，我在上一篇文章中提到的 Admission Controller 和 Initializer，就都属于 Admission 的内容。</p>\n<p>而 Validation，则负责验证这个对象里的各个字段是否合法。这个被验证过的 API 对象，都保存在了 APIServer 里一个叫作 Registry 的数据结构中。也就是说，只要一个 API 对象的定义能在 Registry 里查到，它就是一个有效的 Kubernetes API 对象。</p>\n<p><strong>最后，</strong>APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 把它保存起来。</p>\n<p>由此可见，声明式 API 对于 Kubernetes 来说非常重要。所以，<strong>APIServer 这样一个在其他项目里“平淡无奇”的组件，却成了 Kubernetes 项目的重中之重。</strong>它不仅是 Google Borg 设计思想的集中体现，也是 Kubernetes 项目里唯一一个被 Google 公司和 RedHat 公司双重控制、其他势力根本无法参与其中的组件。</p>\n<p>此外，由于同时要兼顾性能、API 完备性、版本化、向后兼容等很多工程化指标，所以 Kubernetes 团队在 APIServer 项目里大量使用了 Go 语言的代码生成功能，来自动化诸如 Convert、DeepCopy 等与 API 资源相关的操作。这部分自动生成的代码，曾一度占到 Kubernetes 项目总代码的 20%~30%。</p>\n<p>这也是为何，在过去很长一段时间里，在这样一个极其“复杂”的 APIServer 中，添加一个 Kubernetes 风格的 API 资源类型，是一个非常困难的工作。</p>\n<p>不过，在 Kubernetes v1.7 之后，这个工作就变得轻松得多了。这，当然得益于一个全新的 API 插件机制：CRD。</p>\n<p>CRD 的全称是 Custom Resource Definition。顾名思义，它指的就是，允许用户在 Kubernetes 中添加一个跟 Pod、Node 类似的、新的 API 资源类型，即：自定义 API 资源。</p>\n<p>举个例子，<font color=orange>我现在要为 Kubernetes 添加一个名叫 Network 的 API 资源类型。</font></p>\n<p>它的作用是，一旦用户创建一个 Network 对象，那么 Kubernetes 就应该使用这个对象定义的网络参数，调用真实的网络插件，比如 Neutron 项目，为用户创建一个真正的“网络”。这样，将来用户创建的 Pod，就可以声明使用这个“网络”了。</p>\n<p>这个 Network 对象的 YAML 文件，名叫 example-network.yaml，它的内容如下所示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">samplecrd.x-k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Network</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">example-network</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">cidr:</span> <span class=\"string\">&quot;192.168.0.0/16&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">gateway:</span> <span class=\"string\">&quot;192.168.0.1&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看到，我想要描述“网络”的 API 资源类型是 Network；API 组是samplecrd.k8s.io；API 版本是 v1。</p>\n<p>那么，<font color=orange>Kubernetes 又该如何知道这个 API（samplecrd.k8s.io/v1/network）的存在呢？</font></p>\n<p>其实，上面的这个 YAML 文件，就是一个具体的“自定义 API 资源”实例，也叫 CR（Custom Resource）。而为了能够让 Kubernetes 认识这个 CR，你就需要让 Kubernetes 明白这个 CR 的宏观定义是什么，也就是 CRD（Custom Resource Definition）。</p>\n<p>这就好比，你想让计算机认识各种兔子的照片，就得先让计算机明白，兔子的普遍定义是什么。比如，兔子“是哺乳动物”“有长耳朵，三瓣嘴”。</p>\n<p>所以，接下来，我就先编写一个 CRD 的 YAML 文件，它的名字叫作 network.yaml，内容如下所示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apiextensions.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">CustomResourceDefinition</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"comment\"># name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">networks.samplecrd.x-k8s.io</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"comment\"># group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">group:</span> <span class=\"string\">samplecrd.x-k8s.io</span></span><br><span class=\"line\">  <span class=\"attr\">versions:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">v1</span></span><br><span class=\"line\">      <span class=\"comment\"># Each version can be enabled/disabled by Served flag.</span></span><br><span class=\"line\">      <span class=\"attr\">served:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"comment\"># One and only one version must be marked as the storage version.</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"attr\">schema:</span></span><br><span class=\"line\">        <span class=\"attr\">openAPIV3Schema:</span></span><br><span class=\"line\">          <span class=\"attr\">type:</span> <span class=\"string\">object</span></span><br><span class=\"line\">          <span class=\"attr\">properties:</span></span><br><span class=\"line\">            <span class=\"attr\">spec:</span></span><br><span class=\"line\">              <span class=\"attr\">type:</span> <span class=\"string\">object</span></span><br><span class=\"line\">              <span class=\"attr\">properties:</span></span><br><span class=\"line\">                <span class=\"attr\">cidr:</span></span><br><span class=\"line\">                  <span class=\"attr\">type:</span> <span class=\"string\">string</span></span><br><span class=\"line\">                <span class=\"attr\">gateway:</span></span><br><span class=\"line\">                  <span class=\"attr\">type:</span> <span class=\"string\">string</span></span><br><span class=\"line\">  <span class=\"comment\"># either Namespaced or Cluster</span></span><br><span class=\"line\">  <span class=\"attr\">scope:</span> <span class=\"string\">Namespaced</span></span><br><span class=\"line\">  <span class=\"attr\">names:</span></span><br><span class=\"line\">    <span class=\"comment\"># plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span></span><br><span class=\"line\">    <span class=\"attr\">plural:</span> <span class=\"string\">networks</span></span><br><span class=\"line\">    <span class=\"comment\"># singular name to be used as an alias on the CLI and for display</span></span><br><span class=\"line\">    <span class=\"attr\">singular:</span> <span class=\"string\">network</span></span><br><span class=\"line\">    <span class=\"comment\"># kind is normally the CamelCased singular type. Your resource manifests use this.</span></span><br><span class=\"line\">    <span class=\"attr\">kind:</span> <span class=\"string\">Network</span></span><br><span class=\"line\">    <span class=\"attr\">shortNames:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">nw</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个 CRD 中，我指定了“group: samplecrd.x-k8s.io” “version: v1”这样的 API 信息，也指定了这个 CR 的资源类型叫作 Network，复数（plural）是 networks。</p>\n<blockquote>\n<p><font color=red>**注意: **</font> 这里最新的1.23.0版本的k8s不能使用*.k8s.io后缀，最好替换为.x-k8s.io。</p>\n</blockquote>\n<p>然后，我还声明了它的 scope 是 Namespaced，即：我们定义的这个 Network 是一个属于 Namespace 的对象，类似于 Pod。</p>\n<p>这就是一个 Network API 资源类型的 API 部分的宏观定义了。这就等同于告诉了计算机：“兔子是哺乳动物”。所以这时候，Kubernetes 就能够认识和处理所有声明了 API 类型是“samplecrd.k8s.io/v1/network”的 YAML 文件了。</p>\n<p>接下来，我还需要让 Kubernetes“认识”这种 YAML 文件里描述的“网络”部分，比如“cidr”（网段），“gateway”（网关）这些字段的含义。这就相当于我要告诉计算机：“兔子有长耳朵和三瓣嘴”。</p>\n<p>这时候呢，我就需要稍微做些代码工作了。</p>\n<p><strong>首先，我要在 GOPATH 下，创建一个结构如下的项目：</strong></p>\n<blockquote>\n<p>备注：在这里，我并不要求你具有完备的 Go 语言知识体系，但我会假设你已经了解了 Golang 的一些基本知识（比如，知道什么是 GOPATH）。而如果你还不了解的话，可以在涉及到相关内容时，再去查阅一些相关资料。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ tree <span class=\"variable\">$GOPATH</span>/src/github.com/&lt;your-name&gt;/k8s-controller-custom-resource</span><br><span class=\"line\">.</span><br><span class=\"line\">├── controller.go</span><br><span class=\"line\">├── crd</span><br><span class=\"line\">│   └── network.yaml</span><br><span class=\"line\">├── example</span><br><span class=\"line\">│   └── example-network.yaml</span><br><span class=\"line\">├── main.go</span><br><span class=\"line\">└── pkg</span><br><span class=\"line\">    └── apis</span><br><span class=\"line\">        └── samplecrd</span><br><span class=\"line\">            ├── register.go</span><br><span class=\"line\">            └── v1</span><br><span class=\"line\">                ├── doc.go</span><br><span class=\"line\">                ├── register.go</span><br><span class=\"line\">                └── types.go</span><br></pre></td></tr></table></figure>\n\n<p>其中，pkg/apis/samplecrd 就是 API 组的名字，v1 是版本，而 v1 下面的 types.go 文件里，则定义了 Network 对象的完整描述。我已经把这个<a href=\"https://github.com/gxstax/k8s-custom-controller\" title=\"github地址\">项目上传到了 GitHub 上</a>，你可以随时参考。</p>\n<p><strong>然后，我在 pkg/apis/samplecrd 目录下创建了一个 register.go 文件，用来放置后面要用到的全局变量。</strong>这个文件的内容如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> samplecrd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\"> GroupName = <span class=\"string\">&quot;samplecrd.k8s.io&quot;</span></span><br><span class=\"line\"> Version   = <span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><strong>接着，我需要在 pkg/apis/samplecrd 目录下添加一个 doc.go 文件（Golang 的文档源文件）。</strong>这个文件里的内容如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// +k8s:deepcopy-gen=package</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +groupName=samplecrd.k8s.io</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> v1</span><br></pre></td></tr></table></figure>\n\n<p>在这个文件中，你会看到 +&lt; tag_name &gt;[=value]格式的注释，这就是 Kubernetes 进行代码生成要用的 Annotation 风格的注释。</p>\n<p>其中，+k8s:deepcopy-gen=package 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；而+groupName=samplecrd.k8s.io，则定义了这个包对应的 API 组的名字。</p>\n<p>可以看到，这些定义在 doc.go 文件的注释，起到的是全局的代码生成控制的作用，所以也被称为 Global Tags。</p>\n<p><strong>接下来，我需要添加 types.go 文件。</strong>顾名思义，它的作用就是定义一个 Network 类型到底有哪些字段（比如，spec 字段里的内容）。这个文件的主要内容如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> v1</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// +genclient</span></span><br><span class=\"line\"><span class=\"comment\">// +genclient:noStatus</span></span><br><span class=\"line\"><span class=\"comment\">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Network describes a Network resource</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Network <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// TypeMeta is the metadata for the resource, like kind and apiversion</span></span><br><span class=\"line\"> metav1.TypeMeta <span class=\"string\">`json:&quot;,inline&quot;`</span></span><br><span class=\"line\"> <span class=\"comment\">// ObjectMeta contains the metadata for the particular object, including</span></span><br><span class=\"line\"> <span class=\"comment\">// things like...</span></span><br><span class=\"line\"> <span class=\"comment\">//  - name</span></span><br><span class=\"line\"> <span class=\"comment\">//  - namespace</span></span><br><span class=\"line\"> <span class=\"comment\">//  - self link</span></span><br><span class=\"line\"> <span class=\"comment\">//  - labels</span></span><br><span class=\"line\"> <span class=\"comment\">//  - ... etc ...</span></span><br><span class=\"line\"> metav1.ObjectMeta <span class=\"string\">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Spec networkspec <span class=\"string\">`json:&quot;spec&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// networkspec is the spec for a Network resource</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> networkspec <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> Cidr    <span class=\"type\">string</span> <span class=\"string\">`json:&quot;cidr&quot;`</span></span><br><span class=\"line\"> Gateway <span class=\"type\">string</span> <span class=\"string\">`json:&quot;gateway&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NetworkList is a list of Network resources</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NetworkList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> metav1.TypeMeta <span class=\"string\">`json:&quot;,inline&quot;`</span></span><br><span class=\"line\"> metav1.ListMeta <span class=\"string\">`json:&quot;metadata&quot;`</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Items []Network <span class=\"string\">`json:&quot;items&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面这部分代码里，你可以看到 Network 类型定义方法跟标准的 Kubernetes 对象一样，都包括了 TypeMeta（API 元数据）和 ObjectMeta（对象元数据）字段。</p>\n<p>而其中的 Spec 字段，就是需要我们自己定义的部分。所以，在 networkspec 里，我定义了 Cidr 和 Gateway 两个字段。其中，每个字段最后面的部分比如json:”cidr”，指的就是这个字段被转换成 JSON 格式之后的名字，也就是 YAML 文件里的字段名字。</p>\n<blockquote>\n<p>如果你不熟悉这个用法的话，可以查阅一下 Golang 的文档。</p>\n</blockquote>\n<p>此外，除了定义 Network 类型，你还需要定义一个 NetworkList 类型，用来描述一组 Network 对象应该包括哪些字段。之所以需要这样一个类型，是因为在 Kubernetes 中，获取所有 X 对象的 List() 方法，返回值都是List 类型，而不是 X 类型的数组。这是不一样的。</p>\n<p>同样地，在 Network 和 NetworkList 类型上，也有代码生成注释。</p>\n<p>其中，+genclient 的意思是：请为下面这个 API 资源类型生成对应的 Client 代码（这个 Client，我马上会讲到）。而 +genclient:noStatus 的意思是：这个 API 资源类型定义里，没有 Status 字段。否则，生成的 Client 就会自动带上 UpdateStatus 方法。</p>\n<p>如果你的类型定义包括了 Status 字段的话，就不需要这句 +genclient:noStatus 注释了。比如下面这个例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +genclient</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Network is a specification for a Network resource</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Network <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> metav1.TypeMeta   <span class=\"string\">`json:&quot;,inline&quot;`</span></span><br><span class=\"line\"> metav1.ObjectMeta <span class=\"string\">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Spec   NetworkSpec   <span class=\"string\">`json:&quot;spec&quot;`</span></span><br><span class=\"line\"> Status NetworkStatus <span class=\"string\">`json:&quot;status&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，+genclient 只需要写在 Network 类型上，而不用写在 NetworkList 上。因为 NetworkList 只是一个返回值类型，Network 才是“主类型”。</p>\n<p>而由于我在 Global Tags 里已经定义了为所有类型生成 DeepCopy 方法，所以这里就不需要再显式地加上 +k8s:deepcopy-gen=true 了。当然，这也就意味着你可以用 +k8s:deepcopy-gen=false 来阻止为某些类型生成 DeepCopy。</p>\n<p>你可能已经注意到，在这两个类型上面还有一句+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object的注释。它的意思是，请在生成 DeepCopy 的时候，实现 Kubernetes 提供的 runtime.Object 接口。否则，在某些版本的 Kubernetes 里，你的这个类型定义会出现编译错误。这是一个固定的操作，记住即可。</p>\n<p>不过，你或许会有这样的顾虑：这些代码生成注释这么灵活，我该怎么掌握呢？</p>\n<p>其实，上面我所讲述的内容，已经足以应对 99% 的场景了。当然，如果你对代码生成感兴趣的话，我推荐你阅读这篇博客，它详细地介绍了 Kubernetes 的代码生成语法。</p>\n<p><strong>最后，我需要再编写一个 pkg/apis/samplecrd/v1/register.go 文件。</strong></p>\n<p>在前面对 APIServer 工作原理的讲解中，我已经提到，“registry”的作用就是注册一个类型（Type）给 APIServer。其中，Network 资源类型在服务器端注册的工作，APIServer 会自动帮我们完成。但与之对应的，我们还需要让客户端也能“知道”Network 资源类型的定义。这就需要我们在项目里添加一个 register.go 文件。它最主要的功能，就是定义了如下所示的 addKnownTypes() 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> v1</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// addKnownTypes adds our types to the API scheme by registering</span></span><br><span class=\"line\"><span class=\"comment\">// Network and NetworkList</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addKnownTypes</span><span class=\"params\">(scheme *runtime.Scheme)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"> scheme.AddKnownTypes(</span><br><span class=\"line\">  SchemeGroupVersion,</span><br><span class=\"line\">  &amp;Network&#123;&#125;,</span><br><span class=\"line\">  &amp;NetworkList&#123;&#125;,</span><br><span class=\"line\"> )</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// register the type in the scheme</span></span><br><span class=\"line\"> metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>有了这个方法，Kubernetes 就能够在后面生成客户端的时候，“知道”Network 以及 NetworkList 类型的定义了。</p>\n<p>像上面这种 <strong>register.go 文件里的内容其实是非常固定的，你以后可以直接使用我提供的这部分代码做模板，然后把其中的资源类型、GroupName 和 Version 替换成你自己的定义即可。</strong></p>\n<p>这样，Network 对象的定义工作就全部完成了。可以看到，它其实定义了两部分内容：</p>\n<ul>\n<li>第一部分是，自定义资源类型的 API 描述，包括：组（Group）、版本（Version）、资源类型（Resource）等。这相当于告诉了计算机：兔子是哺乳动物。</li>\n<li>第二部分是，自定义资源类型的对象描述，包括：Spec、Status 等。这相当于告诉了计算机：兔子有长耳朵和三瓣嘴。</li>\n</ul>\n<p>接下来，<font color=orange>我就要使用 Kubernetes 提供的代码生成工具，为上面定义的 Network 资源类型自动生成 clientset、informer 和 lister。</font>其中，clientset 就是操作 Network 对象所需要使用的客户端，而 informer 和 lister 这两个包的主要功能，我会在下一篇文章中重点讲解。</p>\n<p>这个代码生成工具名叫k8s.io/code-generator，使用方法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 代码生成的工作目录，也就是我们的项目路径</span></span><br><span class=\"line\">$ ROOT_PACKAGE=<span class=\"string\">&quot;github.com/gxstax/k8s-custom-controller&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># API Group</span></span><br><span class=\"line\">$ CUSTOM_RESOURCE_NAME=<span class=\"string\">&quot;samplecrd&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># API Version</span></span><br><span class=\"line\">$ CUSTOM_RESOURCE_VERSION=<span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装k8s.io/code-generator</span></span><br><span class=\"line\">$ go get -u k8s.io/code-generator/...</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"variable\">$GOPATH</span>/src/k8s.io/code-generator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行代码自动生成，其中pkg/client是生成目标目录，pkg/apis是类型定义目录</span></span><br><span class=\"line\">$ ./generate-groups.sh all <span class=\"string\">&quot;<span class=\"variable\">$ROOT_PACKAGE</span>/pkg/client&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$ROOT_PACKAGE</span>/pkg/apis&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$CUSTOM_RESOURCE_NAME</span>:<span class=\"variable\">$CUSTOM_RESOURCE_VERSION</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>代码生成工作完成之后，我们再查看一下这个项目的目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree</span><br><span class=\"line\">.</span><br><span class=\"line\">└── pkg</span><br><span class=\"line\">    ├── apis</span><br><span class=\"line\">    │   └── samplecrd</span><br><span class=\"line\">    │       ├── register.go</span><br><span class=\"line\">    │       └── v1</span><br><span class=\"line\">    │           ├── doc.go</span><br><span class=\"line\">    │           ├── register.go</span><br><span class=\"line\">    │           └── types.go</span><br><span class=\"line\">    └── client</span><br><span class=\"line\">        └── clientset</span><br><span class=\"line\">            └── versioned</span><br><span class=\"line\">                ├── clientset.go</span><br><span class=\"line\">                ├── doc.go</span><br><span class=\"line\">                ├── fake</span><br><span class=\"line\">                │   ├── clientset_generated.go</span><br><span class=\"line\">                │   ├── doc.go</span><br><span class=\"line\">                │   └── register.go</span><br><span class=\"line\">                ├── scheme</span><br><span class=\"line\">                │   ├── doc.go</span><br><span class=\"line\">                │   └── register.go</span><br><span class=\"line\">                └── typed</span><br><span class=\"line\">                    └── samplecrd</span><br><span class=\"line\">                        └── v1</span><br><span class=\"line\">                            ├── doc.go</span><br><span class=\"line\">                            ├── fake</span><br><span class=\"line\">                            │   ├── doc.go</span><br><span class=\"line\">                            │   └── fake_samplecrd_client.go</span><br><span class=\"line\">                            ├── generated_expansion.go</span><br><span class=\"line\">                            └── samplecrd_client.go</span><br></pre></td></tr></table></figure>\n\n<p>其中，pkg/apis/samplecrd/v1 下面的 zz_generated.deepcopy.go 文件，就是自动生成的 DeepCopy 代码文件。</p>\n<p>而整个 client 目录，以及下面的三个包（clientset、informers、 listers），都是 Kubernetes 为 Network 类型生成的客户端库，这些库会在后面编写自定义控制器的时候用到。</p>\n<p>可以看到，到目前为止的这些工作，其实并不要求你写多少代码，主要考验的是“复制、粘贴、替换”这样的“基本功”。</p>\n<p>而有了这些内容，现在你就可以<font color=orange>在 Kubernetes 集群里创建一个 Network 类型的 API 对象了。</font>我们不妨一起来试验下。</p>\n<p><strong>首先，</strong> 使用 network.yaml 文件，在 Kubernetes 中创建 Network 对象的 CRD（Custom Resource Definition）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f crd/network.yaml</span><br><span class=\"line\">customresourcedefinition.apiextensions.k8s.io/networks.samplecrd.x-k8s.io created</span><br></pre></td></tr></table></figure>\n\n<p>这个操作，就告诉了 Kubernetes，我现在要添加一个自定义的 API 对象。而这个对象的 API 信息，正是 network.yaml 里定义的内容。我们可以通过 kubectl get 命令，查看这个 CRD：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get crd</span><br><span class=\"line\">NAME                                         CREATED AT</span><br><span class=\"line\">networks.samplecrd.x-k8s.io                  2022-03-08T07:26:58Z</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后，</strong>我们就可以创建一个 Network 对象了，这里用到的是 example-network.yaml：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f example/example-network.yaml</span><br><span class=\"line\">network.samplecrd.x-k8s.io/example-network created</span><br></pre></td></tr></table></figure>\n\n<p>通过这个操作，你就在 Kubernetes 集群里创建了一个 Network 对象。它的 API 资源路径是samplecrd.k8s.io/v1/networks。</p>\n<p>这时候，你就可以通过 kubectl get 命令，查看到新创建的 Network 对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get network</span><br><span class=\"line\">NAME              AGE</span><br><span class=\"line\">example-network   101s</span><br></pre></td></tr></table></figure>\n\n<p>你还可以通过 kubectl describe 命令，看到这个 Network 对象的细节：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe network example-network</span><br><span class=\"line\">Name:         example-network</span><br><span class=\"line\">Namespace:    default</span><br><span class=\"line\">Labels:       &lt;none&gt;</span><br><span class=\"line\">Annotations:  &lt;none&gt;</span><br><span class=\"line\">API Version:  samplecrd.x-k8s.io/v1</span><br><span class=\"line\">Kind:         Network</span><br><span class=\"line\">Metadata:</span><br><span class=\"line\">  Creation Timestamp:  2022-03-08T07:27:22Z</span><br><span class=\"line\">  Generation:          1</span><br><span class=\"line\">  Managed Fields:</span><br><span class=\"line\">    API Version:  samplecrd.x-k8s.io/v1</span><br><span class=\"line\">    Fields Type:  FieldsV1</span><br><span class=\"line\">    fieldsV1:</span><br><span class=\"line\">      f:metadata:</span><br><span class=\"line\">        f:annotations:</span><br><span class=\"line\">          .:</span><br><span class=\"line\">          f:kubectl.kubernetes.io/last-applied-configuration:</span><br><span class=\"line\">      f:spec:</span><br><span class=\"line\">        .:</span><br><span class=\"line\">        f:cidr:</span><br><span class=\"line\">        f:gateway:</span><br><span class=\"line\">    Manager:         kubectl-client-side-apply</span><br><span class=\"line\">    Operation:       Update</span><br><span class=\"line\">    Time:            2022-03-08T07:27:22Z</span><br><span class=\"line\">  Resource Version:  4582056</span><br><span class=\"line\">  UID:               86a7188c-4dec-4479-9e72-36ac92b0af63</span><br><span class=\"line\">Spec:</span><br><span class=\"line\">  Cidr:     192.168.0.0/16</span><br><span class=\"line\">  Gateway:  192.168.0.1</span><br><span class=\"line\">Events:     &lt;none&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当然 ，你也可以编写更多的 YAML 文件来创建更多的 Network 对象，这和创建 Pod、Deployment 的操作，没有任何区别。</p>\n"},{"title":"k8s心得","comments":1,"date":"2022-03-22T15:03:42.000Z","updated":"2022-04-03T15:03:42.000Z","desc":"k8s心得","keywords":"k8s, cloudnative","_content":"\n","source":"_posts/k8s心得.md","raw":"---\ntitle: k8s心得\ncomments: true\ndate: 2022-03-22 23:03:42\nupdated: 2022-04-03 23:03:42\ndesc: k8s心得\ncategories:\n    - [云原生, k8s]\ntags: \n    - k8s\nkeywords: k8s, cloudnative\n---\n\n","slug":"k8s心得","published":1,"_id":"cl1iyj6jn000008rb9s9dczgi","layout":"post","photos":[],"link":"","content":"","site":{"data":{"links":{"马以":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"马以的网站"},"Ant":{"link":"https://www.gxstax.top","avatar":"https://www.gxstax.top/images/avatar.jpg","desc":"Ant"}}}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cl063u5bd00008rrb8ylocx5k","category_id":"cl063uleq00058rrb5z97hix9","_id":"cl063uler00068rrb7hqa8ntp"},{"post_id":"cl063u5bd00008rrb8ylocx5k","category_id":"cl063wtdp0000asrb6en1cfqi","_id":"cl063wtds0001asrb6nhj9w05"},{"post_id":"cl064wjvl0000lcrb4qf56lth","category_id":"cl064wjvq0002lcrbcmk54q8e","_id":"cl064wjvy000dlcrbd27x1tw0"},{"post_id":"cl064wjvo0001lcrb7gs7f21i","category_id":"cl064wjvt0006lcrbd9x3bdvo","_id":"cl064wjvz000flcrb8xul95pe"},{"post_id":"cl064wjvr0004lcrbf7ah45dj","category_id":"cl064wjvv000blcrb2x7d87pw","_id":"cl064wjvz000hlcrbfybs2huc"},{"post_id":"cl064wjw2000jlcrb7shc8ffb","category_id":"cl064wjvq0002lcrbcmk54q8e","_id":"cl064wjw7000rlcrbad2vhids"},{"post_id":"cl064wjw4000olcrbbwui1fr0","category_id":"cl064wjvq0002lcrbcmk54q8e","_id":"cl064wjw8000wlcrbf5s8dk03"},{"post_id":"cl064wjw1000ilcrb97tk9o3f","category_id":"cl064wjw3000klcrbc9g72swh","_id":"cl064wjw90010lcrbel3m5uho"},{"post_id":"cl064wjw7000tlcrb4ou48xof","category_id":"cl064wjw8000xlcrb38un5h7x","_id":"cl064wjw90013lcrb3v84e5rk"},{"post_id":"cl064wjwa0014lcrbe8u0csrq","category_id":"cl064wjwc0016lcrb9ksp8amh","_id":"cl064wjwe001blcrbeljshnkc"},{"post_id":"cl064wjwa0015lcrbeqchhn80","category_id":"cl064wjwd0018lcrbcumd2g7z","_id":"cl064wjwe001dlcrbgpb82z5x"},{"post_id":"cl064wjw6000qlcrb4sh65cm7","category_id":"cl063uleq00058rrb5z97hix9","_id":"cl0651k6i0000vjrb70elhc7f"},{"post_id":"cl064wjw6000qlcrb4sh65cm7","category_id":"cl063wtdp0000asrb6en1cfqi","_id":"cl0651k6i0001vjrba9hw65os"},{"post_id":"cl064wjvs0005lcrbgr852olr","category_id":"cl063uleq00058rrb5z97hix9","_id":"cl0651z860002vjrbcr009hnp"},{"post_id":"cl064wjvs0005lcrbgr852olr","category_id":"cl063wtdp0000asrb6en1cfqi","_id":"cl0651z860003vjrba89t9i6n"},{"post_id":"cl064wjw3000mlcrb7zszb90u","category_id":"cl063uleq00058rrb5z97hix9","_id":"cl0652d8l0004vjrb3th0gqyr"},{"post_id":"cl064wjw3000mlcrb7zszb90u","category_id":"cl063wtdp0000asrb6en1cfqi","_id":"cl0652d8m0005vjrb4pi7dsyz"},{"post_id":"cl0htj09z0000lirbhnyg5eyy","category_id":"cl063uleq00058rrb5z97hix9","_id":"cl0htj0a20002lirb14ii5wqg"},{"post_id":"cl0htj09z0000lirbhnyg5eyy","category_id":"cl063wtdp0000asrb6en1cfqi","_id":"cl0htj0a20003lirbgo9q2nm9"},{"post_id":"cl1iyj6jn000008rb9s9dczgi","category_id":"cl063uleq00058rrb5z97hix9","_id":"cl1iykguw00000nrbbmkw24ze"},{"post_id":"cl1iyj6jn000008rb9s9dczgi","category_id":"cl063wtdp0000asrb6en1cfqi","_id":"cl1iykgux00010nrb4v9maqxf"}],"PostTag":[{"post_id":"cl063u5bd00008rrb8ylocx5k","tag_id":"cl063u5bi00028rrbgih98e6x","_id":"cl063u5bk00038rrbg1387pyq"},{"post_id":"cl064wjvs0005lcrbgr852olr","tag_id":"cl063u5bi00028rrbgih98e6x","_id":"cl064wjvu0008lcrb3qmj9xis"},{"post_id":"cl064wjvl0000lcrb4qf56lth","tag_id":"cl064wjvr0003lcrb7hvahcrj","_id":"cl064wjvv0009lcrb9gzla3gy"},{"post_id":"cl064wjvo0001lcrb7gs7f21i","tag_id":"cl064wjvt0007lcrb30oxgpxy","_id":"cl064wjvy000elcrb8tspbfb1"},{"post_id":"cl064wjvr0004lcrbf7ah45dj","tag_id":"cl064wjvx000clcrbhkxvhd6x","_id":"cl064wjvz000glcrb4plr6f2b"},{"post_id":"cl064wjw2000jlcrb7shc8ffb","tag_id":"cl064wjvr0003lcrb7hvahcrj","_id":"cl064wjw4000nlcrb84n74j2m"},{"post_id":"cl064wjw3000mlcrb7zszb90u","tag_id":"cl063u5bi00028rrbgih98e6x","_id":"cl064wjw6000plcrb4yka3idu"},{"post_id":"cl064wjw4000olcrbbwui1fr0","tag_id":"cl064wjvr0003lcrb7hvahcrj","_id":"cl064wjw7000slcrbhiqh8osn"},{"post_id":"cl064wjw1000ilcrb97tk9o3f","tag_id":"cl064wjw3000llcrb7uoi1szm","_id":"cl064wjw8000vlcrb8m5p11n5"},{"post_id":"cl064wjw6000qlcrb4sh65cm7","tag_id":"cl063u5bi00028rrbgih98e6x","_id":"cl064wjw9000zlcrb1vm8gt7b"},{"post_id":"cl064wjw7000tlcrb4ou48xof","tag_id":"cl064wjw9000ylcrb5zrr0o5o","_id":"cl064wjw90012lcrb1yhrfyz2"},{"post_id":"cl064wjwa0014lcrbe8u0csrq","tag_id":"cl064wjwc0017lcrb1urtfbhe","_id":"cl064wjwd001alcrbfn2u6zal"},{"post_id":"cl064wjwa0015lcrbeqchhn80","tag_id":"cl064wjwd0019lcrb1gktarhi","_id":"cl064wjwe001clcrbhbhbdvia"},{"post_id":"cl0htj09z0000lirbhnyg5eyy","tag_id":"cl063u5bi00028rrbgih98e6x","_id":"cl0htj0a10001lirbfpym3tgn"},{"post_id":"cl1iyj6jn000008rb9s9dczgi","tag_id":"cl063u5bi00028rrbgih98e6x","_id":"cl1iyj6js000108rbh1xqdwya"}],"Tag":[{"name":"k8s","_id":"cl063u5bi00028rrbgih98e6x"},{"name":"middleware","_id":"cl064wjvr0003lcrb7hvahcrj"},{"name":"java","_id":"cl064wjvt0007lcrb30oxgpxy"},{"name":"network","_id":"cl064wjvx000clcrbhkxvhd6x"},{"name":"jvm","_id":"cl064wjw3000llcrb7uoi1szm"},{"name":"db","_id":"cl064wjw9000ylcrb5zrr0o5o"},{"name":"linux","_id":"cl064wjwc0017lcrb1urtfbhe"},{"name":"linuxProgram","_id":"cl064wjwd0019lcrb1gktarhi"}]}}